<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="alternate" type="application/rss+xml" title="Verge's Blog" href="https://jysperm.me/atom.xml"><link rel="stylesheet" href="/styles.css"><title>Verge's Blog</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container"><div class="columns page-header"><h1>Verge's Blog</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="Verge's Blog" src="/favicon.png"></a><a href="/">Home</a></nav><nav class="right menus-right"><a href="/atom.xml">RSS</a><a target="_blank" href="hexo-theme-simpleblock">fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">与精子同款的博客主题 simpleblock 现已发布！</a></div><article><header><h2><a href="/2020/04/29/PHP/">PHP学习笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-04-29</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]



## 一些小细节

php代码需要写在`<?php ?>`之间

echo用来输出

php连接两个字符串使用`.`而不是`+`

php每条语句都以;结尾

`//`表示注释

## PHP的新东西

### 数组

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x = <span class="keyword">array</span>();</span><br></pre></td></tr></table></figure>

PHP有两种数组：索引数组、关联数组。

#### 索引数组

索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$fruit = <span class="keyword">array</span>(<span class="string">"苹果"</span>,<span class="string">"香蕉"</span>,<span class="string">"菠萝"</span>);</span><br></pre></td></tr></table></figure>

可以使用`print_r($fruit);`语句输出数组键及对应的值

##### 赋值

`$arr[0]='苹果';`

`array('0'=>'苹果');`

`array("苹果","香蕉");`

##### 读取

`$arr["0"];`/`$arr[0];`

 #### 关联数组

关联数组是指数组的键是字符串的数组

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$fruit = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'apple'</span>=&gt;<span class="string">"苹果"</span>,</span><br><span class="line">    <span class="string">'banana'</span>=&gt;<span class="string">"香蕉"</span>,</span><br><span class="line">    <span class="string">'pineapple'</span>=&gt;<span class="string">"菠萝"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

可以使用`print_r($fruit);`语句输出数组键及对应的值。

##### 赋值

`$arr['apple']='苹果';`

`array('apple'=>'苹果');`

##### 读取

`$fruit['banana'];`

### 类与对象

类是一类东西的结构描述，而对象则是一类东西的一个具体实例

定义一个类

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'汽车'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法内部可以使用$this伪变量调用对象的属性或者方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

对象通过new关键字进行实例化：

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">//也可以采用变量来创建</span></span><br><span class="line">$className = <span class="string">'Car'</span>;</span><br><span class="line">$car = <span class="keyword">new</span> $className();</span><br></pre></td></tr></table></figure>

#### 类的属性

在类中定义的变量称之为属性

属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成

public：公开的
protected：受保护的
private：私有的

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义公共属性</span></span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'汽车'</span>;</span><br><span class="line">    <span class="comment">//定义受保护的属性</span></span><br><span class="line">    <span class="keyword">protected</span> $corlor = <span class="string">'白色'</span>;</span><br><span class="line">    <span class="comment">//定义私有属性</span></span><br><span class="line">    <span class="keyword">private</span> $price = <span class="string">'100000'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

默认都为public，外部可以访问。一般通过->对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">echo</span> $car-&gt;name;   <span class="comment">//调用对象的属性</span></span><br><span class="line"><span class="keyword">echo</span> $car-&gt;color;  <span class="comment">//错误 受保护的属性不允许外部调用</span></span><br><span class="line"><span class="keyword">echo</span> $car-&gt;price; <span class="comment">//错误 私有属性不允许外部调用</span></span><br></pre></td></tr></table></figure>

受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $price = <span class="string">'1000'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;price; <span class="comment">//内部访问私有属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 类的方法

方法就是在类中的function

的方法也具有public，protected 以及 private 的访问控制。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'汽车'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">echo</span> $car-&gt;getName();</span><br></pre></td></tr></table></figure>

使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号::

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'汽车'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> Car::getName(); <span class="comment">//结果为“汽车”</span></span><br></pre></td></tr></table></figure>

#### 构造函数和析构函数

PHP5可以在类中使用**__construct()**定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"构造函数被调用\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">$car = <span class="keyword">new</span> Car(); <span class="comment">//实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串</span></span><br></pre></td></tr></table></figure>

在子类中如果定义了__construct则不会调用父类的__construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用



PHP5支持析构函数，使用**__destruct()**进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"构造函数被调用 \n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"析构函数被调用 \n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">$car = <span class="keyword">new</span> Car(); <span class="comment">//实例化时会调用构造函数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'使用后，准备销毁car对象 \n'</span>;</span><br><span class="line"><span class="keyword">unset</span>($car); <span class="comment">//销毁时会调用析构函数</span></span><br></pre></td></tr></table></figure>

#### 静态关键字

静态属性与方法可以在不实例化类的情况下调用，直接使用`类名::方法名`的方式进行调用。静态属性**不允许**对象使用->操作符调用。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $speed = <span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> Car::getSpeed();  <span class="comment">//调用静态方法</span></span><br></pre></td></tr></table></figure>

静态方法也可以通过变量来进行动态调用

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$func = <span class="string">'getSpeed'</span>;</span><br><span class="line">$className = <span class="string">'Car'</span>;</span><br><span class="line"><span class="keyword">echo</span> $className::$func();  <span class="comment">//动态调用静态方法</span></span><br></pre></td></tr></table></figure>

静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $speed = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$speed;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">speedUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$speed+=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::speedUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BigCar::start();</span><br><span class="line"><span class="keyword">echo</span> BigCar::getSpeed();</span><br></pre></td></tr></table></figure>

#### 访问控制

访问控制通过关键字public，protected和private来实现。

被定义为公有的类成员可以在任何地方被访问。

被定义为受保护的类成员则可以被其自身以及其子类和父类访问。

被定义为私有的类成员则只能被其定义所在的类访问。

默认为公有

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'object create'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $_object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="keyword">self</span>::$_object)) &#123;</span><br><span class="line">            <span class="keyword">self</span>::$_object = <span class="keyword">new</span> Car(); <span class="comment">//内部方法可以调用私有方法，因此这里可以创建对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::$_object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//$car = new Car(); //这里不允许直接实例化对象</span></span><br><span class="line">$car = Car::getInstance(); <span class="comment">//通过静态方法来获得一个实例</span></span><br></pre></td></tr></table></figure>

#### 对象继承

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">speedUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;speed += <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

使用extends

#### 重载

### cookie

#### 设置cookie

### 文件系统

### 异常处理

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//可能出现错误或异常的代码</span></span><br><span class="line">            <span class="comment">//catch表示捕获，Exception是php已定义好的异常类</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)&#123;</span><br><span class="line">            <span class="comment">//对异常处理，方法：</span></span><br><span class="line">                <span class="comment">//1、自己处理</span></span><br><span class="line">                <span class="comment">//2、不处理，将其再次抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 抛出异常

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建可抛出一个异常的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNum</span><span class="params">($number)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>($number&gt;<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"异常提示-数字必须小于等于1"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在 "try" 代码块中触发异常</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line">     checkNum(<span class="number">2</span>);</span><br><span class="line">     <span class="comment">//如果异常被抛出，那么下面一行代码将不会被输出</span></span><br><span class="line">     <span class="keyword">echo</span> <span class="string">'如果能看到这个提示，说明你的数字小于等于1'</span>;</span><br><span class="line"> &#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)&#123;</span><br><span class="line">     <span class="comment">//捕获异常</span></span><br><span class="line">     <span class="keyword">echo</span> <span class="string">'捕获异常: '</span> .$e-&gt;getMessage();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

#### 异常处理类

PHP具有很多异常处理类，其中Exception是所有异常处理的基类。

Exception具有几个基本属性与方法，其中包括了：

message 异常消息内容
code 异常代码
file 抛出异常的文件名
line 抛出异常在该文件的行数

其中常用的方法有：

getTrace 获取异常追踪信息
getTraceAsString 获取异常追踪信息的字符串
getMessage 获取出错信息

#### 捕获异常信息

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'wrong'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'Error:'</span>.$ex-&gt;getMessage().<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $ex-&gt;getTraceAsString().<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'异常处理后，继续执行其他代码'</span>;</span><br></pre></td></tr></table></figure>

#### 将错误信息写入错误日志

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'wrong'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">Exception</span> $ex) &#123;</span><br><span class="line">    $msg = <span class="string">'Error:'</span>.$ex-&gt;getMessage().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= $ex-&gt;getTraceAsString().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= <span class="string">'异常行号：'</span>.$ex-&gt;getLine().<span class="string">"\n"</span>;</span><br><span class="line">    $msg.= <span class="string">'所在文件：'</span>.$ex-&gt;getFile().<span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">//将异常信息记录到日志中</span></span><br><span class="line">file_put_contents(<span class="string">'error.log'</span>, $msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### PHP数据库

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$host = <span class="string">'127.0.0.1'</span>;</span><br><span class="line">$user = <span class="string">'code1'</span>;</span><br><span class="line">$pass = <span class="string">''</span>;</span><br><span class="line">mysql_connect($host,$user,$pass);<span class="comment">//连接数据库</span></span><br><span class="line">mysql_select_db(<span class="string">'code1'</span>);<span class="comment">//选择数据库</span></span><br><span class="line">mysql_query(<span class="string">"set names 'utf8'"</span>);<span class="comment">//设置字符编码</span></span><br></pre></td></tr></table></figure>

#### 查询

在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$res = mysql_query(<span class="string">'select * from user limit 1'</span>);</span><br></pre></td></tr></table></figure>

对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$row = mysql_fetch_array($res);</span><br><span class="line">var_dump($row);</span><br></pre></td></tr></table></figure>

#### 插入

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_query(<span class="string">"insert into user(name, age, class) values('李四', 18, '高三一班')"</span>); <span class="comment">//执行插入语句</span></span><br></pre></td></tr></table></figure>

在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$uid &#x3D; mysql_insert_id();</span><br></pre></td></tr></table></figure>

#### 取得数据查询结果

</div></article><article><header><h2><a href="/2020/04/27/jQuery/">jQuery学习笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-04-27</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]



## 环境搭建

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://www.imooc.com/static/lib/jquery/1.9.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>环境搭建<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span> alert($)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

想要使用jQuery只需要在\<head>标签中

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://www.imooc.com/static/lib/jquery/1.9.1/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

**注意：一定千万不要在引用jquery的script标签里再写js了，重新写一个script标签**

可以在这里https://jquery.com/download/下载使用jQuery的其他版本

网速慢的话

https://www.bootcdn.cn/jquery/

这样操作

## 选择器

### id选择器

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$( &quot;#id&quot; )</span><br></pre></td></tr></table></figure>

id若多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素，按理来说id需要唯一

### 类选择器

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".class"</span>)</span><br></pre></td></tr></table></figure>

假如你想改变某一类标签内容的样式可以直接使用`$(.class).css()`,不再像原生js一样需要循环

### 标签选择器

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"tag"</span>)</span><br></pre></td></tr></table></figure>

### 全能选择器

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"*"</span>)</span><br></pre></td></tr></table></figure>

获取文档中的所有元素

### 层级选择器

文档中的所有的节点之间都是有这样或者那样的关系。我们可以把节点之间的关系可以用传统的家族关系来描述，可以把文档树当作一个家谱，那么节点与节点直接就会存在父子，兄弟，祖孙的关系了。

![](http://img.mukewang.com/5590e98b0001f60d06130229.jpg)

### 基本筛选选择器

![](http://img.mukewang.com/57cd1df2000146de06020498.jpg)

假如你使用标签选择器选取了所有div标签，但是你只想要第一个就可以这样

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div:first"</span>)<span class="comment">//选择第一个</span></span><br><span class="line">$(<span class="string">"div:eq(0)"</span>)<span class="comment">//选择索引值为0的那个</span></span><br><span class="line">$(<span class="string">"div:lt(1)"</span>)<span class="comment">//选择索引值小于1的</span></span><br></pre></td></tr></table></figure>

### 内容筛选选择器

![](http://img.mukewang.com/57cd20bf0001a97f05290214.jpg)

1. :contains与:has都有查找的意思，但是contains查找包含“**指定文本**”的元素，has查找包含“**指定元素**”的元素
2. 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。
3. :parent与:empty是相反的，两者所涉及的子元素，包括文本节点

### 可见性筛选选择器

![](http://img.mukewang.com/5590f6de0001e2b204460106.jpg)

我们有几种方式可以隐藏一个元素：

1. CSS display的值是none。
2. type="hidden"的表单元素。
3. 宽度和高度都显式设置为0。
4. 一个祖先元素是隐藏的，该元素是不会在页面上显示
5. CSS visibility的值是hidden
6. CSS opacity的值是0

### 属性筛选选择器

![](http://img.mukewang.com/57d654200001c46507360560.jpg)

用法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"一个元素集合[属性 | 属性 运算符 "</span>value<span class="string">"]"</span>)</span><br></pre></td></tr></table></figure>

### 子元素筛选选择器

![](https://img3.mukewang.com/5bac45120001301105960331.jpg)

1. :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1)
2. :last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素
3. 如果子元素只有一个的话，:first-child与:last-child是同一个
4.  :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配
5. jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的
6. nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算

### 表单元素选择器

![img](http://img.mukewang.com/5592040d0001f8eb04940441.jpg)

#### 表单对象属性筛选选择器

![img](http://img.mukewang.com/55920c2f0001198b04940201.jpg)

### 特殊选择器this

> this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。
> $(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值

## 属性与样式

### attr()与.removeAttr()

用来获取和设置元素属性

**attr()有4个表达式**

1. attr(传入属性名)：获取属性的值
2. attr(属性名, 属性值)：设置属性的值
3. attr(属性名,函数值)：设置属性的函数值
4. attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … }

**removeAttr()删除方法**

.removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute）

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=<span class="string">"10086"</span>&gt;移动&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">$("#10086").attr(id,10001);</span></span><br><span class="line"><span class="regexp">$("#10001").attr(id);</span></span><br></pre></td></tr></table></figure>

### .html()及.text()

.html() 获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法：

1. .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容
2. .html( htmlString ) 设置每一个匹配元素的html内容
3. .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数

.text()

得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法：

1. .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代
2. .text( textString ) 用于设置匹配元素内容的文本
3. .text( function(index, text) ) 用来返回设置文本内容的一个函数





.html处理的是元素内容，.text处理的是文本内容

### .val()

**.val()方法**

主要是用于处理表单元素的值，比如 input, select 和 textarea。

1. .val()无参数，获取匹配的元素集合中第一个元素的当前值
2. .val( value )，设置匹配的元素集合中每个元素的值
3. .val( function ) ，一个用来返回设置值的函数

**.html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的"value"值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的"value"值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容**。

### .addClass()和removeClass()

**addClass( className )方法**

1. .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名
2. .addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名

**注意事项：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上</span><br></pre></td></tr></table></figure>

**.removeClass( )方法**

1. .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名
2. .removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名

**注意事项**

如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除

### .toggleClass()

一次执行相当于addClass，再次执行相当于removeClass

**.toggleClass( )方法：**在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类

1. .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名
2. .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除
3. .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值
4. .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数

**注意事项：**

1. toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加

### .css()

**获取：**

1. .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.css(<span class="string">"background-color"</span>)</span><br></pre></td></tr></table></figure>



1. .css( propertyNames )：传递一组数组，返回一个对象结果

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.css([<span class="string">'width'</span>,<span class="string">'height'</span>])</span><br></pre></td></tr></table></figure>



**设置：**

1.  .css(propertyName, value )：设置CSS

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.css(&quot;background-color&quot;,&quot;red&quot;)</span><br></pre></td></tr></table></figure>

2. .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.css(&quot;width&quot;,function(index,value)&#123;</span><br><span class="line">            &#x2F;&#x2F;value带单位，先分解</span><br><span class="line">            value &#x3D; value.split(&#39;px&#39;);</span><br><span class="line">            &#x2F;&#x2F;返回一个新的值，在原有的值上，增加50px</span><br><span class="line">            return (Number(value[0]) + 50) + value[1];</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

3. .css( properties )：可以传一个对象，同时设置多个样式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">css(&#123;</span><br><span class="line">            &#39;font-size&#39;        :&quot;15px&quot;,</span><br><span class="line">            &quot;background-color&quot; :&quot;#40E0D0&quot;,</span><br><span class="line">            &quot;border&quot;           :&quot;1px solid red&quot;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

## 结点创建与属性

### 创建

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;"</span>)</span><br></pre></td></tr></table></figure>

### 插入

![img](http://img.mukewang.com/56cc12f800017b4104480146.jpg)

.append(), 内容在方法的后面，参数是将要插入的内容。

.appendTo()刚好相反，内容在方法前面，无论是一个选择器表达式 或创建作为标记上的标记它都将被插入到目标容器的末尾

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append()前面是被插入的对象，后面是要在对象内插入的元素内容</span><br><span class="line">appendTo()前面是要插入的元素内容，而后面是被插入的对象</span><br></pre></td></tr></table></figure>

**作用是一样的**</div></article><article><header><h2><a href="/2020/04/26/CSS/">CSS学习笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-04-26</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

# CSS

穿衣服

## CSS语法

![CSS](http://img.mukewang.com/52fde5c30001b0fe03030117.jpg)

选择符又名选择器，指明网页中要应用样式规则的元素

**最后一条声明可以没有分号**

/*这样写注释\*/

## CSS的三种用法及优先级

### 内联式

直接写在标签中

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span></span><br><span class="line">    红</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p style="color:red">
    红
</p>
多条语句用;分开

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red;font-size:12px"</span>&gt;</span>红<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p style="color:red;font-size:36px">红</p>

### 嵌入式

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    p&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> &gt;</span></span><br><span class="line">    我是蓝的</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 外部式

创建一个单独的css文件

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"base.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

使用上面这句引用，通常写在head标签中

### 优先级

**内联式 > 嵌入式 > 外部式**

## 选择器

### 标签选择器

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure>

### 类选择器

使用"**.**"开头

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.1&#123;</span><br><span class="line">	color:pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    粉🐖</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

### ID选择器

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1&#123;</span><br><span class="line">	color:pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    粉🐖</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 类选择器和ID选择器的区别

1. ID选择器只可以使用一次，而类选择器可以使用多次

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>我不是<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>🐖<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

这是错的嗷

2. 还可以这样写

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.1&#123;</span><br><span class="line">	color:pink;</span><br><span class="line">&#125;</span><br><span class="line">.2&#123;</span><br><span class="line">	font-size:200px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">”1</span> <span class="attr">2</span>“&gt;</span>大粉🐖<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 亲戚关系选择器hhh

#### 子选择器

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>🐖<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.1</span>&gt;<span class="selector-tag">sapn</span>&#123;<span class="attribute">color</span>:pink&#125;</span><br></pre></td></tr></table></figure>

选择class名为1下的子元素\<span>

#### 后代选择器

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.1</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:pink&#125;</span><br></pre></td></tr></table></figure>

与子选择器的区别：子选择器只选择他的直接后代，而后代选择器把他的儿子孙子重孙都选上了,都变成粉色了

### 通用选择器

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">color</span>:pink;&#125;</span><br></pre></td></tr></table></figure>

这下所以标签的元素都成粉的了

### 伪类选择器

给不存在的标签（或标签的某种状态）设置样式

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:pink;&#125;</span><br></pre></td></tr></table></figure>

当鼠标经过时变粉

### 分组选择器

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:pink;&#125;</span><br></pre></td></tr></table></figure>

相当于

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:pink;&#125;</span><br><span class="line"><span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:pink;&#125;</span><br></pre></td></tr></table></figure>

## 继承，优先级和重要性

### 样式的继承性

什么是继承性？

允许样式不仅应用于某个特定html标签，而且应用于后代

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p&#123;color:red;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hhhhh<span class="tag">&lt;<span class="name">sapn</span>&gt;</span>wllll<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

hhhhh是红色，wllll也是红色

**但是某些CSS样式不具有继承性**

### 选择器的优先级

1、如果一个元素使用了多个选择器,则会按照选择器的优先级来给定样式。

2、选择器的优先级依次是: 内联样式 > id选择器 > 类选择器 > 标签选择器 > 通配符选择器

### 权值

**标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100**

若多个选择器匹配到了一个标签上，那么谁的权值高就显示谁的样式

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure>

### !important

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:green;&#125;</span><br><span class="line">&lt;p class="first"&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt;</span><br></pre></td></tr></table></figure>

带有!important的会被应用，无论其他的权值有多高

## 设置样式

### 关于字体

#### font-family

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"Microsoft Yahei"</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"微软雅黑"</span>;&#125;</span><br></pre></td></tr></table></figure>

#### font-size

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br></pre></td></tr></table></figure>

#### font-weight字体粗细

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p span&#123;font-weight:bold;&#125;</span><br></pre></td></tr></table></figure>

| 值                                  | 描述                                                        |
| :---------------------------------- | :---------------------------------------------------------- |
| normal                              | 默认值。定义标准的字符。                                    |
| bold                                | 定义粗体字符。                                              |
| bolder                              | 定义更粗的字符。                                            |
| lighter                             | 定义更细的字符。                                            |
| 100/200/300/400/500/600/700/800/900 | 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 |
| inherit                             | 规定应该从父元素继承字体的粗细。                            |

#### font-style字体样式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-style:normal;&#125;</span><br></pre></td></tr></table></figure>

| 值      | 描述                                   |
| :------ | :------------------------------------- |
| normal  | 默认值。浏览器显示一个标准的字体样式。 |
| italic  | 浏览器会显示一个斜体的字体样式。       |
| oblique | 浏览器会显示一个倾斜的字体样式。       |
| inherit | 规定应该从父元素继承字体样式。         |

#### color设置字体颜色

- 英文命令颜色

  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

- RGB 颜色

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;color:rgb(133,45,200);&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;color:rgb(20%,33%,25%);&#125;</span><br></pre></td></tr></table></figure>

- 十六进制颜色

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;color:#00ffff;&#125;</span><br></pre></td></tr></table></figure>

#### font家族的缩写

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-style</span>:italic;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold; </span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>; </span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">1.5em</span>; </span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这么多行的代码其实可以缩写为一句：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:italic  bold  <span class="number">12px</span>/<span class="number">1.5em</span>  <span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

1. **想要使用这种简写方式，至少要指定font-size和font-family，其他属性未指定则会使用默认值**
2. **在缩写时 font-size 与 line-height 中间要加入“/”斜扛**

### 关于文本

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">text-decoration</span>:none&#125;</span><br></pre></td></tr></table></figure>

#### text-decoration给文本添加修饰

| 值           | 描述                                            |
| :----------- | :---------------------------------------------- |
| none         | 默认。定义标准的文本。                          |
| underline    | 定义文本下的一条线。                            |
| overline     | 定义文本上的一条线。                            |
| line-through | 定义穿过文本下的一条线。                        |
| blink        | 定义闪烁的文本。                                |
| inherit      | 规定应该从父元素继承 text-decoration 属性的值。 |

#### text-indent为文本添加首行缩进

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;text-indent:2em;&#125;</span><br></pre></td></tr></table></figure>

1em 等于当前的字体尺寸。

2em 等于当前字体尺寸的两倍。

例如，如果某元素以 12pt 显示，那么 2em 是24pt。

在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体

#### line-height为文字间设置行间距/行高

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;line-height:1.5em;&#125;</span><br></pre></td></tr></table></figure>

#### letter/word-spacing增加或减少字符间的空白

`letter-spacing`为文字或字母中间设置间隔

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">letter-spacing</span>:<span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure>

`word-spacing`为单词之间设置间距

#### text-align设置文本对齐方式

为块状元素设置对齐方式

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;text-align:center&#125;</span><br></pre></td></tr></table></figure>

| 值      | 描述                                       |
| :------ | :----------------------------------------- |
| left    | 把文本排列到左边。默认值：由浏览器决定。   |
| right   | 把文本排列到右边。                         |
| center  | 把文本排列到中间。                         |
| justify | 实现两端对齐文本效果。                     |
| inherit | 规定应该从父元素继承 text-align 属性的值。 |

## 盒模型

### 概念

在CSS中，HTML中的标签，被分为三类

- 块状元素

  - ```html
    <div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form>
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 内联元素</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;html</span><br><span class="line">    &lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</span><br></pre></td></tr></table></figure>

- 内联块元素

  - ```html
    <img>、<input>
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 块级元素</span><br><span class="line"></span><br><span class="line">- 每个块级元素都从新的一行开始</span><br><span class="line">- 元素高度、宽度、行高、顶边底边距都可设置</span><br><span class="line">- 元素宽度在不设置的情况下，是他本身父容器的100%，即和父元素宽度一致</span><br><span class="line"></span><br><span class="line">通过</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">a&#123;display:block;&#125;</span><br></pre></td></tr></table></figure>

可以将内联元素转换为块状元素

#### 内联元素

- 和其他元素都在一行上
- 元素的高度、宽度及顶部和底部边距**不可**设置
- 元素的宽度就是它包含的文字或图片的宽度，不可改变

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">display</span>:inline;&#125;</span><br></pre></td></tr></table></figure>

可以将块状元素转换为内联元素

#### 内联块状元素

- 和其他元素在一行上
- 高宽，行高，顶底边距都可设置

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">display</span>:inline-block;&#125;</span><br></pre></td></tr></table></figure>

当display设置为none时，元素隐藏

### 使用

#### 盒模型基本知识

![](http://img.mukewang.com/543b4cae0001b34304300350.jpg)

- padding 是盒子里的内容到盒子边框的距离
- border 是盒子的边框
- margin 是盒子边框距离别的盒子边框的距离

![](http://img.mukewang.com/539fbb3a0001304305570259.jpg)

**css内定义的宽（width）和高（height），指的是填充以里的内容范围。**

**因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。**

#### background-color背景色

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div&#123;background-color:red;&#125;&#x2F;&#x2F;为块状元素设置</span><br><span class="line">a&#123;background-color:green;&#125;&#x2F;&#x2F;为行内元素设置</span><br></pre></td></tr></table></figure>

#### border为盒子添加边框

| 值             | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| *border-width* | 规定边框的宽度。参阅：[border-width](https://www.w3school.com.cn/cssref/pr_border-width.asp) 中可能的值。 |
| *border-style* | 规定边框的样式。参阅：[border-style](https://www.w3school.com.cn/cssref/pr_border-style.asp) 中可能的值。 |
| *border-color* | 规定边框的颜色。参阅：[border-color](https://www.w3school.com.cn/cssref/pr_border-color.asp) 中可能的值。 |

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border-width:2px;</span><br><span class="line">    border-style:solid;</span><br><span class="line">    border-color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

可以简写为

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    border:2px  solid  red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



##### border-方向 为盒子的某一边框设置样式

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;border-bottom/top/left/right:xxx xxx&#125;</span><br></pre></td></tr></table></figure>

##### border-radius 为边框四个角分别设置圆角

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure>

顺序为左上、右上、右下、左下

也可以分开写：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">border-top-right-radius</span>: <span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">border-bottom-right-radius</span>: <span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">border-bottom-left-radius</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

如果四个圆角都为10px;可以这么写：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">border-radius</span>:<span class="number">10px</span>;&#125;</span><br></pre></td></tr></table></figure>

如果左上角和右下角圆角效果一样为10px，右上角和左下角圆角一样为20px，可以这么写：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123; <span class="attribute">border-radius</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure>

需要特别注意的：一个正方形，当设置圆角效果值为元素宽度一半时，显示效果为圆形。例如：

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">100px</span>/<span class="number">50%</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

#### padding为盒子设置填充

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;padding:20px 10px 15px 30px;&#125;</span><br></pre></td></tr></table></figure>

上右下左

![](https://img.mukewang.com/5e95733a0001dead04210227.jpg)

其他设置方法与border-radius类似

#### margin为盒子设置外边距

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div&#123;margin:20px 10px 15px 30px;&#125;</span><br></pre></td></tr></table></figure>

![](https://img4.mukewang.com/5e95747a0001a39505090231.jpg)

一样

## 布局模型

### 流动模型（Flow）

默认的网页布局模式

特征

- 块状元素会在所处的包含元素内，自上而下垂直延申分布(默认状态下块元素的宽度为100%)
- 内联元素都会在包含元素内从左到右水平分布

### 浮动模型(Float)

可以设置两个块状元素显示一行

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">float</span>:left/right;&#125;</span><br></pre></td></tr></table></figure>

设置靠左or靠右

也可以分别设置，使之一个靠左一个靠右

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div1</span>&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line"><span class="selector-id">#div2</span>&#123;<span class="attribute">float</span>:right;&#125;</span><br></pre></td></tr></table></figure>

### 层模型

**关于文档流可以看这篇https://blog.csdn.net/wayne1998/article/details/80230608**

层模型有三种形式：

1、**绝对定位**(position: absolute)

这条语句的作用将元素从**文档流**中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于**浏览器窗口**。

2、**相对定位**(position: relative)

它通过left、right、top、bottom属性确定元素在**正常文档流中**的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。

**我的理解是，先正常生成元素，然后再浮起来，相对原来的位置进行移动**

![](http://img.mukewang.com/541a4bfc0001abef05940489.jpg)

3、**固定定位**(position: fixed)

fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（**屏幕内的网页窗口**）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 弹性盒模型

**这个好这个好https://www.jianshu.com/p/5856c4ae91f2**

弹性盒子由弹性容器和弹性子元素组成

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display:flex | inline-flex;</span><br></pre></td></tr></table></figure>

弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。

### 常用属性

| 属性            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| flex-direction  | 指定弹性容器中子元素排列方式                                 |
| flex-wrap       | 设置弹性盒子的子元素超出父容器时是否换行                     |
| flex-flow       | flex-direction 和 flex-wrap 的简写                           |
| align-items     | 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式               |
| align-content   | 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 |
| justify-content | 设置弹性盒子元素在主轴（横轴）方向上的对齐方式               |

#### flex-direction

决定子元素排列方向

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123; <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse; &#125;</span><br></pre></td></tr></table></figure>

| 值             | 描述                                     |
| -------------- | ---------------------------------------- |
| row            | 默认值。元素将水平显示，正如一个行一样。 |
| row-reverse    | 与 row 相同，但是以相反的顺序。          |
| column         | 元素将垂直显示，正如一个列一样。         |
| column-reverse | 与 column 相同，但是以相反的顺序。       |

![](https://upload-images.jianshu.io/upload_images/2326131-bbd36877856086ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/796/format/webp)

#### flex-wrap

flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。

| 值           | 描述                                               |
| ------------ | -------------------------------------------------- |
| nowrap       | 默认值。规定元素不拆行或不拆列。                   |
| wrap         | 规定元素在必要的时候拆行或拆列。                   |
| wrap-reverse | 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 |

可以取三个值：
（1） nowrap (默认)：不换行。



![img](https://upload-images.jianshu.io/upload_images/2326131-b71b6e4c79ceb64b.png?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

（2）wrap：换行，第一行在上方。



![img](https://upload-images.jianshu.io/upload_images/2326131-6de957f9ef4d43fa.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

（3）wrap-reverse：换行，第一行在下方。



![img](https://upload-images.jianshu.io/upload_images/2326131-b432b2461d51d73a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

#### flex-flow

flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123; <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt; &#125;</span><br></pre></td></tr></table></figure>

#### align-items

align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。

| 值         | 描述                           |
| ---------- | ------------------------------ |
| stretch    | 默认值。项目被拉伸以适应容器。 |
| center     | 项目位于容器的中心。           |
| flex-start | 项目位于容器的开头。           |
| flex-end   | 项目位于容器的结尾。           |
| baseline   | 项目位于容器的基线上。         |

![img](https:////upload-images.jianshu.io/upload_images/2326131-b3099f9b3e8bea50.png?imageMogr2/auto-orient/strip|imageView2/2/w/617/format/webp)

#### justify-content



justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。

| 值            | 描述                                             |
| ------------- | ------------------------------------------------ |
| flex-start    | 默认值。项目位于容器的开头。                     |
| flex-end      | 项目位于容器的结尾。                             |
| center        | 项目位于容器的中心。                             |
| space-between | 项目位于各行之间留有空白的容器内。               |
| space-around  | 项目位于各行之前、之间、之后都留有空白的容器内。 |

![img](https:////upload-images.jianshu.io/upload_images/2326131-86f8477572e8b976.png?imageMogr2/auto-orient/strip|imageView2/2/w/637/format/webp)

### 弹性子元素属性

| 属性        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| order       | 设置弹性盒子的子元素排列顺序。                               |
| flex-grow   | 设置或检索弹性盒子元素的扩展比率。                           |
| flex-shrink | 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 |
| flex-basis  | 用于设置或检索弹性盒伸缩基准值。                             |
| flex        | 设置弹性盒子的子元素如何分配空间。                           |
| align-self  | 在弹性子元素上使用。覆盖容器的 align-items 属性。            |

#### order属性

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">order</span>: &lt;integer&gt;; &#125;</span><br></pre></td></tr></table></figure>

<integer>：用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认为0。



![img](https:////upload-images.jianshu.io/upload_images/2326131-5466d2ec3968ca3b.png?imageMogr2/auto-orient/strip|imageView2/2/w/751/format/webp)

#### flex-grow属性



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">flex-grow</span>: &lt;integer&gt;; &#125;</span><br></pre></td></tr></table></figure>

<integer>：一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。



![img](https:////upload-images.jianshu.io/upload_images/2326131-189a57eada2a12a8.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

#### flex-shrink属性



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">flex-shrink</span>: &lt;integer&gt;; &#125;</span><br></pre></td></tr></table></figure>

<integer>：一个数字，规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。



![img](https:////upload-images.jianshu.io/upload_images/2326131-b55c4a8caa6d3a90.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/700/format/webp)

#### flex-basis属性



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">flex-basis</span>: &lt;integer&gt; | auto; &#125;</span><br></pre></td></tr></table></figure>

<integer>：一个长度单位或者一个百分比，规定元素的初始长度。
 auto：默认值。长度等于元素的长度。如果该项目未指定长度，则长度将根据内容决定。

#### flex属性

flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。

flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">flex</span>: flex-grow flex-shrink flex-basis | auto | initial | inherit; &#125;</span><br></pre></td></tr></table></figure>

| 值          | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| flex-grow   | 一个数字，规定项目将相对于其他元素进行扩展的量。             |
| flex-shrink | 一个数字，规定项目将相对于其他元素进行收缩的量。             |
| flex-basis  | 项目的长度。合法值："auto"、"inherit" 或一个后跟 "%"、"px"、"em" 或任何其他长度单位的数字。 |
| auto        | 与 1 1 auto 相同。                                           |
| none        | 与 0 0 auto 相同。                                           |
| initial     | 设置该属性为它的默认值，即为 0 1 auto。                      |
| inherit     | 从父元素继承该属性。                                         |

#### align-self属性



<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | stretch | center | flex-start | flex-end | baseline | initial | inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

| 值         | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| auto       | 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 "stretch"。 |
| stretch    | 元素被拉伸以适应容器。                                       |
| center     | 元素位于容器的中心。                                         |
| flex-start | 元素位于容器的开头。                                         |
| flex-end   | 元素位于容器的结尾。                                         |
| baseline   | 元素位于容器的基线上。                                       |
| initial    | 设置该属性为它的默认值。                                     |
| inherit    | 从父元素继承该属性。                                         |

![img](https:////upload-images.jianshu.io/upload_images/2326131-8dc02c66cf79f0e8.png?imageMogr2/auto-orient/strip|imageView2/2/w/743/format/webp)



**作者：弓三水**
**链接：https://www.jianshu.com/p/5856c4ae91f2**
**来源：简书**
**写的很全很好很厉害，直接复制了，方便以后查阅**

</div></article><article><header><h2><a href="/2020/04/26/graph/">图（Graph）</a></h2></header><div class="article-meta clearfix"><time class="left">2020-04-26</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

### 图（Graph）

- 表示多对多的关系
- 包含
  - 一组顶点:通常用V（Vertex）表示顶点集合
  - 一组边：通常用E（Edge）表示边的集合
    - 边是顶点对：（v,w）属于E，v,w属于V
    - 有向边<v,w>表示从v指向w的边（单行线）
    - 不考虑重边和自回路

#### 抽象数据类型定义

- 类型名称：图（Graph）
- 操作对象集：G（V，E）由一个非空的有限顶点集合V和一个有限边集合E组成
- 操作集
  - Graph Create()
  - Graph InsertVertex(Graph G,Vertex V)
  - Graph InsertEdge(Graph G,Edge e)
  - void DFS(Graph G,Vertex v)
  - void BFS(Graph G,Vertex v)
  - void ShortestPath(Graph G,Vertex v,int Dist[])
  - void MST(Graph G)最小生成树

#### 如何表示一个图

- 邻接矩阵
  - 有边记为1
  - 优缺点
    - 直观简单，方便查找任意一对顶点之间是否有边，方便查找任一顶点的所有邻接点（有边直接相连的顶点）
    - 方便计算任意顶点的度
      - 无向图：对应行或列非零元素个数
      - 有向图：非零行是出度，非零列的入度
    - 若是稀疏矩阵的话会造成空间浪费以及时间浪费

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//定点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    DataType Data[MaxVertexNum]; <span class="comment">//顶点包含的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br></pre></td></tr></table></figure>

MGraph创建并初始化

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)mallcon(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把Graph全部置为0</span></span><br><span class="line">    <span class="keyword">for</span>(V = <span class="number">0</span>;V &lt; Graph-&gt;Nv;V++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(W = <span class="number">0</span>;W &lt; Graph-&gt;Nv;W++)&#123;</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

向MGraph插入边

 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">	Vertex V1,V2;</span><br><span class="line">    WeightType Weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">	Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line">    <span class="comment">//若为无向图，则还要插入边（V2，V1）</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

建立完整的MGraph

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MGraph Grpah;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    scnaf(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));</span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)&#123;</span><br><span class="line">		E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;Ne;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读入数据</span></span><br><span class="line">        <span class="keyword">for</span>(V = <span class="number">0</span>;V &lt; Graph-&gt;Nv;V++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;Data[V]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**这个矩阵存的是顶点与顶点间的关系**

- 邻接表
  - 用一个指针数组，对应矩阵每行一个元素，只存非零元素
    - 优缺点
      - 对于稀疏矩阵在时间和空间上的表现都比较好
      - 方便找任意顶点的邻接点
      - 方便计算任一顶点的度
        - 无向图：是
        - 有向图：否，只能计算出度，需要构造逆邻接表
      - 难以检查任意一对顶点间是否存在边
- 用一个长为N(N+1)/2的一维数组表示
  - Gij在这个数组中对应的下标为(i*(i+1)/2+j) 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">Vnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PtrToAdjVNode FirstEdge;</span><br><span class="line">    DataType Data;</span><br><span class="line">&#125;AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Nv;</span><br><span class="line">    <span class="keyword">int</span> Ne;</span><br><span class="line">    AdjList G;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>



#### 图的遍历

##### 深度优先搜索(Depth First Search,DFS)

思路:从起点出发，挑视线内一盏灯点亮，然后走到刚刚点亮的等上，继续重复，如果视线内所有灯都被点亮，就原路返回，退后一格，然后继续看，直到退到起点

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">	visited[V] = ture;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点W)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[W]) DFS(W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

##### 广度优先搜素(Breath First Search,BFS)

与树的层序遍历类似

思路：从起点开始，把所有邻接点压入队列，然后弹出一个，再把这的结点的所有邻接点压入队列，重复直至队列空

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V,Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V的每个邻接点W)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[W])&#123;</span><br><span class="line">				visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W,Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 最短路问题

分类：

- 单源最短路径问题：从某固定点出发，求其到所有其他顶点的最短路径
  - 有向无权图
  - 有向有权图
- 多源最短路问题：求任意两顶点间的最短路径

##### 单源有向无权图的最短路

**无权图的最短路可以认为是，从起点到终点经过的顶点数最少的路**

与BFS有点类似

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unweighted</span><span class="params">(Vertex S)</span></span>&#123;</span><br><span class="line">	Enqueue(S,Q);<span class="comment">//先把这个结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">		 V = Dequeue(Q);<span class="comment">//弹出一个元素</span></span><br><span class="line">    	<span class="keyword">for</span>(V 的每个邻接点 W)<span class="comment">//遍历V的每个邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(dist[W] == <span class="number">-1</span>)&#123;<span class="comment">//如果W没有被访问过就执行以下操作</span></span><br><span class="line">			dist[W] = dist[V]+<span class="number">1</span>;<span class="comment">//S到W的距离变成，S到他前一个结点V的距离+1</span></span><br><span class="line">            path[W] = V;<span class="comment">//要到达W就要经过V，把v存起来</span></span><br><span class="line">            Enqueue(W,Q);<span class="comment">//把这个结点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为每次找的都是这个结点的邻接点，因此最后出来的结果是最短的

path存储来这个结点的结点，只要一直网下推，就能推出整条最短路

##### 单源有向有权图

**权重和最小 **

**Dijkatra算法**

- 令s = {源点s + 已经确定了从s到的最短路径的顶点v}
- 对于任何一个没有收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径**仅经过s中的顶点**，即{s -> (v属于s) -> v}的最小长度(这个最小长度不是最终的最小长度)
  - 前提条件：路径是按照递增的顺序生成的
  - 真正的最短路必须只经过s中的顶点，因为，假设一个顶点不在s中，但从源点到v经过他，这时就产生了矛盾，因为路径书按照递增顺序生成的
  - 每次从未收录的顶点中选一个dist最小的收录
  - 增加一个v进入s，可能会影响另外一个w的dist值 
    - 要产生这样的结果要满足
    - v在s到w的路径上
    - v到w一定有一条直接的边，因为路径按照递增顺序生成

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        V = 为收录顶点中dist最小者;</span><br><span class="line">        <span class="keyword">if</span>(这样的V不存在) <span class="keyword">break</span>;</span><br><span class="line">        collected[V] = <span class="literal">true</span>;<span class="comment">//用来标记结点是否被收录</span></span><br><span class="line">        <span class="keyword">for</span>(V 的每个邻接点 W)</span><br><span class="line">            <span class="keyword">if</span>(collected[W] == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span>(dist[V] + E(v到w的距离) &lt; dist[W])&#123;<span class="comment">//如果原来s到w的距离大于，s到v加上v到w的距离那么就改变s到w的最短路径</span></span><br><span class="line">                    dist[W] = dist[V]+E(V到W的距离);</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><article><header><h2><a href="/2020/04/23/Regular-expression/">正则表达式</a></h2></header><div class="article-meta clearfix"><time class="left">2020-04-23</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'a1b2c3'</span>;</span><br><span class="line">string = string.replace(<span class="regexp">/[abc]/g</span>, <span class="string">'X'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string);</span><br></pre></td></tr></table></figure>



在JavaScript中创建一个正则表达式对象

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">RegExp</span>();</span><br><span class="line"><span class="keyword">var</span> b = <span class="regexp">/表达式/</span>属性(g/i/m)</span><br></pre></td></tr></table></figure>

正则表达式由两种基本字符类型组成

- 原义文本字符

  - 代表要查找文本的原本意思的字符

- 元字符

  - 在正则表达式中有特殊含义的非字母字符

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*+?$^.|\()[]&#123;&#125;</span><br></pre></td></tr></table></figure>



### 字符类

- 一般情况下正则表达式一个字符对应字符串一个字符

- 要匹配某类字符使用`[]`构建一个类
  - 类指符合某些特征的对象
  - `[abc]`意思就是把abc归为一类，匹配这类字符
  - `[^abc]`就是匹配出除abc以外的字符

### 范围类

- 可以使用`[a-z]`表示匹配a到z的任意字符
- `[a-zA-Z]`表示匹配a到z和A到Z的任意字符

### 预定义类

| 字符 | 等价类          | 含义                           |
| ---- | --------------- | ------------------------------ |
| .    | [^\r\n]         | 除了回车、换行符之外的其他字符 |
| \d   | [0-9]           | 数字字符                       |
| \D   | [^0-9]          | 非数字字符                     |
| \s   | [\t\n\x0B\f\r]  | 空白符                         |
| \S   | [^\t\n\x0B\f\r] | 非空白符                       |
| \w   | [a-zA-Z_0-9]    | 单词字符(字母、数字、下划线)   |
| \W   | [^a-zA-Z_0-9]   | 非单词字符                     |

### 边界

- `\b`单词边界,`\B`非单词边界
- `^`表示以...开始，`$`表示以...结束

### 量词

| 字符  | 含义            |
| ----- | --------------- |
| ?     | 0或1 次         |
| +     | ≥1 次           |
| *     | ≥0 次（任意次） |
| {n}   | n 次            |
| {n,m} | n到m 次         |
| {n,}  | ≥n 次           |

#### 贪婪模式

尽可能多的匹配

例如有一个字符串12345678

`\d{3,6}`这样进行匹配的话结果是123456，并非123或1234或....

#### 非贪婪模式

尽量少的匹配，一旦匹配成功就不再继续尝试

`\d{3,6}`结果是123，456

**JS默认使用贪婪模式，想使用非贪婪模式在量词后加上`?`即可**

### 分组

使用`()`进行分组

假如你想匹配一个小写字母加数字连续出现3次就可以这样写`([a-z]\d){3}`,而这样是不行的`[a-z]\d{3}`这样结果是匹配一个字母加三个数字

#### 或

`|`表示或

假如想匹配123345和124445就可以这样写`12(33|44)45`

感觉功能上和`[]`有**一点点**重叠

#### 反向引用

假如你想把2020-4-24变为24/4/2020就可以这样写`(\d{4})-(\d{2}|\d{1})-(\d{2}|\d{1})`

然后使用`$1$2$3`捕获分组写成`$3/$2/$1`

#### 忽略分组

假如你不想捕获某个分组就可以

这样`(\d{4})-(\d{2}|\d{1})-(?:\d{2}|\d{1})`这样就匹配不到日期了,$3就是没内容的

### 前瞻&后顾

文本头叫前文本尾部叫后

前瞻就是在正则表达式匹配带规则时，向前检查是否符合断言，后顾与之相反

**JS不支持后顾**

既要符合exp正则，又要满足断言要求

**正向/肯定 匹配**：符合特定断言
**负向/否定 匹配**：不符合特定断言

| 名称     | 正则写法      | 含义                            |
| -------- | ------------- | ------------------------------- |
| 正向前瞻 | exp(?=assert) | 符合exp正则，且符合设置的断言   |
| 负向前瞻 | exp(?!assert) | 符合exp正则，且不符合设置的断言 |

**断言部分只作为约束条件而存在，并不会参与字符本身的匹配和替换，匹配字符的是exp正则部分**

假如你想匹配一个字母后加一个数字，但是只替换字母就可以

这样`a1aaa3`一个字符串`[a-z](?=\d)`

### RegExp对象属性

| 名称       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| global     | `g`：全文搜索，默认false                                     |
| ignoreCase | `i`：大小写敏感，默认false                                   |
| multiline  | `m`：多行搜索，默认false                                     |
| lastIndex  | 下次匹配的起始位置 该属性只有设置标志`g`才能使用，实现遍历检索匹配 |
| source     | 正则的文本字符串（正则主体）                                 |

gim这三个对象都是只读的

### RegExp对象方法

#### test()方法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg1.test(字符串)</span><br></pre></td></tr></table></figure>

返回true或false，测试字符串参数中是否存在所匹配正则的字符串

非全局调用

默认从字符串第一个字符出发，找到第一个符合条件的子字符串就停止

全局调用

如果reg1标志g的话，lastIndex就会起作用，可以通过不断调用reg1.test()对字符串进行遍历，找出所有符合条件的子字符串

每调用一次reg1.test()就会使lastIndex移动到上一次找出的字符串的最后一个字符的下一个字符上，当找不到符合条件的子字符串时，会将lastIndex重置为0

![](https://upload-images.jianshu.io/upload_images/4866277-b79894ead9358586.png?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp)

#### exec()方法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg1.exec(字符串);</span><br></pre></td></tr></table></figure>

全局调用

返回一个数组，包含额外的属性 `index` 和 `input`，找不到返回null

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/quick\s(brown).+?(jumps)/ig</span>;</span><br><span class="line"><span class="keyword">var</span> result = re.exec(<span class="string">'The Quick Brown Fox Jumps Over The Lazy Dog'</span>);</span><br></pre></td></tr></table></figure>

| 属性/索引         |描述                                | 例子                                                |
| ---------------- | ------------------  ------------- | ------------------------------------------------- |
|`[0]`             |匹配的全部字符串                      |`Quick Brown Fox Jumps`                             |
| `[1], ...[*n* ]` |括号中的分组捕获                      |`[1] = Brown[2] = Jumps`                           |
|`index`           |匹配到的字符位于原始字符串的基于0的索引值 | `4`                                                |
| `input`          |原始字符串                           | `The Quick Brown Fox Jumps Over The Lazy Dog` |

非全局调用

与test()方法类似

</div></article><article><header><h2><a href="/2020/03/30/JavaScript/">JavaScript学习笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-30</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

## 插入JS

使用\<script>\</script>标签

<q>\<script type="text/javascript"></q>固定写法

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    JS写在这里</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

JS也可以单独存在类似CSS

在JS文件中不需要\<script>标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js文件的路径"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

通过上面这句来引用js文件

JS一般放在\<head>或\<body>里，浏览器读到时就会运行

## 基础

1. js的每句代码结束都需要;
2. 用//添加注释，/\*注释内容\*/实现多行注释
3. 使用var声明变量
   - JS中变量区分大小写
4. if和else用法与C语言几乎一样
5. 函数使用function定义

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

定义好后不会自己执行，需要调用

### 输出

#### document.write()

1. 直接使用引号

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">"哈哈"</span>);</span><br></pre></td></tr></table></figure>

2. 输出变量

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"hahah"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str);</span><br></pre></td></tr></table></figure>

3. 输出多项内容

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"java"</span>;</span><br><span class="line">documen.write(str+<span class="string">"script"</span>);</span><br></pre></td></tr></table></figure>

4. 输出html标签

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">documen.write(<span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure>

#### alert()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量)；</span><br></pre></td></tr></table></figure>

弹出一个消息对话框，包含一个确定按钮

**点击确定前不能进行其他任何操作**

### 互动

#### confirm()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure>

str是在对话框中显示的内容

返回值是Boolean

用户点击确定时返回ture，取消返回false

#### prompt()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1,str2);</span><br></pre></td></tr></table></figure>

str1是在对话框中显示的文本

str2是文本框中的内容

点确定返回文本框中的内容，取消返回null

### 窗口

#### window.open()

**注意使用单引号**

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">'URL'</span>,<span class="string">'窗口名称'</span>,<span class="string">'参数字符串,多个用逗号隔开'</span>);</span><br></pre></td></tr></table></figure>

- URL可选，在窗口中显示网页的网址或路径。如果省略，那么窗口就不显示任何文档

- 窗口名称可选，被打开窗口的名称

>  1.该名称由字母、数字和下划线字符组成。
>       2."_top"、"_blank"、"_self"具有特殊意义的名称。
>          _blank：在新窗口显示目标网页
>          _self：在当前窗口显示目标网页
>          _top：框架网页中在上部窗口中显示目标网页
>       3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
>      4.name 不能包含有空格。

- 窗口字符串

![windowstr](http://img.mukewang.com/52e3677900013d6a05020261.jpg)

sample

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"> <span class="built_in">window</span>.open(<span class="string">'http://www.imooc.com'</span>,<span class="string">'_blank'</span>,<span class="string">'width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口

#### window.close()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();<span class="comment">//关闭本窗口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> mywin=<span class="built_in">window</span>.open(<span class="string">'http://www.imooc.com'</span>); <span class="comment">//将新打的窗口对象，存储在变量mywin中</span></span></span><br><span class="line">   mywin.close();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 练习

> 1、新窗口打开时弹出确认框，是否打开
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示: 使用 if 判断确认框是否点击了确定，如点击弹出输入对话框，否则没有任何操作。</span><br></pre></td></tr></table></figure>
>
> 2、通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/
>
> 3、打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span> new document <span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=gbk"</span>/&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span>  </span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">openWindow</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> sta = confirm(<span class="string">"是否打开窗口"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(sta == <span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> url = prompt(<span class="string">"请填写网址"</span>,<span class="string">" http：//www.imooc.com/"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.open(<span class="string">'url'</span>,<span class="string">'width=400,height=500,toolbar=no,menubar=no'</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"新窗口打开网站"</span> <span class="attr">onclick</span>=<span class="string">"openWindow()"</span> /&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 变量

#### 声明

Javascript使用

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br></pre></td></tr></table></figure>

声明变量，可以存储数字、字符、字符串

#### 表达式

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"goodbye"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"verge"</span>;</span><br><span class="line"><span class="keyword">var</span> c = a + b;</span><br><span class="line">alert(c);</span><br></pre></td></tr></table></figure>

结果是goodbyeverge

### 数组

#### 声明

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>

在括号内指定数组长度，虽然数组长度已经确定，但仍可以将数据储存在规定长度之外

#### 赋值

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">myarr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myarr[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

实现同样的效果还有两种方法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = [<span class="number">1</span>,<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

可以使用未使用的下标，不断给数组添加成员

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarr[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

数组没有赋值直接输出的话会输出undefined

#### 数组长度

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarr.length;</span><br></pre></td></tr></table></figure>

可以使用

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarr.length = 一个数字;<span class="comment">//改变数组长度</span></span><br></pre></td></tr></table></figure>

在你改变数组长度后，即使里面什么都没存，长度还是你改变后的。

如果，一个数组是这样var arr = [1,2,3] 长度为3，如果这是你进行 arr.length = 2,那么长度就会变成2，会把原来arr[2]的位置变为undefined

数组元素增加长度也会改变

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">alert(myarr.length);</span><br><span class="line">myarr[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">alert(myarr.length);</span><br></pre></td></tr></table></figure>

#### 二维数组

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myarr[][];</span><br></pre></td></tr></table></figure>

##### 定义

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//先声明一维 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   <span class="comment">//一维长度为2</span></span><br><span class="line">   myarr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//再声明二维 </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;   <span class="comment">//二维长度为3</span></span><br><span class="line">   		myarr[i][j]=i+j;   <span class="comment">// 赋值，每个数组元素的值为i+j</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]];<span class="comment">//两行三列</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

 ### 函数

#### 定义

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funname</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 调用函数

1. 在\<script>标签内直接调用

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	funname();    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

2.  在HTML文件中调用，通过点击按钮调用定义好的函数

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">           <span class="function"><span class="keyword">function</span> <span class="title">add2</span><span class="params">()</span></span></span></span><br><span class="line">           &#123;</span><br><span class="line">                 sum = 5 + 6;</span><br><span class="line">                 alert(sum);</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"click it"</span> <span class="attr">onclick</span>=<span class="string">"add2()"</span>&gt;</span>  //按钮,onclick点击事件，直接写函数名</span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

#### 含有参数的函数

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(x+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 有返回值的函数

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(x+y);</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = add(x,y);</span><br></pre></td></tr></table></figure>

## 事件

事件是可以被Javascript侦测到的行为

![](http://img.mukewang.com/53e198540001b66404860353.jpg)

### onclick 鼠标点击事件

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">"button"</span> <span class="attr">value</span> = <span class="string">"点我调用add()"</span> <span class="attr">onclick</span>=<span class="string">"add()"</span> &gt;</span></span><br></pre></td></tr></table></figure>

### onload 加载事件

加载页面时会触发onload事件

可以理解为打开页面时会出发的事件

### onubload卸载事件

当用户刷新，关闭页面时触发的事件

### 其他事件使用方式大同小异

## 对象

### 什么是对象

JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有**属性**和**方法**。

**对象的属性：**反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等；

**对象的方法：**能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；**就是在对象的基础上再进行操作**



JavaScript 提供多个内建对象，比如 String、Date、Array 等等，使用对象前先定义，如下使用数组对象：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  var objectName &#x3D;new Array();&#x2F;&#x2F;使用new关键字定义对象</span><br><span class="line">或者</span><br><span class="line">  var objectName &#x3D;[];</span><br></pre></td></tr></table></figure>

**访问对象属性的语法:**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.propertyName</span><br></pre></td></tr></table></figure>

如使用 Array 对象的 length 属性来获得数组的长度：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myarray&#x3D;new Array(6);&#x2F;&#x2F;定义数组对象</span><br><span class="line">var myl&#x3D;myarray.length;&#x2F;&#x2F;访问数组长度length属性</span><br></pre></td></tr></table></figure>

**以上代码执行后，myl的值将是：6**

**访问对象的方法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectName.methodName()</span><br></pre></td></tr></table></figure>

如使用string 对象的 toUpperCase() 方法来将文本转换为大写：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var mystr&#x3D;&quot;Hello world!&quot;;&#x2F;&#x2F;创建一个字符串</span><br><span class="line">var request&#x3D;mystr.toUpperCase(); &#x2F;&#x2F;使用字符串对象方法</span><br></pre></td></tr></table></figure>

以上代码执行后，request的值是**：HELLO WORLD!**

### Date 日期对象

可以存储任意一个日期，可以精确到毫秒

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>

初始值为当前电脑系统世间

自定义初始值可以

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Apr 23,2020'</span>);</span><br></pre></td></tr></table></figure>

我们最好使用下面介绍的“方法”来严格定义时间。

**访问方法语法：**“<日期对象>.<方法>”

Date对象中处理时间和日期的常用方法：

![](http://img.mukewang.com/555c650d0001ae7b04180297.jpg)

#### 返回/设置年份的方法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">mydate.setFullYear(<span class="number">20</span>);<span class="comment">//不同浏览器结果不同，有可能是20或0020</span></span><br><span class="line"><span class="keyword">var</span> myyear = mydate.getFullYear();</span><br></pre></td></tr></table></figure>

#### 返回星期方法

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydate.getDay()<span class="comment">//返回的是0-6的一个数字，0是周日</span></span><br></pre></td></tr></table></figure>

#### 返回/设置时间的方法

**get/setTime()** 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。

时间加一小时就是

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydate.setTime(mydate.getTime()+<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

### String 字符串对象

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"jinxuyang"</span>;</span><br><span class="line"><span class="keyword">var</span> srtlen = str.length;<span class="comment">//返回字符串长度</span></span><br><span class="line"><span class="keyword">var</span> STR = str.toUpperCase();<span class="comment">//转换为大写,toLowerCase()转换为小写</span></span><br></pre></td></tr></table></figure>

#### charAT() 返回指定位置的字符

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringOject.charAt(index)</span><br></pre></td></tr></table></figure>

参数index即字符在字符串中的下标

返回一个字符长度为1的字符串

#### indexOf() 返回指定的字符串首次出现的位置

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.indexOf(substring, startpos)</span><br></pre></td></tr></table></figure>

![](http://img.mukewang.com/53853d4200019feb04920149.jpg)

返回需要检索的字符串的第一个字符第一次出现的位置，如果没有则返回-1

#### split() 字符串分割

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.split(separator,limit)</span><br></pre></td></tr></table></figure>

![](http://img.mukewang.com/532bee4800014c0404230108.jpg)

如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。

若达到分割的次数之后，后面分割出来的字串就不会输出，或者说到达分割的次数之后就不再分割

#### substring() 提取字符串

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.substring(startPos,stopPos)</span><br></pre></td></tr></table></figure>

![](http://img.mukewang.com/532bf1bb000151af04450082.jpg)

startPos和stopPos可以理解为字符串数组开始和结束的下标，两个参数相等的话就返回一个空串，如果stop比start大会先交换这两个参数

stopPos

假设一个字符串是abcdefg那么substring(0,4)提取出来的结果是abcd，到stopPos结束，并不包括stopPos

#### substr() 提取指定数目字符串

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.substr(startPos,length)</span><br></pre></td></tr></table></figure>

![](http://img.mukewang.com/532bf2e00001105305100098.jpg)

**注意：**如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。

如果startPos为负数且绝对值大于字符串长度，startPos为0

#### search() 检索字符串中指定的子字符串（正则）

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.search(reg/str)</span><br></pre></td></tr></table></figure>

返回第一个匹配结果的index，查找不到返回-1

search()不执行全局匹配，总是从字符串的开始进行检索

#### match() 检索字符串找到一个或多个与RegExp匹配的文本

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.match(regexp)</span><br></pre></td></tr></table></figure>

参数

- `regexp`

  一个[正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)对象。如果传入一个非正则表达式对象，则会隐式地使用 `new RegExp(obj)` 将其转换为一个 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 。如果你没有给出任何参数并直接使用match() 方法 ，你将会得到一 个包含空字符串的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array) ：[""] 。

返回值

- 如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。
- 如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（`Array`）。 在这种情况下，返回的项目将具有如下所述的其他属性。

附加属性

如上所述，匹配的结果包含如下所述的附加特性。

- `groups`: 一个捕获组数组 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)（如果没有定义命名捕获组）。
- `index`: 匹配的结果的开始位置
- `input`: 搜索的字符串.

描述

如果正则表达式不包含 `g `标志，`str.match()` 将返回与 [`RegExp.exec()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec). 相同的结果。

#### replace() 替换字符串中指定子字符串或正则匹配的结果

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.replace(regexp,<span class="string">"替换成的内容"</span>)</span><br><span class="line">str.replace(<span class="string">"要替换的内容"</span>，<span class="string">"替换成的内容"</span>)</span><br></pre></td></tr></table></figure>



### Math 对象

**注意：**Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。

Math 对象属性

![](http://img.mukewang.com/532fe7cf0001e7b505170269.jpg)

Math对象方法

![](http://img.mukewang.com/532fe841000174db05160622.jpg)

### Array 数组对象

#### concat() 数组连接

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.concat(array1,array2,...,arrayN)</span><br></pre></td></tr></table></figure>

返回一个连接后的数组，不会改变原来的数组

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mya = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">  mya[<span class="number">0</span>] = <span class="string">"1"</span>;</span><br><span class="line">  mya[<span class="number">1</span>] = <span class="string">"2"</span>;</span><br><span class="line">  mya[<span class="number">2</span>] = <span class="string">"3"</span>;</span><br><span class="line">  <span class="built_in">document</span>.write(mya.concat(<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

可以这样写直接给数组后面在加上4，5，**注意并不改变mya数组**

#### join() 指定分隔符连接数组元素

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.join(分隔符)</span><br></pre></td></tr></table></figure>

若参数留空则默认使用，分开

#### reverse() 颠倒数组元素顺序

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.reverse()</span><br></pre></td></tr></table></figure>

**注意：**该方法会改变原来的数组，而不会创建新的数组。

#### slice() 选定元素

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.slice(start,end)</span><br></pre></td></tr></table></figure>

![](http://img.mukewang.com/533299680001637b05160145.jpg)

返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素

#### sort() 数组排序

**sort()**方法使数组中的元素按照一定的顺序排列。

**语法:**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.sort(方法函数)</span><br></pre></td></tr></table></figure>

**参数说明：**

![img](http://img.mukewang.com/53329a2a000127f705170060.jpg)

1.如果不指定<方法函数>，则按unicode码顺序排列。

2.如果指定<方法函数>，则按<方法函数>所指定的排序方法排序。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myArray.sort(compareFunction);</span><br></pre></td></tr></table></figure>

如果没有指明 `compareFunction` ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 "Banana" 会被排列到 "cherry" 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 `compareFunction`），比较的数字会先被转换为字符串，所以在Unicode顺序上 "80" 要比 "9" 要靠前。

如果指明了 `compareFunction` ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：

- 如果 `compareFunction(a, b)` 小于 0 ，那么 a 会被排列到 b 之前；

- 如果 `compareFunction(a, b)` 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；

- 如果 `compareFunction(a, b)` 大于 0 ， b 会被排列到 a 之前。
- `compareFunction(a, b)` 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。

所以，比较函数格式如下：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b ) &#123;           <span class="comment">// 按某种排序标准进行比较, a 小于 b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// a must be equal to b</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

具体实现

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sortNum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line"> <span class="comment">//升序，如降序，把“a - b”该成“b - a”</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"80"</span>,<span class="string">"16"</span>,<span class="string">"50"</span>,<span class="string">"6"</span>,<span class="string">"100"</span>,<span class="string">"1"</span>);</span><br><span class="line">  <span class="built_in">document</span>.write(myarr + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">  <span class="built_in">document</span>.write(myarr.sort(sortNum));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

**运行结果：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">80,16,50,6,100,1</span><br><span class="line">1,6,16,50,80,100</span><br></pre></td></tr></table></figure>

### window对象

![](http://img.mukewang.com/535483720001a54506670563.jpg)

### JavaScript定时器

![](http://img.mukewang.com/56976e1700014fc504090143.jpg)

#### setInterval()

载入页面后每隔指定时间执行代码

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(代码，交互时间)</span><br></pre></td></tr></table></figure>

代码：要执行的代码

交互时间：周期执行的时间间隔，单位毫秒

返回值：是一个值，可以把这个值传给clearInterval()从而取消setInterval()的执行

**调用函数格式(**假设有一个clock()函数**):**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval(&quot;clock()&quot;,1000)</span><br><span class="line">或</span><br><span class="line">setInterval(clock,1000)</span><br></pre></td></tr></table></figure>

#### clearInterval()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clearInterval(id_of_setInterval)</span><br></pre></td></tr></table></figure>

#### setTimeout()

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(代码，延迟时间);</span><br></pre></td></tr></table></figure>

延迟时间到后执行代码

#### clearTimeout()

与clearInterval()相似

### history对象

history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。

**注意:从\**窗口\**被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。**

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.[属性|方法]</span><br></pre></td></tr></table></figure>

**注意：**window可以省略。

**History 对象属性**

[![img](http://img.mukewang.com/53548c030001759e05840068.jpg)](http://img.mukewang.com/53548c030001759e05840068.jpg)

**History 对象方法**

**[![img](http://img.mukewang.com/53548c200001228206210123.jpg)](http://img.mukewang.com/53548c200001228206210123.jpg)**

使用length属性，当前窗口的浏览历史总长度，**代码如下：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var HL &#x3D; window.history.length;</span><br><span class="line">  document.write(HL);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

#### go()



语法：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.go(number);</span><br></pre></td></tr></table></figure>

**参数：**

[![img](http://img.mukewang.com/5354947e00011a9a06490153.jpg)](http://img.mukewang.com/5354947e00011a9a06490153.jpg)





### location对象

location用于获取或设置窗体的URL，并且可以用于解析URL。

**语法:**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.[属性|方法]</span><br></pre></td></tr></table></figure>

**location对象属性图示:**

[![img](http://img.mukewang.com/53605c5a0001b26909900216.jpg)](http://img.mukewang.com/53605c5a0001b26909900216.jpg)

**location 对象属性：**

**[![img](http://img.mukewang.com/5354b1d00001c4ec06220271.jpg)](http://img.mukewang.com/5354b1d00001c4ec06220271.jpg)**

**location 对象方法:**

**[![img](http://img.mukewang.com/5354b1eb00016a2405170126.jpg)](http://img.mukewang.com/5354b1eb00016a2405170126.jpg)**



### navigator对象

![](http://img.mukewang.com/5354cff70001428b06880190.jpg)



## DOM

### 什么是DOM

参考<a href="https://www.runoob.com/htmldom/htmldom-nodes.html" target="_blank" rel="noopener">这个</a>

### 获取元素

#### getElementById

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"id"</span>);</span><br></pre></td></tr></table></figure>

**获取的元素是一个对象，想要对这个元素操作还需要其他东西**

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span></span><br><span class="line">    documen.write(str);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

这样是**错误**的

#### getElementsByName

Element比上面那个多了个s

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByName();</span><br></pre></td></tr></table></figure>

由于name属性可能是不唯一的，因此返回值是元素数组，同样也有length属性

#### getElementsByTagName

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementsByTagName(Tagname)</span><br></pre></td></tr></table></figure>

 Tagname是标签的名称，如p、a、img等标签名

返回值也是数组也有length

#### getAttribute()

通过元素结点的属性名获取属性的值

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementNode.getAttribute(name)</span><br></pre></td></tr></table></figure>

### 操作元素



#### setAttribute()

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementNode.setAttribute(name,value)</span><br></pre></td></tr></table></figure>

1.name: 要设置的属性名。

2.value: 要设置的属性值

**注意：**

1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。

#### innerHTML

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.innerHTML</span><br></pre></td></tr></table></figure>

object是获取的元素

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span></span><br><span class="line">    documen.write(str.innerHTML);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

这样就对了

#### 改变HTML样式

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.style.property=new style;</span><br></pre></td></tr></table></figure>

object是获取的元素

property

![111](http://img.mukewang.com/52e4d4240001dd6c04850229.jpg)

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.innerHTML);</span></span><br><span class="line"><span class="actionscript">    str.style.color=<span class="string">"pink"</span>;<span class="comment">//变粉</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

#### 显示和隐藏

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.style.display = <span class="string">"value"</span>;</span><br></pre></td></tr></table></figure>

value的值

![display](http://img.mukewang.com/52e4dba5000179da04110095.jpg)

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.innerHTML);</span></span><br><span class="line"><span class="actionscript">    str.style.color=<span class="string">"pink"</span>;<span class="comment">//变粉</span></span></span><br><span class="line"><span class="actionscript">    str.style.display=<span class="string">"none"</span>;<span class="comment">//隐藏</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

#### 控制类名

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.className = <span class="string">"classname"</span>;</span><br></pre></td></tr></table></figure>

获取元素class属性

为元素指定一个css样式

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.innerHTML);</span></span><br><span class="line"><span class="actionscript">    str.style.color=<span class="string">"pink"</span>;<span class="comment">//变粉</span></span></span><br><span class="line"><span class="actionscript">    str.style.display=<span class="string">"none"</span>;<span class="comment">//隐藏</span></span></span><br><span class="line"><span class="actionscript">    str.classNme = <span class="string">"hahaha"</span><span class="comment">//改变元素类名</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.ha</span>&#123;<span class="attribute">color</span>:pink;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.hahaha</span>&#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">class</span>=<span class="string">"ha"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

### 结点属性

在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：

1. nodeName : 节点的名称

2. nodeValue ：节点的值

3. nodeType ：节点的类型

**一、nodeName 属性:** 节点的名称，是只读的。

1. 元素节点的 nodeName 与标签名相同
2. 属性节点的 nodeName 是属性的名称
3. 文本节点的 nodeName 永远是 #text
4. 文档节点的 nodeName 永远是 #document

**二、nodeValue 属性：**节点的值

1. 元素节点的 nodeValue 是 undefined 或 null
2. 文本节点的 nodeValue 是文本自身
3. 属性节点的 nodeValue 是属性的值

**三、nodeType 属性:** 节点的类型，是只读的。以下常用的几种结点类型:

**元素类型   节点类型**
 元素      1
 属性      2
 文本      3
 注释      8
 文档      9

### 访问结点

#### 访问子节点childNodes

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementNode.childNodes</span><br></pre></td></tr></table></figure>

返回值是所有子节点的列表，可以看作数组，没有子节点则返回一个不包含结点的列表

##### 访问子节点的第一项和最后一项

一、**`firstChild `**属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.firstChild</span><br></pre></td></tr></table></figure>

**说明：**与elementNode.childNodes[0]是同样的效果。 

二、**` lastChild`** 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.lastChild</span><br></pre></td></tr></table></figure>

**说明：**与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 

#### 访问父节点parentNode

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementNode.parentNode</span><br></pre></td></tr></table></figure>

一个结点只能有一个父结点

#### 访问兄弟结点

1. nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeObject.nextSibling</span><br></pre></td></tr></table></figure>

**说明：**如果无此节点，则该属性返回 null。

2. previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodeObject.previousSibling</span><br></pre></td></tr></table></figure>

**说明：**如果无此节点，则该属性返回 null。

### 插入结点

#### appendChild()

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.appendChild(newnode)</span><br></pre></td></tr></table></figure>

在指定节点的**最后一个子节点**列表之后添加一个新的子节点。

这里的newnode需要使用`document.createElement("标签")`来创建

#### insertBefore()

方法在参考节点之前插入一个拥有指定父节点的子节点

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.insertBefore(newnode,node);</span><br></pre></td></tr></table></figure>

newnode: 要插入的新节点。

node: 指定此节点前插入节点。

而所谓的“拥有指定父节点”，就是指被参照的节点的父节点就是调用insertBefore方法的节点。

如果给定的子节点是对文档中现有节点的引用，insertBefore()会将其从当前位置移动到新位置。

如果给定的子节点是DocumentFragment，那么DocumentFragment的全部内容将被移动到指定父节点的子节点列表中。

### 删除节点

#### removeChild()

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let oldChild &#x3D; node.removeChild(child);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;OR</span><br><span class="line"></span><br><span class="line">element.removeChild(child);</span><br></pre></td></tr></table></figure>

- `child` 是要移除的那个子节点.
- `node` 是`child`的父节点.
- oldChild保存对删除的子节点的引用. `oldChild` === `child`.

被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如`上例中的oldChild`来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被[内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)回收.

#### replaceChild()

replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 

**语法：**

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.replaceChild (newnode,oldnew )</span><br></pre></td></tr></table></figure>

**参数：**

newnode : 必需，用于替换 oldnew 的对象。 
oldnew : 必需，被 newnode 替换的对象。</div></article><article><header><h2><a href="/2020/03/28/HTML/">HTML学习笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-28</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

# html

## 基础

### html文件的基本结构

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注释是这样写的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这里是head,title里的内容会显示在浏览器标题栏里<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里是body<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

## 标签

### 这些都很简单

#### body标签

一般网页需要展示出来的内容就存放在body标签里

#### p标签

段落标签

#### hx标签

共有h1到h6六个从大到小的标签

#### em和strong标签

em是<em>斜体</em>，strong是<strong>加粗</strong>

#### span标签

span本身没有什么作用，它就是用来设置单独的样式用的

#### q标签

短文本引用，引用后会自动给引用的部分加上引号

#### blockquote标签

<blockquote>长文本引用，这个不会加引号，但是会产生缩进</blockquote>

![blockquote](http://img.mukewang.com/528c50ea000146a205520264.jpg)

#### br标签和\&nbsp;

html中回车空格是无效的，换行需要\<br />或\<br>(常用\<br />)

br与其他标签不同的是，br不需要成对出现

\&nbsp;就代表空格

#### hr标签

效果

<hr>

写成\<hr>或\<hr />

#### address标签

效果

<address>陕西西安</address>

#### code标签

效果

<code>while(1)</code>

#### pre标签

插入大段代码

<pre>
    #include<iostream>
    using namespace std;
    int main(){
		cout << "Hello Word" << endl;
	}
</pre>

### 列表/表格

#### ul ol标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>456<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>789<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
    <li>123</li>
    <li>456</li>
    <li>789</li>
</ul>

无序列表\<ul>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>456<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>789<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
    <li>123</li>
    <li>456</li>
    <li>789</li>
</ol>

有序列表\<ol>

#### div标签

可以用来划分区域

#### table标签和caption标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">summary</span>=<span class="string">”这里的文字不会显示，增加表格可读性“</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果不加&lt;thead&gt;&lt;tbody&gt;&lt;tfooter&gt; , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caotion</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">caotion</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="comment">&lt;!--表格的行--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="comment">&lt;!--th是表格的表头--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>学生数<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>平均成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>一班<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--一个单元格，有几个就说明表格有几列--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>89<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>35<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>85<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table summary=”这里的文字不会显示，增加表格可读性“>
    <tbody>
         <caotion>这是标题</caotion>
        <tr>
          <th>班级</th>
          <th>学生数</th>
          <th>平均成绩</th>
        </tr>
        <tr>
          <td>一班</td>
          <td>30</td>
          <td>89</td>
        </tr>
        <tr>
          <td>二班</td>
          <td>35</td>
          <td>85</td>
        </tr>
    </tbody>
</table>

### 进阶

#### a标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">"目标网址"</span>  <span class="attr">title</span>=<span class="string">"鼠标滑过显示的文本"</span>&gt;</span>链接显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a  href="baidu.com"  title="鼠标滑过显示的文本">链接显示的文本</a>

默认情况下链接的网页是在档期浏览器窗口打开

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">"目标网址"</span>  <span class="attr">title</span>=<span class="string">"鼠标滑过显示的文本"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>链接显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

z这样写就是在新窗口打开

#### malito标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:981340404@qq.com?cc=jinxuyang3@gmail.com&amp;subject=我觉得你很帅&amp;body=真的"</span>&gt;</span>发送<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a href="mailto:981340404@qq.com?cc=jinxuyang3@gmail.com&subject=我觉得你很帅&body=真的">发送</a>

mailto后若有多个参数的话，第一个参数用?开头，后面跟的参数用&开头

mailto后是**":"**,其他参数后是**"="**

![mailto](http://img.mukewang.com/52da4f2a000150b714280550.jpg)

#### img标签

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">alt</span>=<span class="string">"下载失败时的替换文本"</span> <span class="attr">title</span> = <span class="string">"提示文本"</span>&gt;</span></span><br></pre></td></tr></table></figure>

图片使用**src**标识位置

**alt**当图像不可见时，显示的文本

<img src="" alt="就显示这个">

**title**鼠标滑过时显示的文本

img也不需要成对出现

### 表单

**可以把用户输入内容传到服务端**

\<form>标签成对出现

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>    <span class="attr">method</span>=<span class="string">"post"</span>   <span class="attr">action</span>=<span class="string">"save.php"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"pass"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

**method**数据的传输方式（get/post）

**action**数据被传送到的地方

**所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在  标签之间**

#### 文本/密码输入框

\<input />单独出现

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text/password"</span> <span class="attr">name</span>=<span class="string">"名称"</span> <span class="attr">value</span>=<span class="string">"文本"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

type="text"时文本输入框

type="password"时是密码输入框

name：文本框命名

value：文本框默认值，不输入时显示的内容

<form>
    <input type="text" name="account" value="value里显示的" /><br />
    <input type="password" name="account" value="123123123" />
</form>

#### 多行文本输入

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"行数"</span> <span class="attr">cols</span>=<span class="string">"列数"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<textarea rows="5" cols="5"></textarea>

#### 单选框/复选框

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio/checkbox"</span> <span class="attr">value</span>=<span class="string">"值"</span> <span class="attr">name</span>=<span class="string">"名称"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

- **type**

=radio为单选框

=checkbox为复选框

- value提交到服务器的值
- name为控件命名
- check=checked时该项默认勾选

**同一组的单选按钮name一定要相同这样才能实现单选**

<form>
    <label>你是人</label>
    <input type="radio" value="1" name="单选" />
    <br \>
    <label>你不是🐖</label>
    <input type="radio" value="1" name="单选" />
</form>
<hr \>
<form>
	1<input type="checkbox" value="1" name="1" />
    2<input type="checkbox" value="1" name="2" />
    3<input type="checkbox" value="1" name="3" checked="checked"/>
</form>



#### 下拉列表框

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'1'</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'2'</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

- value是向服务器提交的值
- selected="selected"表示该项默认选中,没有这个默认第一项

<select>
	<option value='1'>1</option>
    <option value='2' selected="selected">2</option>
</select>

##### 使用下拉列表框进行多选

再\<select>中添加multiple="mutiple"

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'1'</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">'2'</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<select multiple="multiple">
	<option value='1'>1</option>
    <option value='2'>2</option>
</select>

#### 提交/重置按钮

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit/reset"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

- type="submit"这样设置才是提交按钮
- value按钮上显示的内容

<form>
    <input type="submit" value="提交" />
    <input type="reset" value="重置" />
</form>

#### label标签

本来要选中控件就需要点中控件本身，有了label就可以把某些文字与控件关联，实现点击文字就聚焦到控件上

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"1"</span>&gt;</span>你是🐖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"r"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"2"</span>&gt;</span>你是人<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">name</span>=<span class="string">"r"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"2"</span>&gt;</span>你是🐖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"r"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"1"</span>&gt;</span>你是人<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"2"</span> <span class="attr">name</span>=<span class="string">"r"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<form>
    <label for="1">你是🐖</label>
    <input type="radio" id="1" name="r"/>
    <label for="2">你是人</label>
    <input type="radio" id="2" name="r"/>
</form>

<form>
    <label for="2">你是🐖</label>
    <input type="radio" id="1" name="r"/>
    <label for="1">你是人</label>
    <input type="radio" id="2" name="r"/>
</form></div></article><article><header><h2><a href="/2020/03/23/string/">算法竞赛入门经典笔记</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-23</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

## 数组

### 程序3-1 逆序输出

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105 </span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x) == <span class="number">1</span>)</span><br><span class="line">        a[n++] = x;<span class="comment">//读取，先赋值a[n]＝x，然后执行n＝n＋1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);<span class="comment">//逆序输出	</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[<span class="number">0</span>]);<span class="comment">//最后一个输出后跟换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**数组声明在main函数外可以开的更大**

数组不可以直接b=a，但可以使用memcpy(b,a,sizeof(int)*k),这个函数中的int需要根据数据类型不同，进行改变。这个函数包含在string.h中

### 程序3-2 开灯问题

>开灯问题。有n盏灯，编号为1～n。第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉灯
>将被打开，开着的灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？输入n和k，输出开着的灯的编号。k≤n≤1000。
>
>样例输入：
>7 3
>样例输出：
>1 5 6 7

模拟题

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1010</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, first = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));<span class="comment">//初始化数组</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);<span class="comment">//n盏灯，k个人</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    		<span class="keyword">if</span>(j % i == <span class="number">0</span>) a[j] = !a[j];<span class="comment">//j%i==0可以计算出i的倍数，符合条件就改变灯的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//循环输出</span></span><br><span class="line">    	<span class="keyword">if</span>(a[i]) &#123; <span class="comment">//灯开着就输出</span></span><br><span class="line">            <span class="keyword">if</span>(first) first = <span class="number">0</span>; <span class="comment">//第一个进行特殊化处理，放在第一个的原因是，最后一个不好找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>); </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

>蛇形填数。在n×n方阵里填入1，2，…，n×n，要求填成蛇形。例如，n＝4时方阵为：
>10 11 12 1
>9   16  13  2
>8 15 14   3
>7 6 5       4

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, y, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);<span class="comment">//读方阵边长</span></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    tot = a[x=<span class="number">0</span>][y=n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    上面这句其实就是</span></span><br><span class="line"><span class="comment">    x = 0;</span></span><br><span class="line"><span class="comment">    y = n-1;</span></span><br><span class="line"><span class="comment">    a[x][y] = 1;  </span></span><br><span class="line"><span class="comment">    tot = 1;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(tot &lt; n*n)&#123; <span class="comment">//向四个方向移动，先判断是否到达边界，是否已经来过，再移动，再赋值，</span></span><br><span class="line">        <span class="keyword">while</span>(x+<span class="number">1</span>&lt;n &amp;&amp; !a[x+<span class="number">1</span>][y]) a[++x][y] = ++tot;</span><br><span class="line">        <span class="keyword">while</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !a[x][y<span class="number">-1</span>]) a[x][--y] = ++tot;</span><br><span class="line">        <span class="keyword">while</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !a[x<span class="number">-1</span>][y]) a[--x][y] = ++tot;</span><br><span class="line">        <span class="keyword">while</span>(y+<span class="number">1</span>&lt;n &amp;&amp; !a[x][y+<span class="number">1</span>]) a[x][++y] = ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; n; x++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(y = <span class="number">0</span>; y &lt; n; y++) <span class="built_in">printf</span>(<span class="string">"%3d"</span>, a[x][y]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔。因为“悔棋”往往比较麻烦。**

**细心的读者也许会发现这里的一个“潜在bug”：如果越界，x+1会等a[x+1][y]将访问非法内存！幸运的是，这样的担心是不必要的。“&&”是短路运算符（还记得我们在哪里提到过吗？）。如果x+1<n为假，将不会计算“!a[x+1][y]”，也就不会越界了。**



## 字符数组





### 程序3-4　竖式问题

> 竖式问题。找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出(为了便于观察，竖式中的空格改用小数点显示，但所写程序中应该输出空格，而非小数点）。
> 样例输入：
> 2357
> 样例输出：
> <1>
> ..775
>
> X..33
>
> .2325
>
> 2325.
>
> 25575
> The number of solutions = 1

伪代码

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> abc = <span class="number">111</span>; abc &lt;= <span class="number">999</span>; abc++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> de = <span class="number">11</span>; de &lt;= <span class="number">99</span>; de++)</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">"abc*de"</span>是个合法的竖式)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"&lt;%d&gt;\n"</span>, count);</span><br><span class="line">			打印abc*de的竖式和其后的空行</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The number of solutions = %d\n"</span>, count);</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">20</span>], buf[<span class="number">99</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> abc = <span class="number">111</span>; abc &lt;= <span class="number">999</span>; abc++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> de = <span class="number">11</span>; de &lt;= <span class="number">99</span>; de++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x = abc * (de % <span class="number">10</span>), y = abc * (de / <span class="number">10</span>), z = abc * de;<span class="comment">//模拟竖式计算过程</span></span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">"%d%d%d%d%d"</span>, abc, de, x, y, z);<span class="comment">//把这个竖式 的所有字符放入buf中</span></span><br><span class="line">			<span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(buf); i++)<span class="comment">//遍历buf的所有字符</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strchr</span>(s, buf[i]) == <span class="literal">NULL</span>) ok = <span class="number">0</span>;<span class="comment">//如果buf里有一个字符在s中找不到，就不符合要求，ok=0不输出</span></span><br><span class="line">			<span class="keyword">if</span> (ok)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"&lt;%d&gt;\n"</span>, ++count);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%5d\nX%4d\n-----\n%5d\n%4d\n-----\n%5d\n\n"</span>, abc, de, x, y, z);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The number of solutions = %d\n"</span>, count);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### strchr():

​	原型：

​		char *strchr(const char *str, int c)

​	参数：

​		str--要被检索的C字符串

​		c--在str中要搜索的字符

​	返回值：

​		该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。

#### sprintf()：

​	将格式化的数据写入字符串	

​	原型：

​		 int sprintf(char *str, char * format [, argument, ...]);

​	参数：		

​		str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量

​	返回值：

​			成功则返回参数str 字符串长度，失败则返回-1

#### strlen()：

​	返回字符串实际长度

#### scanf("%s", s)

​	使用该函数读取字符串，当遇到空格或TAB时，不会将他们读入

## 竞赛题目选讲



### 例题3-2　WERTYU（WERTYU, UVa10082）

> 把手放在键盘上时，稍不注意就会往右错一位。这样，输入Q会变成输入W，输入J会变成输入K等。键盘如图3-2所示。
> 输入一个错位后敲出的字符串（所有字母均大写），输出打字员本来想打出的句子。输入保证合法，即一定是错位之后的字符串。例如输入中不会出现大写字A。
> 样例输入：
> O S, GOMR YPFSU/
> 样例输出：
> I AM FINE TODAY.

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./"</span>;<span class="comment">//常量数组，真好！！！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, c;</span><br><span class="line">	<span class="keyword">while</span> ((c = getchar()) != EOF) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; s[i] &amp;&amp; s[i] != c; i++); <span class="comment">//找错位之后的字符在常量表中的位置</span></span><br><span class="line">		<span class="keyword">if</span> (s[i]) <span class="built_in">putchar</span>(s[i - <span class="number">1</span>]); <span class="comment">//如果找到，则输出它的前一个字符</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">putchar</span>(c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**主要是常量数组的使用**

> 输入一个字符串，判断它是否为回文串以及镜像串。输入字符串保证不含数字0。所谓回文串，就是反转以后和原串相同，如abba和madam。所有镜像串，就是左右镜像之后和原串相同，如2S和3AIAE。注意，并不是每个字符在镜像之后都能得到一个合法字符。在本题中，每个字符的镜像如图3-3所示（空白项表示该字符镜像后不能得到一个合法字符）。
> ![8qbomF.png](https://s1.ax1x.com/2020/03/24/8qbomF.png)
> 输入的每行包含一个字符串（保证只有上述字符。不含空白字符），判断它是否为回文
> 串和镜像串（共4种组合）。每组数据之后输出一个空行。
> 样例输入：
> NOTAPALINDROME
> ISAPALINILAPASI
> 2A3MEAS
> ATOYOTA
> 样例输出：
> NOTAPALINDROME -- is not a palindrome.
> ISAPALINILAPASI -- is a regular palindrome.
> 2A3MEAS -- is a mirrored string.
> ATOYOTA -- is a mirrored palindrome.

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rev = <span class="string">"A   3  HIL JM O   2TUVWXY51SE Z  8 "</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* msg[] = &#123;<span class="string">"not a palindrome"</span>, <span class="string">"a regular palindrome"</span>, <span class="string">"a mirrored string"</span>,</span><br><span class="line"><span class="keyword">char</span> r(<span class="keyword">char</span> ch) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch)) <span class="keyword">return</span> rev[ch - <span class="string">'A'</span>];<span class="comment">//如果ch是个字母，就返回ch-'A'(这个的意思就是在rev中的序号)</span></span><br><span class="line">	<span class="keyword">return</span> rev[ch - <span class="string">'0'</span> + <span class="number">25</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s) == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);<span class="comment">//读取字符串实际长度</span></span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">1</span>, m = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len + <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;<span class="comment">//只要一半符合要求即可确定，因为回文串和镜像串从中间分开，两头都存在一定的关系，因此i &lt; (len + i) / 2</span></span><br><span class="line">			<span class="keyword">if</span> (s[i] != s[len - <span class="number">1</span> - i]) p = <span class="number">0</span>; <span class="comment">//不是回文串,len-1-i实现倒序</span></span><br><span class="line">			<span class="keyword">if</span> (r(s[i]) != s[len - <span class="number">1</span> - i]) m = <span class="number">0</span>; <span class="comment">//不是镜像串</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s -- is %s.\n\n"</span>, s, msg[m * <span class="number">2</span> + p]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**头文件ctype.h中定义的isalpha，isdigit，isorint可以用来判断字符的属性，toupper，tolower可以用来转换大小写**

### 例题3-4　猜数字游戏的提示（Master-Mind Hints, UVa 340）

>实现一个经典"猜数字"游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。
>输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。
>
>样例输入：
>4
>1 3 5 5
>1 1 2 3
>4 3 3 5
>6 5 5 1
>6 1 3 5
>1 3 5 5
>0 0 0 0
>10
>1 2 2 2 4 5 6 6 6 9
>1 2 3 4 5 6 7 8 9 1
>1 1 2 2 3 3 4 4 5 5
>1 2 1 3 1 5 1 6 1 9
>1 2 2 5 5 5 6 6 6 7
>0 0 0 0 0 0 0 0 0 0
>
>样例输出：
>Game 1:
>(1,1)
>(2,0)
>(1,2)
>(1,2)
>(4,0)
>Game 2:
>(2,4)
>(3,2)
>(5,0)
>(7,0)
>
>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1010</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line">	<span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123; <span class="comment">//n=0时输入结束</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Game %d:\n"</span>, ++kase);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);<span class="comment">//读入答案</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);<span class="comment">//读入用户猜的序列</span></span><br><span class="line">				<span class="keyword">if</span> (a[i] == b[i]) A++; <span class="comment">//相同位置，且相同的用A来记</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//正常的猜测序列不会有0，所以只判断第一个数是否为0即可</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">				<span class="keyword">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>; <span class="comment">//统计数字d在答案序列和猜测序列中各出现多少次</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[i] == d) c1++;</span><br><span class="line">					<span class="keyword">if</span> (b[i] == d) c2++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (c1 &lt; c2) B += c1; <span class="keyword">else</span> B += c2;</span><br><span class="line">			&#125;<span class="comment">//刘老师真是nb，这里把答案数组和用户数组的每一位拿出来和1-9分别比较，统计每一个数字出现的次数，然后输出两个计数器中值小的一个（一旦小的都大于等于1，就说明两个数列中都含有这个数）</span></span><br><span class="line">            <span class="number">1355</span></span><br><span class="line">            <span class="number">1123</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" (%d,%d)\n"</span>, A, B - A);<span class="comment">//B-A总数-位置相同的，就是。。。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 例题3-5　生成元（Digit Generator, ACM/ICPC Seoul 2005, UVa1583）

> 如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。

**为了节省空间，提升效率，可以一次性把100000内所有数字的生成元计算出来，然后输出时直接调用**

**一个数的生成元可能有多个**



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T, n;</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span>(ans));<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; maxn; m++) &#123;<span class="comment">//</span></span><br><span class="line">		<span class="keyword">int</span> x = m, y = m;</span><br><span class="line">		<span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123; y += x % <span class="number">10</span>; x /= <span class="number">10</span>; &#125;<span class="comment">//把x拆分，各项相加</span></span><br><span class="line">		<span class="keyword">if</span> (ans[y] == <span class="number">0</span> || m &lt; ans[y]) ans[y] = m;<span class="comment">//把这个数的生成元存到数组里，下标为数字，值为生成元</span></span><br><span class="line">        <span class="comment">//有点难理解，可以让m=198自行尝试一下，就会发现其实这个程序是倒着来的，是已知某个数的生成元，然后再计算出这个数</span></span><br><span class="line">        <span class="comment">//一个数的生成元是不唯一的，因此需要ans[y] == 0 || m &lt; ans[y]进行限制</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 例题3-6　环状序列（Circular Sequence, ACM/ICPC Seoul 2004, UVa1584）

> 长度为n的环状串有n种表示法，分别为从某个位置开始顺时针得到。例如，图3-4的环状串有10种表示：
>
> [![8juuRJ.png](https://s1.ax1x.com/2020/03/25/8juuRJ.png)](https://imgchr.com/i/8juuRJ)
>
> CGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称为"最小表示"。
> 输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是CCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。

**我理解能力不行，基本上每个题都要看原题才看得懂（可以上vj上看）**

**字典序（lexicographical order）：就是字符串在字典中的排序。abc比bcd小，hi比his小，1，2，4，7比1，2，5小**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="comment">//环状串s的表示法p是否比表示法q的字典序小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">less</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> i, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (s[(i + j) % n] != s[(ans + j) % n])</span><br><span class="line">            <span class="number">1</span> <span class="number">0</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span></span><br><span class="line">			<span class="keyword">return</span> s[(i + j) % n] &lt; s[(ans + j) % n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//相等</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">char</span> s[maxn];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span> (less(s, i, ans)) ans = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="built_in">putchar</span>(s[(i + ans) % n]);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 习题

### 习题3-1　得分（Score, ACM/ICPC Seoul 2005, UVa1585）

题目地址：https://vjudge.net/problem/UVA-1585

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="keyword">char</span> x;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>, temp = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((x = getchar()) != <span class="string">'\n'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x = <span class="string">'O'</span>) &#123;</span><br><span class="line">				res += temp;</span><br><span class="line">				temp++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				temp = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 习题3-2　分子量（Molar Mass, ACM/ICPC Seoul 2007, UVa1586）

**又臭又长的烂代码，但是至少可以安慰自己这个代码好理解把，哈哈哈**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> ex[] = &#123;<span class="number">67</span>, <span class="number">12.01</span>, <span class="number">72</span>, <span class="number">1.008</span>, <span class="number">79</span>, <span class="number">16.00</span>, <span class="number">78</span>, <span class="number">14.01</span>&#125; ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">isalpha</span>(s[i + <span class="number">1</span>]) &amp;&amp; i + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">					<span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">while</span> (!<span class="built_in">isalpha</span>(s[i + n]) &amp;&amp; i + n &lt; len) &#123;</span><br><span class="line">						n++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">int</span> temp1 = <span class="number">1</span>, temp2 = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = i + n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">						temp2 += (s[j] - <span class="number">48</span>) * temp1;</span><br><span class="line">						temp1 *= <span class="number">10</span>;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (s[i] == ex[j]) &#123;</span><br><span class="line">							res += ex[j + <span class="number">1</span>] * temp2;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (s[i] == ex[j]) &#123;</span><br><span class="line">							res += ex[j + <span class="number">1</span>];</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**这题考察的应该是ctype.h里的函数的应用，isalpha，isdigit，当时没想到isdigit这个函数，所以写的比较复杂**

**在vj的评论区看到了29行的代码，牛皮**

### 习题3-3　数数字（Digit Counting , ACM/ICPC Danang 2007, UVa1225）

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> x[<span class="number">10010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10005</span>; i++) &#123;</span><br><span class="line">			x[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> d;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;d);</span><br><span class="line">		<span class="keyword">int</span> q = <span class="number">0</span>, w = <span class="number">0</span>, e = <span class="number">0</span>, r = <span class="number">0</span>, t = <span class="number">0</span>, y = <span class="number">0</span>, u = <span class="number">0</span>, j = <span class="number">0</span>, o = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = i;</span><br><span class="line">			<span class="keyword">while</span> (temp) &#123;</span><br><span class="line">				<span class="keyword">switch</span> (temp % <span class="number">10</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>: q++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>: w++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>: e++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>: r++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>: t++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>: y++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">6</span>: u++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">7</span>: j++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">8</span>: o++; <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">9</span>: p++; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				temp /= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d %d %d %d %d\n"</span>, q, w, e, r, t, y, u, j, o, p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 习题3-4　周期串（Periodic Strings, UVa455）

搞我心态。。

![GCYz7V.png](https://s1.ax1x.com/2020/03/27/GCYz7V.png)

..到网上随便找了个oj，贡献了一发WA，改了改代码，再到vj上就就提交上去了，哈哈哈vj这是为了我好！！！

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (count &lt;= len) &#123;</span><br><span class="line">			<span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len ; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[j] != s[j % count] || len % count != <span class="number">0</span>) &#123;</span><br><span class="line">					ok = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**这个代码在vj上没过，在台湾那个oj上过了，不得不说vj真是严格**

**调整了一下格式总算AC了**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (count &lt;= len) &#123;</span><br><span class="line">			<span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len ; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[j] != s[j % count] || len % count != <span class="number">0</span>) &#123;</span><br><span class="line">					ok = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">				<span class="keyword">if</span> (T) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%d\n\n"</span>, count);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### 习题3-5　谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）

**这个代码没AC，格式有问题**

**写了一中午，在vj上获得两发persentation error之后脑子炸裂决定放弃**



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">char</span> f[<span class="number">5</span>][<span class="number">5</span>],temp;</span><br><span class="line">		<span class="keyword">int</span> x,y; </span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>((temp = getchar()) != <span class="string">'\n'</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span> (temp == <span class="string">'Z'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					f[i][j] = temp;	</span><br><span class="line">					<span class="keyword">if</span> (f[i][j] == <span class="string">' '</span>) &#123;</span><br><span class="line">						x = i;</span><br><span class="line">						y = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> j--; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> op = <span class="string">'0'</span>;</span><br><span class="line">		<span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> ((op = getchar()) != <span class="string">'0'</span>) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">				<span class="keyword">if</span> (x<span class="number">-1</span> &gt;= <span class="number">0</span> ) &#123;f[x][y] = f[x<span class="number">-1</span>][y]; f[x<span class="number">-1</span>][y] = <span class="string">' '</span>; x = x - <span class="number">1</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">				<span class="keyword">if</span> (x+<span class="number">1</span> &lt; <span class="number">5</span> ) &#123;f[x][y] = f[x+<span class="number">1</span>][y]; f[x+<span class="number">1</span>][y] = <span class="string">' '</span>; x = x + <span class="number">1</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">				<span class="keyword">if</span> (y<span class="number">-1</span> &gt;= <span class="number">0</span>) &#123;f[x][y] = f[x][y<span class="number">-1</span>]; f[x][y<span class="number">-1</span>] = <span class="string">' '</span>; y = y - <span class="number">1</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">				<span class="keyword">if</span> (y + <span class="number">1</span> &lt; <span class="number">5</span>) &#123;f[x][y] = f[x][y+<span class="number">1</span>]; f[x][y+<span class="number">1</span>] = <span class="string">' '</span>; y = y + <span class="number">1</span>;&#125;</span><br><span class="line">				<span class="keyword">else</span> ok = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> isfil = <span class="number">1</span>, isfic = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (ok) &#123;</span><br><span class="line">			<span class="keyword">if</span>(tag)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Puzzle #%d:\n"</span>, count);</span><br><span class="line">				tag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"\nPuzzle #%d:\n"</span>, count);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!isfil) isfic = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> isfil = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isfic) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">"%c"</span>, f[i][j]);</span><br><span class="line">						isfic = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>, f[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(tag)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"Puzzle #%d:\n"</span>, count);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"This puzzle has no final configuration.\n\n"</span>);</span><br><span class="line">				tag = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\nPuzzle #%d:\n"</span>, count);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"This puzzle has no final configuration.\n\n"</span>);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 函数和递归

### 例题4-3　救济金发放（The Dole Queue, UVa 133）

> n(n<20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。
> 输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 25</span></span><br><span class="line"><span class="keyword">int</span> n, k, m, a[maxn];</span><br><span class="line"><span class="comment">//逆时针走t步，步长是d（-1表示顺时针走），返回新位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> d, <span class="keyword">int</span> t)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;<span class="comment">//走t布</span></span><br><span class="line">		<span class="keyword">do</span> &#123; </span><br><span class="line">            p = (p+d+n<span class="number">-1</span>) % n + <span class="number">1</span>; <span class="comment">//循环数组</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(a[p] == <span class="number">0</span>); <span class="comment">//走到下一个非0数字，是零的说明那个人都已经走了</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;m) == <span class="number">3</span> &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = i;<span class="comment">//循环，初始化数组</span></span><br><span class="line">        <span class="keyword">int</span> left = n; <span class="comment">//还剩下的人数</span></span><br><span class="line">        <span class="keyword">int</span> p1 = n, p2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            p1 = go(p1, <span class="number">1</span>, k);<span class="comment">//从p1开始，逆时针遍历数组</span></span><br><span class="line">            p2 = go(p2, <span class="number">-1</span>, m);<span class="comment">//顺时针</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3d"</span>, p1); <span class="comment">//输出函数的返回值</span></span><br><span class="line">            left--;<span class="comment">//剩余人数-1</span></span><br><span class="line">            <span class="keyword">if</span> (p2 != p1) &#123; <span class="comment">//如果不是同一人</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%3d"</span>, p2); <span class="comment">//再打印第二个人</span></span><br><span class="line">                left--; <span class="comment">//人数-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[p1] = a[p2] = <span class="number">0</span>;<span class="comment">//赋为0，表示两人已离开，不参与下次循环，遇到就直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (left) <span class="built_in">printf</span>(<span class="string">","</span>);<span class="comment">//最后一个不打印，</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



### 例题4-4　信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）

## C++和STL

### 引用(与指针类似比指针弱)

直接再参数名之前加上一个&，再函数内修改参数的值，也会修改函数的实参

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;<span class="comment">//直接在参数名之前加一个"&amp;"，即可</span></span><br><span class="line">    <span class="keyword">int</span> t = a; a = b; b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">    swap2(a, b);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 字符串

C++中提供了一个string类型使处理字符数组更加简便，cin/cout可以直接读写string，还可以像整数一样相加

> 输入数据的每行包含若干个（至少一个）以空格隔开的整数，输出
> 每行中所有整数之和。如果只能使用字符与字符数组，一般有两种方案：一是使用getchar( )边读边算，代码较短，但容易写错，并且相对较难理解(5)；二是每次读取一行，然后再扫描该行的字符，同时计算结果。如果使用C＋＋，代码可以很简单。

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, x;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(<span class="built_in">line</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; x) sum += x;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

string类在string头文件中，而stringstream在sstream头文件中

### STL



## 一个总结 

1. 对于需要输入多组数据的题目，当第一组数据处理完之后，一定要及时初始化各种变量，因此，定义变量时，尽量把变量定义在需要用的地方的附近。
2. 对于一些需要特定格式的题目，例如需要使用空格隔开字母，但最后一个字母后不能有空格，如果直到一共可以输出多少个，既可以做一个判断，最后一个字母后不接空格，如果不知道要输出多少个，可以把空格放在每个字母之前，对第一个进行特殊化</div></article><article><header><h2><a href="/2020/03/12/PTA-Pratice/">PTA测试题（C语言程序设计）</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-12</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 循环测验

#### 编程题

##### 7-1 小于m的最大的10个素数

> 给定一个整数m（50<m<20000），找出小于m的最大的10个素数。
>
> ### 输入格式:
>
> 输入在一行中给出一个正整数m（50<m<20000）。
>
> ### 输出格式:
>
> 在一行中按递减顺序输出10个满足条件的素数，每个素数输出占6列。没有其它任何附加格式和字符。
>
> ### 输入样例:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">229  </span><br></pre></td></tr></table></figure>
>
> ### 输出样例:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">227   223   211   199   197   193   191   181   179   173</span><br></pre></td></tr></table></figure>

**思路：**输入m后，写一个循环体，判断每一个小于m的数字，若为素数则输出

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsPrimeNum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//判断这个数是否为素数</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(x % i != <span class="number">0</span>)&#123; <span class="comment">//循环破坏的条件是x与i相等或x被i整除</span></span><br><span class="line">		i++; <span class="comment">//每个循环自加1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x == i) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果x == i说明除了它本身，其他数字都无法整除它，说明是素数</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m,i,count = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(i = m<span class="number">-1</span>;i &gt; <span class="number">1</span>;i--)&#123; <span class="comment">//把小于m的数都拿出来看是不是素数</span></span><br><span class="line">		<span class="keyword">if</span>(IsPrimeNum(i))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%6d"</span>,i); <span class="comment">//是素数则打印出来</span></span><br><span class="line">			count++;  <span class="comment">//计数器</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">10</span>) <span class="keyword">break</span>;	<span class="comment">//打印10个后退出循环	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

##### **7-3** **求N分之一序列前N项和**

> 本题要求编写程序，计算序列 1 + 1/2 + 1/3 + ... 的前N项之和。
>
> ### 输入格式:
>
> 输入在一行中给出一个正整数N。
>
> ### 输出格式:
>
> 在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。
>
> ### 输入样例:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6  </span><br></pre></td></tr></table></figure>
>
> ### 输出样例:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 2.450000</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N,i,x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> res = <span class="number">0</span>; <span class="comment">//注意res一定要初始化</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">for</span>(i = N;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">		res += <span class="number">1.0</span>/x; <span class="comment">//一定要写成1.0，否则会默认取整</span></span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sum = %.6lf"</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

##### **7-5** **吃鱼还是吃肉**

> 国家给出了 8 岁男宝宝的标准身高为 130 厘米、标准体重为 27 公斤；8 岁女宝宝的标准身高为 129 厘米、标准体重为 25 公斤。
>
> 现在你要根据小宝宝的身高体重，给出补充营养的建议。
>
> ### 输入格式：
>
> 输入在第一行给出一个不超过 10 的正整数 *N*，随后 *N* 行，每行给出一位宝宝的身体数据：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">性别 身高 体重</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
>
> 其中`性别`是 1 表示男生，0 表示女生。`身高`和`体重`都是不超过 200 的正整数。
>
> ### 输出格式：
>
> 对于每一位宝宝，在一行中给出你的建议：
>
> - 如果太矮了，输出：`duo chi yu!`（多吃鱼）；
> - 如果太瘦了，输出：`duo chi rou!`（多吃肉）；
> - 如果正标准，输出：`wan mei!`（完美）；
> - 如果太高了，输出：`ni li hai!`（你厉害）；
> - 如果太胖了，输出：`shao chi rou!`（少吃肉）。
>
> 先评价身高，再评价体重。两句话之间要有 1 个空格。
>
> ### 输入样例：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 130 23</span><br><span class="line">1 129 27</span><br><span class="line">1 130 30</span><br><span class="line">0 128 27 </span><br></pre></td></tr></table></figure>
>
> ### 输出样例：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ni li hai! duo chi rou!</span><br><span class="line">duo chi yu! wan mei!</span><br><span class="line">wan mei! shao chi rou!</span><br><span class="line">duo chi yu! shao chi rou!</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N,gen[<span class="number">11</span>],sta[<span class="number">11</span>],wei[<span class="number">11</span>];<span class="comment">//使用数组存放每个bb的身体数据</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">	<span class="keyword">int</span> temp = N;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>,ssta,swei;</span><br><span class="line">	<span class="keyword">while</span>(temp--)&#123; <span class="comment">//有N个宝宝就读取次</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;gen[i],&amp;sta[i],&amp;wei[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; N;i++)&#123; <span class="comment">//判断bb男女，确定标准数据</span></span><br><span class="line">		<span class="keyword">if</span>(gen[i] == <span class="number">1</span>)&#123;</span><br><span class="line">			ssta = <span class="number">130</span>;</span><br><span class="line">			swei = <span class="number">27</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ssta = <span class="number">129</span>;</span><br><span class="line">			swei = <span class="number">25</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span>(sta[i] == ssta)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"wan mei!"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sta[i] &lt; ssta)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"duo chi yu!"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"ni li hai!"</span>);</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span>(wei[i] == swei)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" wan mei!\n"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(wei[i] &lt; swei)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" duo chi rou!\n"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" shao chi rou!\n"</span>);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





### 选择测验

#### 7-3新胖子公式

> 根据钱江晚报官方微博的报导，最新的肥胖计算方法为：体重(kg) / 身高(m) 的平方。如果超过 25，你就是胖子。于是本题就请你编写程序自动判断一个人到底算不算胖子。
>
> ### 输入格式：
>
> 输入在一行中给出两个正数，依次为一个人的体重（以 kg 为单位）和身高（以 m 为单位），其间以空格分隔。其中体重不超过 1000 kg，身高不超过 3.0 m。
>
> ### 输出格式：
>
> 首先输出将该人的体重和身高代入肥胖公式的计算结果，保留小数点后 1 位。如果这个数值大于 25，就在第二行输出 `PANG`，否则输出 `Hai Xing`。
>
> ### 输入样例 1：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.1 1.74</span><br></pre></td></tr></table></figure>
>
> ### 输出样例 1：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.1</span><br><span class="line">PANG  </span><br></pre></td></tr></table></figure>
>
> ### 输入样例 2：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65 1.70  </span><br></pre></td></tr></table></figure>
>
> ### 输出样例 2：
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22.5</span><br><span class="line">Hai Xing</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> res,w,h;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;w,&amp;h);</span><br><span class="line">	res = w / (h * h);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>,res);</span><br><span class="line">	<span class="keyword">if</span>(res &gt; <span class="number">25</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PANG"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Hai Xing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 7-6计算分段函数[1]

> 本题目要求计算下列分段函数*f*(*x*)的值：
>
> ![公式](https://images.ptausercontent.com/1)
>
> ### 输入格式:
>
> 输入在一行中给出实数x。
>
> ### 输出格式:
>
> 在一行中按“f(x) = result”的格式输出，其中x与result都保留一位小数。
>
> ### 输入样例1:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
>
> ### 输出样例1:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(10.0) &#x3D; 0.1</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
>
> ### 输入样例2:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
>
> ### 输出样例2:
>
> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(0.0) &#x3D; 0.0</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> x,res;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;x);</span><br><span class="line">	res = <span class="number">1.0</span>/x;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"f(%.1f) = 0.0"</span>,x);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"f(%.1f) = %.1f"</span>,x,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><article><header><h2><a href="/2020/03/09/tree/">树（Tree）</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-09</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

### 树（Tree）

n个节点构成的有限集合

n = 0时，称为空树

#### 非空树有以下性质：

- 树中有一个称为"根（Root）"的节点，用r表示

- 其余节点互不相交且有限，其中每个集合本身又是一棵树，称为原树的子树(SubTree)

  ![8i5Bf1.png](https://s2.ax1x.com/2020/03/10/8i5Bf1.png)

- 子树是不相交的
- 除根节点外，每个节点有且仅有一个父节点

**这些都不是树**

![8ioDsK.png](https://s2.ax1x.com/2020/03/10/8ioDsK.png)

- 一棵N个节点的树有N-1条边

#### 树的一些基本术语

1. 节点的度(Degree)：节点的子树个数
2. 树的度：树的所有节点中最大的度数（上面那个树的度为3）
3. 叶结点（Leaf）：度为零的节点，即没有子树
4. 父结点（Parent）：有子树的节点是其子树的根节点的父节点
5. 子结点（Child）
6. 兄弟结点（Sibling）：具有同一父节点的各节点彼此
7. 路径和路径长度：
8. 祖先节点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个节点的祖先结点，比如从A到L，ABG都是L的祖先结点
9. 子孙结点（Descendant）
10. 结点的层次（Level）：规定根结点在1层，其他任一结点的层数是其父结点层数+1，
11. 树的深度（Depth）：树中所有结点中的最大层次就是这棵树的深度



#### 树的表示

为了节省空间和方便这里使用**兄弟-儿子表示法**

##### 兄弟-儿子表示法

| Element    |             |
| ---------- | ----------- |
| FirstChild | NextSibling |

链表的每个结点如上图

链接起来后如下图

![8k30kn.png](https://s2.ax1x.com/2020/03/11/8k30kn.png)

这样的树被称为**二叉树**

#### 二叉树（Binary Tree）

##### 二叉树的定义

二叉树是一个有穷的结点集合

这个集合可以为空

若不为空，则它是由根节点和称为其**左子树**和**右子树**的两个**不相交**的二叉树组成

##### 二叉树的五种基本形态

- 空树
- 只有根
- 只有左子树
- 只有右子树
- 左右子树都有

二叉树和其他度为2的树的不同在于二叉树的子树有左右顺序之分

##### 特殊的二叉树

- 斜二叉树（Skewed Binary Tree）

只有左子树或只有右子树

- 完美二叉树（Perfect Binary Tree）/满二叉树（Full Binary Tree）

![8kadJJ.png](https://s2.ax1x.com/2020/03/11/8kadJJ.png)



- 完全二叉树（Complete Binary Tree）

有n个结点的二叉树，对树中的结点按上图所示方式编号，编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同

将完美二叉树的叶结点，从有往左依次删除任意个数，所形成的二叉树就是完全二叉树

下图就不是一个完全二叉树

![8kasL6.png](https://s2.ax1x.com/2020/03/11/8kasL6.png)

##### 二叉树的几个性质

- 一个二叉树第i层的最大结点数为：2^(i-1) , i >= 1

- 深度为k的二叉树有最大结点总数为：2^k - 1 ,k >= 1

  完美二叉树可以达到2^k - 1个结点

- 对于任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶结点个数，那么n0 = n2 + 1

##### 二叉树的抽象数据类型定义

###### 类型名称：二叉树

###### 数据对象集：

​		一个有穷结点集合。

​		若不为空，则有根节点和其左、右二叉树组成

###### 操作集：

1. Boolean IsEmpty(BinTree BT):判断二叉树是否为空
2. void Traversal(BinTree BT):遍历，按某种顺序访问每个结点
   - void PreOrderTraversal(BinTree BT):先序-根、左子树、右子树
   - void InOrderTraversal(BinTree BT):中序---左子树、根、右子树
   - void PostOrderTraversal(BinTree BT):后序---左子树、右子树、根
   - void LevelOrderTraversal(BinTree BT):层次遍历，从上到下、从左到右
3. BinTree CreatBinTree():创建二叉树

##### 二叉树的存储结构

###### 1. 顺序存储结构

**完全二叉树**可以方便的使用数组实现

共n个结点

| 结点 | A    | B    | C    | D    | E    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 序号 | 1    | 2    | 3    | 4    | 5    |

- 非根结点（i > 1）的父结点的序号是i/2
- 结点（i）的左孩子结点序号是2i（2i <= n，否则没有左孩子）
- 结点（i）的右孩子结点的序号是2i+1（2i+1 <= n,否则没有右孩子）

**一般二叉树**也可以使用数组实现，但是会造成空间浪费

###### 2. 链表存储

结点的结构：|Left|Data|Right|

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

##### 二叉树的遍历

1. 遍历（递归）

简单但是浪费空间

1. 先序遍历

   遍历过程

   1. 访问根节点
   2. 先序遍历其左子树
   3. 先序遍历其右子树
   
   看了这个图可能能更好地理解递归的过程

![8Z98Ug.png](https://s1.ax1x.com/2020/03/12/8Z98Ug.png)

这个图更好，注意看箭头

![8Z9cG9.png](https://s1.ax1x.com/2020/03/12/8Z9cG9.png)

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);<span class="comment">//打印这个结点的数据</span></span><br><span class="line">        PerOrderTraversal(BT-&gt;Left);<span class="comment">//递归地遍历左子树</span></span><br><span class="line">        PerOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 中序遍历

   1. 中序遍历其左子树
   2. 访问其根节点
   3. 中序遍历其右节点

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        </span><br><span class="line">        InOrderTraversal(BT-&gt;Left);<span class="comment">//递归地遍历左子树</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);<span class="comment">//打印这个结点的数据</span></span><br><span class="line">        InOrderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

3. 后序遍历

   1. 后序遍历其左节点
   2. 后序遍历其右节点
   3. 访问根节点

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        </span><br><span class="line">        PostOrderTraversal(BT-&gt;Left);<span class="comment">//递归地遍历左子树</span></span><br><span class="line">        PostOrderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,BT-&gt;Data);<span class="comment">//打印这个结点的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**以上三种遍历过程，经过结点的路线一样，只是访问各结点的时机不同**

2. 遍历（非递归）

   1. 中序遍历（第二次碰到结点就printf）
   
   - 遇到一个结点，就把它压栈，并去遍历它的左子树
- 当左子树遍历结束后，就从栈顶弹出这个结点并访问它
   - 然后按其右指针再去中序遍历该节点的右子树

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreatStack(MaxSize); <span class="comment">//创建并初始化堆栈</span></span><br><span class="line">    <span class="keyword">while</span>(T || !IsEmpty(S))&#123;<span class="comment">//循环结束只要满足结点为空且堆栈为空</span></span><br><span class="line">        <span class="keyword">while</span>(T)&#123; <span class="comment">//一直循环直至结点为空</span></span><br><span class="line">            Push(S,T);<span class="comment">//把结点压入堆栈</span></span><br><span class="line">        	T = T-&gt;Left; <span class="comment">//指针转到下一个左边的结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123; <span class="comment">//如果堆栈不空的话就开始Pop</span></span><br><span class="line">            T = Pop(S); <span class="comment">//把栈顶元素给T，并Pop</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%5d"</span>,T-&gt;Data); <span class="comment">//打印结点数据</span></span><br><span class="line">            T = T-&gt;Right; <span class="comment">//准到根节点的右子树</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   2. 先序遍历（第一次碰到结点就printf）

   **由于走过的路径相同，只需要改变访问结点的时机就可以在中序遍历的基础上实现先序遍历**

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    BinTree T = BT;</span><br><span class="line">    Stack S = CreatStack(MAxSize);</span><br><span class="line">    <span class="keyword">while</span>(T || !Empty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(T)&#123;</span><br><span class="line">            Push(S,T);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%5d"</span>,T-&gt;Data);<span class="comment">//与中序遍历的区别就在printf的位置</span></span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T = Pop(S);</span><br><span class="line">            T = T-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   3. 后序遍历（第三次碰到结点再printf）	

   4. 层序遍历

      **二叉树遍历的核心问题：二维结构的线性化**

      问题在于当你访问完一个结点的左儿子或右儿子之后，剩下的一个儿子怎么办？如果没有存储右儿子或者自己，那么这些结点就丢失了，所以需要一种方法保存该节点或保存他的父结点

      

      **总的来说就是我们需要一个存储结构保存暂时不访问的结点**

      这里使用队列解决问题

      - 先把根入队
      - 根出队，并且让它的两个儿子入队，左儿子现右儿子后
      - 依次让队列里的结点出队，并且让他的儿子入队
      - 重复，直至队列空

      

      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    BinTree T;</span><br><span class="line">    Q = CreatQueue(MaxSize); <span class="comment">//创建并初始化队列</span></span><br><span class="line">    Add(Q,BT); <span class="comment">//让根入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123; <span class="comment">//队列不空就一直循环</span></span><br><span class="line">        T = Delete(Q); <span class="comment">//队首的出队，并记录队首的地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,T-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Left) Add(Q,T-&gt;Left); <span class="comment">//左儿子入队</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;Right) Add(Q,T-&gt;Right); <span class="comment">//右儿子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

###### 二叉树遍历的应用

##### 二叉树的同构

一个二叉树可以通过n次左右树交换就能变得和另一个一样，就称俩数同构 

#### 二叉搜索树（Binary Search Tree）

满足：

1. 非空左子树的所有键值小于其根节点的键值
2. 右子树大于根节点
3. 左右子树都是搜索二叉树

![GR6Tpt.png](https://s1.ax1x.com/2020/04/08/GR6Tpt.png)

##### 操作集

Position Find(ElementType X,BinTree BST):查找X，返回结点的地址

Position FindMin(BinTree BST)：返回最小元素结点并返回

Position FindMax(BinTree BST)：最大

BinTree Insert(ElementType X,BinTree BST)：插入X

BinTree Delete(ElementType X,BinTree BST)：删除X



Find()思路：

1. 从根节点开始，如果树为空返回NULL
2. 非空就和X进行比较
   1. 若小于根就在左子树继续查找
   2. 大于则就在右子树里查找
   3. 相等就返回指针



递归实现

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span> <span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//若数为空就返回NULL</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X,BST-&gt;Right); <span class="comment">//递归地调用Find，进入右子树继续查找</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        <span class="keyword">return</span> Find(X,BST-&gt;Left);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BST;<span class="comment">//相等时返回该节点的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

循环实现

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(BST)&#123;</span><br><span class="line">        <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



FindMin()&FindMax()

递归实现

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//空就返回NULL</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Left)<span class="comment">//如果左子树为空，说明到最小回</span></span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> FindMin(BST-&gt;Left);<span class="comment">//不为空，就进入左子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

循环实现

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(BST)<span class="comment">//找到空为止</span></span><br><span class="line">        <span class="keyword">while</span>(BST-&gt;Right) BST = BST-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Insert()

**关键是找到插入的位置**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!BST)&#123;<span class="comment">//若原树为空，则生成并返回一个结点</span></span><br><span class="line">        BST = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">        BST-&gt;Data = x;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Left = Insert(X,BST-&gt;Left);<span class="comment">//递归，找出正确位置，赋值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">            BST-&gt;Right = Insert(X,BST-&gt;Right);</span><br><span class="line">        <span class="comment">//else 若X已经存在，那什么都不用做</span></span><br><span class="line">        <span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

Delete()

有三种情况

1. 叶结点，直接让他的父结点指向NULL
2. 只有一个孩子，直接用它的儿子替代它‘
3. 有两个孩子，

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(ElementType X,BinTree BST)</span></span>&#123;</span><br><span class="line">    Position Tmp;</span><br><span class="line">    <span class="keyword">if</span>(!BST) <span class="built_in">printf</span>(<span class="string">"要删除的元素未找到"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &lt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Left = Delete(X,BST-&gt;Left);<span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(X &gt; BST-&gt;Data)</span><br><span class="line">        BST-&gt;Right = Delete(X,BST-&gt;Right);<span class="comment">//这两个else if都是查找的过程</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//找到后</span></span><br><span class="line">        <span class="keyword">if</span>(BST-&gt;Left &amp;&amp; BST-&gt;Right)&#123;<span class="comment">//判断结点的类型</span></span><br><span class="line">            Tmp = FindMin(BST-&gt;Right);<span class="comment">//找到右子树中最小的结点</span></span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;<span class="comment">//用找到的那个结点替换要删除的结点</span></span><br><span class="line">            BST-&gt;Right=Delete(BST-&gt;Data,BST-&gt;Right);<span class="comment">//删除那个用于替换原结点的结点,不理解为什么，有赋值这个操作 </span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">            Tmp = BST;</span><br><span class="line">            <span class="keyword">if</span>(!BST-&gt;Left)</span><br><span class="line">                BST = BST-&gt;Right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!BST-&gt;Right)</span><br><span class="line">                BST = BST-&gt;Left;</span><br><span class="line">            <span class="built_in">free</span>(Tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 平衡二叉树

查找效率高

**平衡因子（Blance Factor，BF）**：BF(T) = hL-hR

hL,hR分别为T的左右子树的高度



**平衡二叉树(Blance Binary Tree)(AVL树)**

1. 空树
2. 任意结点左右子树高度差的绝对值不超过1

##### 平衡二叉树的调整

给树插入结点时，有可能会破坏树的平衡，因此需要调整

平衡二叉树还是一个搜索二叉树，因此在调整过程中，依然要保持搜索二叉树的特性

#### 堆

优先队列(Priority Queue):特殊的队列，取出元素的顺序按照元素的优先权（关键字）大小

**两个特性：**

1. 结构性：用数组表示的完全二叉树
2. 有序性：任意结点的关键字是其子树所有结点的最大值或最小值
   - 最大堆（MaxHeap）也称大顶堆
   - 最小堆（MinHeap）也称小顶堆



##### 操作集

MaxHeap Create(int MaxSize)

Boolean IsFull(MaxHeap H)

Inser(MaxHeap H,ElementType item)

Boolean IsEmpty(MaxHeap H)

ElementType DeleteMax(MaxHeap H)

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> *<span class="title">MaxHeap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span>&#123;</span></span><br><span class="line">    ElementType *ElementType;<span class="comment">//储存堆元素的数组</span></span><br><span class="line">    <span class="keyword">int</span> Size;<span class="comment">//堆当前元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> Capacity;<span class="comment">//堆的最大容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MaxHeap <span class="title">Create</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct HeapStruct));<span class="comment">//申请一块空间给H</span></span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElementType));<span class="comment">//申请一块数组空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;<span class="comment">//初始为零，当前元素个数</span></span><br><span class="line">    H-&gt;Capacity = MaxSize;<span class="comment">//初始为MaxSize，堆的最大容量</span></span><br><span class="line">    H-&gt;Element[<span class="number">0</span>] = MaxDate;<span class="comment">//哨兵，方便以后访问</span></span><br><span class="line">    <span class="keyword">return</span> H; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;<span class="comment">//i指向插入后堆中的最后一个元素,插入后Size++</span></span><br><span class="line">    <span class="keyword">for</span>(;H&gt;Elements[i/<span class="number">2</span>] &lt; item;i/=<span class="number">2</span>)<span class="comment">//插入时结点放在最后，然后依次与他的父结点进行比较，直到父结点大于他为止</span></span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>];<span class="comment">//大于就和父结点互换位置</span></span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">    <span class="comment">//完全二叉树中，一个结点的序号/2就是它父结点的序号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



[![G4l1bV.png](https://s1.ax1x.com/2020/04/09/G4l1bV.png)](https://imgchr.com/i/G4l1bV)



哨兵的一个作用就是，哨兵的值是堆中最大的，无论多大的结点来比较，到哨兵这里就会停止，可以减少一个判断条件i>1，提高效率

**基本思路：删除根之后，把树的最后一个节点（保证完全二叉树的特性）挪到根的位置，然后进行调整排序**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteMax</span><span class="params">(MaxHeap H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Parent,Child;</span><br><span class="line">    ElementType MaxItem,temp;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>];<span class="comment">//把要删除的结点存起来，一会儿返回出去</span></span><br><span class="line">    temp = H-&gt;Element[H-&gt;Size--];<span class="comment">//把最后一个结点存起来，然后Size--</span></span><br><span class="line">    <span class="keyword">for</span>(Parent = <span class="number">1</span>;Parent*<span class="number">2</span>&lt;=H-&gt;Size;Parent=Child)&#123;<span class="comment">//从根节点开始循环，每次循环完后进入下一层的左节点，如果Parent*2&lt;=H-&gt;Size说明，下一层没有节点了</span></span><br><span class="line">        Child = Parent*<span class="number">2</span>;<span class="comment">//进入下一层的左节点</span></span><br><span class="line">        <span class="keyword">if</span>((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Element[Child]&lt;H-&gt;Elements[Chile+<span class="number">1</span>]))<span class="comment">//Child!=H-&gt;Size保证进入这个判断的结点都有两个儿子，(H-&gt;Element[Child]&lt;H-&gt;Elements[Chile+1])默认左节点大于右节点，如果小于就Child++</span></span><br><span class="line">            Child++;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= H-&gt;Element[Child]) <span class="keyword">break</span>;<span class="comment">//如果temp大于这个节点的最大子节点那么说明位置正确</span></span><br><span class="line">        <span class="keyword">else</span> H-&gt;ElementS[Parent] = H-&gt;Elements[Child];<span class="comment">//交换两节点位置</span></span><br><span class="line">    &#125; </span><br><span class="line">    H-&gt;Element[Parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**建立最大堆**

方法：

1. 通过Insert操作，将元素一个一个插进去（O(NlogN)）

2. 在线性时间复杂度下建立最大堆

   1. 将N个元素按顺序存入，先满足完全二叉树的特性
   2. 调整各节点位置，以满足有序特性

   **如何调整**

#### 哈夫曼树（最优二叉树）（Huffman Tree）

**带权路径长度（WPL）：**设二叉树有n个叶结点，每个叶结点带有权值Wk，从根节点到每个叶结点的长度为Lk，WPL=每条路径长度乘权值的和

哈夫曼树：WPL最小

##### 哈夫曼树的构造

思路:把所有元素按权值排列，然后拿出两个权值最小的合并成一个二叉树，然后再找两个最小的合并，直到合并完

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">HuffmanTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">    HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HuffmanTree <span class="title">Huffman</span><span class="params">(MinHeap H)</span></span>&#123;<span class="comment">//假设H-&gt;Size的权值已经存在H-&gt;Element[]-&gt;Weight里</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BulidMinHeap(H); <span class="comment">//将H-》ElementS[]按权值调整为最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;H-&gt;Size;i++)&#123;</span><br><span class="line">        T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));<span class="comment">//建一个新结点，存放新组成的树</span></span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H);<span class="comment">//从堆里拿出俩元素，进行组合</span></span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">        Insert(H,T);<span class="comment">//把组合后的树插入最小堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    T = DeleteMin(H);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**特点**：

- 没有度为1的结点
- n个叶结点的哈夫曼树共有2n-1个结点
- 任意非叶结点的左右子树交换后仍是哈夫曼树
- 同一组权值存在不同构的两颗哈夫曼树

##### 哈夫曼编码

为了将字符的存储空间降到最小还要避免二义性，就可以使用哈夫曼编码（编码不等长）

方法：

1. 将每个字符出现的次数作为权值
2. 创建一个哈夫曼树，保证每个字符都在叶结点上就不会出现二义性

#### 集合

并查集：集合并，查某元素属于那个集合

存储实现：用树结构（并非二叉树），树的每个结点代表一个元素

1. 用是链表实现

2. 数组：

   - 数组的每个分量都是一共结构，包含结点的值和父结点的下标，没有父结点则记为-1

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Parent;</span><br><span class="line">&#125;SetType;</span><br></pre></td></tr></table></figure>

   - 查

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(SetType s[],ElementType X)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MaxSize &amp;&amp; S[i].Data != X;i++);<span class="comment">//循环查找X，找到后退出时i的值就是该节点的下标或没找到</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= MaxSize) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//判断属于以上那种情况</span></span><br><span class="line">    <span class="keyword">for</span>(;s[i].Parent &gt;= <span class="number">0</span>;i = s[i].Parent);<span class="comment">//查找这个结点的根结点，退出时就是i是根节点的下标</span></span><br><span class="line">    <span class="keyword">return</span> i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   - 并
     - 分别找到两个集合的根节点
     - 若不同根就设置一个集合的根节点的父结点为另一个集合的根节点

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(SetType s[],ElementType X1,ElementType X2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Root1,Root2;</span><br><span class="line">    Root1 = Find(S,X1);</span><br><span class="line">    Root2 = FInd(S,X2);</span><br><span class="line">    <span class="keyword">if</span>(Root1 != Root2) s[Root2].Parent = Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   ​	如果总是这样插的话可能会导致树越来越高，所以考虑将结点少的插到结点多的树底下

   这使就需要考虑如何存储一个树的结点个数，如果在结构中再创建一个变量的话，由于只有根节点需要存储数据，会造成空间浪费，所以考虑继续使用本来的数组存储，可以使用原来标记结点为根节点的空间来存储，有x个结点就在数组中存为-x，到时候只需要判断正负就可以。

</div></article><div class="archive-pagination"><div class="paginator"><a class="extend prev" rel="prev" href="/archives/2020/">&amp;laquo;</a><a class="page-number" href="/archives/2020/">1</a><span class="page-number current">2</span><a class="page-number" href="/archives/2020/page/3/">3</a><a class="extend next" rel="next" href="/archives/2020/page/3/">&amp;raquo;</a></div></div></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>Simple Block 是一个基于线框设计的简单的 Hexo 主题，拆分自 <a href="https://jysperm.me" target="_blank" rel="noopener">精子的博客</a>。
支持使用 Jade 或 Markdown 来向边栏添加小部件，或向正文前添加横幅。</p>
<p>技术栈：</p>
<ul>
<li>Jade - 页面模板</li>
<li>Less/Sass - 页面样式</li>
<li>Bower - 前端包管理器</li>
<li>CoffeeScript - Hexo 拓展脚本</li>
<li>Gulp - 编译工具</li>
</ul>
</div><div class="widget tags"></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a>&nbsp; 授权发布。最后生成于 2020-08-05.</p></div></div></div></div></body></html>