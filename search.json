[{"title":"我是如何实现易班自动打卡的？","date":"2020-07-28T06:01:36.000Z","url":"/2020/07/28/yiban-autocheck/","content":"需要用到的工具 HttpCanary 抓包 先进入易班，然后退出登录，方便我们一会记录整个登录和打卡的过程 打开HttpCanary将易班添加为目标程 开始抓包 完成从登录易班到打卡完成的整个过程的抓包 分析我们倒着来分析 抓到了很多数据包，但是音频和图片js…文件是我们不需要的，因此进行过滤保留这三种数据包即可 开始一个一个分析，发现一个数据包很可疑，打开一看这不就是我们提交的表单吗 验证猜想，重发这个请求，返回消息如下，可以确定这就是我们要找的数据包 猜想是否可以依靠每天自动重发这个请求实现签到，答案是否定的，是什么原因呢 分析该请求的请求头，发现这里有一个Cookie，有两个字段 第一个不用说，第二个就是罪魁祸首，一看这名字就知道肯定和SESSION有关，百度一下 好了这下目标明确，寻找是谁第一次Set了这个Cookie，筛选，好了就是他，理论上我们只要，发送一下这个请求就可以拿到Cookie 问题又来了，这些又是啥？？？继续往下看 首先猜测一下这个act=iappxxxxx应该是易班小程序的ID，那么OK，他是不会变的，记住就行了，那么这个v是什么？看了看他的前一个请求发现就是access_token 好了继续寻找access_token 拉到最下面，第一个请求应该就是登录的请求，查看他的响应信息果然access_token就在里面 至此，抓包数据分析完成 总结： 登录拿到access_token 拿着access_token去获得Cookie 拿着Cookie提交表单 完成 代码以下使用java，使用Hutool进行Http请求、json解析等等等 获取Access_token 获取Cookie 提交表单 发送邮件(不得不说Hutool就是好用) "},{"title":"算法学习笔记","date":"2020-07-21T08:00:47.000Z","url":"/2020/07/21/algorithm/","content":"[TOC] 枚举 一一列举 不重复，不遗漏 优化枚举的基本思路 减少枚举次数 选择合适的枚举对象 选择合适的枚举方向 ——方便排除非法和不是最优的情况 选择合适的数据维护方法 ——转化问题 例1.最大正方形 题目 在一个N*N（N&lt;100）的矩阵中求一个最大的正方形使得该正方形的四个顶点是由“#”构成 ##**# ***** **##* #*#*#* *#*#* 思路 几个点可以确定一个正方形？ 对角线上的两个点确定一个正方形 明确思路使用枚举法，枚举所有两个点的组合，判断剩下两个点是否是#，是的话记录面积不是就继续枚举下一个组合，直至枚举完所有集合 前缀和 对于一个数列，再开一个数组，第n个数就存前n个数字的和 例2 数列求和问题 给定一个数列{an}（1&lt;= n &lt;= 100000）,有q（1&lt;= n &lt;= 100000）次询问，每次询问从i到j的元素之和 思路 暴力，直接算（范围大的话必超时） 先便利数据，求前缀和，存到数组中 使用时直接求aj-ai即可 差分 例3 数列修改问题 给定一个数列{an}（1&lt;= n &lt;= 100000）,有q（1&lt;= n &lt;= 100000）次修改，每次修改把从i到j的每个元素加上k，求所有修改之后的每个数值 思路 暴力，每次修改都遍历区间（时间复杂度太大） 思考问题，进行修改时区间什么没有变，什么变了 区间内各个元素之间的差值未变 端点处的差值改变 把修改的地方从整个区间变到区间的端点，就可以大大减少时间复杂度 当我们对第i到j个数加上k的话，i与i-1的差值增加了k，j与j加一的差值减少了k，区间内部相邻两数差值不变 因此可以使用一个数组来维护第i个数和第i-1个数的差值（默认第一个数的前一个数是0），将[i,j]这个区间的每个数+1时，只需要修改i和j+1（i+k，j+1-k） 对这个数组求前缀和，即可得到数列的值 这种方法叫差分 差分与前缀和的关系 差分和前缀和是一对对称的操作 差分数组求前缀和就是原数组，对前缀和求差分也能得到原数组 尺取法 给定长度为n的正整数数列以及整数S，求出总和不小于S的连续子串的长度的最小值，如果接不存在，输出0 暴力，枚举两个点的所有组合，选择和大于等于S的最短子串（时间复杂度爆炸）（O（n3）） 优化，使用前缀和省去计算和的那一步复杂度变为（O（n2）），依然不低 使用尺取法（O（n）） 确定两个端点，从数组0开始 首先向右移动右边的端点，判断和是否大于S，若大于S就移动左边的端点，一直移动直至再移动一次就不大于S时，记录长度 继续移动右端点，重复2，直至数组结束 得出最小距离 贪心 对问题求解时，总是做出在当前看来最好的选择，不从整体上考虑，做出的选择是局部是上最优解 使用贪心算法解决的问题都是能够证贪心出的局部最优解是所求的全局最优解 STL 算法类 **sort(beg,end,comp)**给数组排序，返回排号的数组,cmp可以不写，comp用来定义比较方法 search binary_search(起始地址，结束地址，要查找的值)，返回布尔值，匹配返回true **lower_bound(beg,end,val)**返回可插入的最小位置的迭代器（可以理解为指针） 例插入3 1 2 2 2 (可以被插到这) 3 3 3 4 5 返回加粗3处的指针 第一个大于等于你查询的数的位置 **upper_bound(beg,end,val)**返回可插入的最大位置的迭代器（可以理解为指针） 1 2 2 2 3 3 3 (可以被插到这) 4 5 返回加粗4处的指针 第一个大于你查询的数的位置 使用前数组一定要排序 **find(beg,end,val)**返回val第一次出现的地址 count(beg,end,val)返回val的出现次数 返回一个ptrdiff_t(typedef long long ptrdiff_t)我也不知道这是个啥 **swap(a,b)**交换两个数 二分、三分 二分查找"},{"title":"MyBatis学习笔记","date":"2020-06-22T02:21:37.000Z","url":"/2020/06/22/MyBatis/","content":"[TOC] 环境搭建 创建实体类和实体类的接口 User IUserDao 配置主配置文件 SqlMapConfig.xml 创建映射配置文件 IUserDao.xml 注意： MyBatis的映射配置文件位置必须和Dao接口的包结构相同 映射配置文件的mapper标签的namespace属性取值必须是Dao接口的全限定类名 映射配置文件的操作配置，id属性的取值必须是dao接口的方法名 ​ 遵从这三点，在开发中就无需实现IUserDao的类，MyBatis代替我们完成 使用 读取配置文件 创建SqlSessionFactory工厂 创建SqlSession对象 创建Dao接口的代理对象 释放资源 注解使用 省略映射配置文件 在要实现的接口上写 主配置文件&lt;mapper&gt;标签下使用class属性指定被注解的Dao全限定类名 CURD 增 配置文件写法 注解写法 需要向接口中传入一个User对象 最后需要commit 获取插入数据的ID keyProperty表示返回值的名称 order表示执行该命令的时间，AFTER表示插入之后再执行 改、删 与增加操作类似只需要改变标签名称或注解的@Xxx 查 获取用户总记录的条数 OGNL表达式 Object Graphic Navigation Language 连接池与事务控制 MyBatis中的连接池 mybatis中提供了3种方式配置 在SqlMapConfig.xml中的dataSource标签中，type属性就是配置采用何种连接池的方式 POOLED 采用传统javax.sql.DataSource规范中的连接池 UNPOOLED 虽然实现了javax.sql.DataSource，但没有使用池的思想 JNDI 事务 可以在创造SqlSession对象时，给OpenSession中传一个true，就可以实现自动提交 动态SQL语句 &lt;if&gt;标签 &lt;where&gt; 多表查询 I don’t have a favorite singer, but a film soundtrack composer whose name is hans zimmer is my favorite composer. I know him from a film called Interstellar. At the same time, Interstellar is also my favorite film. It is because of this excellent OST that there are such excellent film。 Let’s enjoy it together"},{"title":"数据库连接池","date":"2020-06-01T11:46:07.000Z","url":"/2020/06/01/DataSource/","content":"什么是数据库连接池 数据库连接池就是一个存放数据库连接的容器 当系统初始化完成后，容器就被创建，容器中会申请一些连接对象，当用户来访问数据时，从容器中获取连接对象，用户访问完后，将连接对象归还给容器 实现 接口：DataSource 方法 获取连接：getConnection() 归还连接：Connection.close() 如果连接是从数据库连接池中获得的就归还给连接池，而不是关闭连接 由数据库厂商实现\\ 数据库连接池技术 C3P0 Druid C3P0 使用 导入jar包 定义配置文件： c3p0.properties/c3p0-config.xml 放在src文件夹下 创建核心对象 数据库连接池对象 ComboPooledDataSource( ) Druid 使用 导入jar包 配置文件 xxx.properties 可以叫任意名称，放在任意目录下 加载配置文件 Properties 数据库连接池对象 DruidDataSourceFactory 参数：字节流对象 方法：createDataSource获取一个DataSource对象 "},{"title":"cookie&session","date":"2020-05-31T16:48:08.000Z","url":"/2020/06/01/cookie-session/","content":"会话 什么是会话 一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器发送请求，会话建立，指导一方断开为止 有什么用 在一次会话范围内的多次请求共享数据 怎么实现 客户端会话技术（数据存放在客户端）：Cookie 服务端会话技术（数据存放在服务端）：Session Cookie 如何使用 创建Cookie对象】 new Cookie(String name,String value) 发送Ciookie对象 response.addCookie(Cookie cookie) 获取Cookie Cookie[] request.getCookies() 原理 基于请求头Cookie和响应头Set-Cookie实现 细节 一次可以发送多个Cookie（创建多个Cookie对象，多次调用AddCookie） Cookie可以保存多长时间 默认情况下，浏览器关闭后Cookie销毁 持久化存储 setMaxAge(int seconds) 正数，将Cookie数据写道硬盘中，设置Cookie存货时间，单位s 负数，默认值，结束会话删除 0，删除Cookie信息 Cookie的获取范围 1. 特点和作用 cookie储存在客户端 浏览器对于单个Cookie大小有限制4kb，对一个域名下总cookie数量有限制20个 Session 使用 获取HttpSession对象(域对象) request.getSession() 方法 Object getAttribute(String name) void setAttribute(String name,Object value) void removeAttribute(String name) 原理 Session的实现依赖于Cookie 首次使用时服务器向浏览器发送一个Cookie包含一个JSESSIONID，再次访问时，浏览器向服务器发送JSESSIONID，服务器通过这个ID，确保两次访问使用的是同一个HttpSeesion对象 细节 客户端关闭服务器不关闭，两次访问不是同一个Session 若需要相同可以设置Cookie的存活时间 服务器关闭客户端不关闭，两次访问不是同一个Session session钝化： session活化 Session失效时间 服务器关闭 调用一个自杀方法 默认失效时间30min 特点 存储一次会话的数据，存在服务端 可以存储任意类型数据，任意大小 比Cookie安全 "},{"title":"XML","date":"2020-05-31T13:50:17.000Z","url":"/2020/05/31/XML/","content":"什么是XML XML(Extensible Markup Language)可扩展标记语言 可扩展：标签都是可以自定义的 语法严格 啥用 存储数据 配置文件 在网络中传输 基本语法 第一行必须为版本声明（必须是第一行，第一行是空行都不行） 有且只能有一个根标签(&lt;users&gt;&lt;/users&gt;) 属性值必须用 引号引起来（单双都行） 标签都是成对出现（除首行） 标签名称区分大小写 "},{"title":"Spring","date":"2020-05-30T15:38:55.000Z","url":"/2020/05/30/Spring/","content":"[TOC] IoC(控制反转) 将对象的创建交给框架 目的：降低程序间的耦合 如何使用 Maven项目引入一下依赖 在项目的src文件下创建bean.xml(可以是任何名称文件 配置bean标签 创建对象 BeanFactory与ApplicationContext BeanFactory是顶层接口 ApplicationContext是BeanFactory的子接口 不同：对象的创建时间不同 BeanFactory 什么时候用什么时候创建 ApplicationContext默认情况下读取完配置文件之后就创建 （一般用它） ApplicationContext的实现类 ClassPathXmlApplicationContext： 它是从类的根路径下加载配置文件 推荐 FileSystemXmlApplicationContext： 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 Bean标签 属性： 作用 用于配置对象让Spring创建 默认调用对象的无参构造器构造 属性 id:给对象指定唯一标识符 class：指定对象的全限定类名 scope：指定对象的作用范围 singleton :默认值，单例的. prototype :多例的. request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中. global session :WEB项目中,应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session. init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 实例化Bean 使用默认无参构造函数 使用静态工厂 实例工厂 依赖注入 理解控制反转和依赖注入： 构造函数注入 使用类中的构造函数，给成员变量赋值 set方法注入 注入集合属性 AOP 注解 创建对象 @Component ​ 用于把当前类对象存入Spring容器种，相当于配置文件里的&lt;bean&gt;&lt;/bean&gt; 这个注解有一个属性value用于指定bean的id，默认值为当前类名，首字母小写 @Controller @Service @Repository 这三个注解的作用和属性与@Component相同，只是提供了更加明确的语义化 注入数据 相当于&lt;property name=&quot;&quot; ref=&quot;&quot;&gt; @AutoWired 自动按照类型注入 使用注解注入属性时， set 方法可以省略 当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找 @Qualifier 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。 给字段注入时不能独立使用，必须和@Autowire 一起使用;给方法参数注入时，可以独立使用。 属性：value，bean 的id @Resource 直接按照 Bean 的 id 注入 属性：value，bean 的id @Value 注入基本数据类型和 String 类型数据的 value：用于指定值"},{"title":"JDBC学习笔记","date":"2020-05-29T17:04:43.000Z","url":"/2020/05/30/JDBC/","content":"JDBC是啥 JDBC(Java DataBase connectivity)(Java 数据库连接) 由SUN公司定义的一系列操作关系型数据库的接口，后由数据库厂商对接口进行实现，提供数据库驱动jar包 使用 导入jar包 加载驱动 连接数据库 host = jdbc:mysql://host /db 连接时发现报错 The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法 host后加上?serverTimezone=UTC 对象详解 DriverManage驱动管理 注册驱动 MySQL5以后可以自动注册 获取数据库连接 static getConnection(String url,String user,String password) url = jdbc:mysql://ip地址:端口号/数据库名 Connection数据库连接对象 获取执行sql语句的对象 Statement CreateStatement(String sql) Prestatement prepareStatement(String sql) 管理事务 Statement执行sql语句 执行sql int executeUpdate(String sql)：执行DML(insert,update,delete)，DDL(create,alter,drop) 返回值是操作后影响的行数 可以用来判断成功与否 ResultSet executeQuery(String sql):执行DQL(select) ResultSet查询结果的封装 boolean next()游标向下移动一行(默认指向表头)，判断是否有数据 getXxx(“列名/列的编号，从1开始”)获取数据Xxx代表类型 PreparedStatement SQL注入问题:在拼接sql‘语句时，有一些特殊的词参与拼接会造成安全问题 使用PreparedStatem对象解决问题 定义sql语句时使用?作为占位符，替换参数 使用setXxx(？的编号从1开始，参数的值) 执行sql语句时不再需要传参 Spring JDBC Spring框架提供的JDBC简单封装 提供一个JDBCTemplate 使用 导入jar包 创建JdbcTemplate，依赖于DataSource JdbcTemplate template = new JdbcTemplate 调用JdbcTemplate的方法完成CRUD操作 update()增删改 queryForMap()将查询结果封装为map集合 queryForList()将查询结果封装为list集合 query()查询结果，将查询结果封装为JavaBean对象 queryForObject()将查询结果封装为对象 "},{"title":"Servlet学习笔记","date":"2020-05-29T16:04:09.000Z","url":"/2020/05/30/Servlet/","content":"[TOC] 什么是Servlet Servlet(Service applet)运行在服务器的小程序 Servlet就是一个接口，定义了某个Java类能被tomcat识别的规则 如何使用 新建一个类 实现servlet的接口 实现接口中的抽象类 配置servlet Servlet的执行流程 Servlet基础 配置Servlet 当 Servlet启动时自动装载 num越小优先级越高 使用注解 @WebServlet(&quot;url&quot;) 就不用在web.xml里面配置了 声明周期 第一次访问后，servlet创建，第二次访问时不需要创建，直接使用，当服务器关闭时，servlet销毁 Servlet结构 Servlet接口下有两个实现类 HttpServlet和GenericServlet GenericServlet 除了service类外，对Servlet接口的其他类都进行了空实现 以后使用Servlet时，对该类进行继承就行 HttpServlet 对http协议进行了封装，简化操作 Request对象 继承体系 获取数据库 获取请求行 getMethod获取请求方法 getContextPath取虚拟目录 getServletPath获取Servlet路径 getQueryString获取请求参数 获取请求URI getRequestURI getRequestURL getProtocol获取协议版本 getRemoteAddr获取客户机IP地址 获取请求头 getHeader(String name)通过请求头的名称获得请求头 Enumeration&lt;String&gt; getHeaderNames()获取所有请求头的名称 获取请求体 只有POST有请求体 获取流对象 BufferReader getReader()获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()获取字节输入流，可以操作所有数据类型 从流对象中获取数据 其他（重要） 获取请求参数的通用方式（兼容GET&amp;POST） String getParameter(String name)根据参数名获取参数值 String[] getParameterValues(String name)根据参数名获取参数值的数组 – hobby=吃饭&amp;hobby=睡觉 Enumeration&lt;String&gt; getParameterNames()获取所有请求参数的名称 Map&lt;String,String[]&gt; getParameterMap()获取所有参数的map集合 请求转发 步骤 通过request对象获取请求转发器对象：RequestDispatcher get RequestDispatcher(String path) 使用RequestDispatcher对象进行转发：forward(ServletRequest request,ServletResponse response) request.getRequestDispatcher(&quot;/path&quot;).forward(request,response) 特点 浏览器地址栏不变化 只能转发到当前服务器内部资源 访问带转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj)存储数据 Object getAttribute(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext "},{"title":"MySQL学习笔记","date":"2020-05-06T10:42:04.000Z","url":"/2020/05/06/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"登录登出 修改MySQL提示符 登陆时 登陆后 MySQL常用命令 关键字与函数名全部大写 数据库名，表名称，字段名称全部小写 MySQL语句必须以分号结尾 创建数据库 "},{"title":"PHP学习笔记","date":"2020-04-28T16:17:56.000Z","url":"/2020/04/29/PHP/","content":"[TOC] 一些小细节 php代码需要写在&lt;?php ?&gt;之间 echo用来输出 php连接两个字符串使用.而不是+ php每条语句都以;结尾 //表示注释 PHP的新东西 数组 PHP有两种数组：索引数组、关联数组。 索引数组 索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 可以使用print_r($fruit);语句输出数组键及对应的值 赋值 $arr[0]='苹果'; array('0'=&gt;'苹果'); array(&quot;苹果&quot;,&quot;香蕉&quot;); 读取 $arr[&quot;0&quot;];/$arr[0]; 关联数组 关联数组是指数组的键是字符串的数组 可以使用print_r($fruit);语句输出数组键及对应的值。 赋值 $arr['apple']='苹果'; array('apple'=&gt;'苹果'); 读取 $fruit['banana']; 类与对象 类是一类东西的结构描述，而对象则是一类东西的一个具体实例 定义一个类 对象通过new关键字进行实例化： 类的属性 在类中定义的变量称之为属性 属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成 public：公开的 protected：受保护的 private：私有的 默认都为public，外部可以访问。一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。 类的方法 方法就是在类中的function 的方法也具有public，protected 以及 private 的访问控制。 使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号:: 构造函数和析构函数 PHP5可以在类中使用**__construct()**定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数 在子类中如果定义了__construct则不会调用父类的__construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用 PHP5支持析构函数，使用**__destruct()**进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数 静态关键字 静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。 静态方法也可以通过变量来进行动态调用 静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。 访问控制 访问控制通过关键字public，protected和private来实现。 被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的类成员则只能被其定义所在的类访问。 默认为公有 对象继承 使用extends 重载 cookie 设置cookie 文件系统 异常处理 抛出异常 异常处理类 PHP具有很多异常处理类，其中Exception是所有异常处理的基类。 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容 code 异常代码 file 抛出异常的文件名 line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息 getTraceAsString 获取异常追踪信息的字符串 getMessage 获取出错信息 捕获异常信息 将错误信息写入错误日志 PHP数据库 查询 在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。 对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 插入 在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。 取得数据查询结果"},{"title":"jQuery学习笔记","date":"2020-04-27T08:04:06.000Z","url":"/2020/04/27/jQuery/","content":"[TOC] 环境搭建 想要使用jQuery只需要在&lt;head&gt;标签中 注意：一定千万不要在引用jquery的script标签里再写js了，重新写一个script标签 可以在这里下载使用jQuery的其他版本 网速慢的话  这样操作 选择器 id选择器 id若多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素，按理来说id需要唯一 类选择器 假如你想改变某一类标签内容的样式可以直接使用$(.class).css(),不再像原生js一样需要循环 标签选择器 全能选择器 获取文档中的所有元素 层级选择器 文档中的所有的节点之间都是有这样或者那样的关系。我们可以把节点之间的关系可以用传统的家族关系来描述，可以把文档树当作一个家谱，那么节点与节点直接就会存在父子，兄弟，祖孙的关系了。 基本筛选选择器 假如你使用标签选择器选取了所有div标签，但是你只想要第一个就可以这样 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。 :parent与:empty是相反的，两者所涉及的子元素，包括文本节点 可见性筛选选择器 我们有几种方式可以隐藏一个元素： CSS display的值是none。 type=&quot;hidden&quot;的表单元素。 宽度和高度都显式设置为0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的值是0 属性筛选选择器 用法 子元素筛选选择器 :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) :last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素 如果子元素只有一个的话，:first-child与:last-child是同一个 :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配 jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的 nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算 表单元素选择器 表单对象属性筛选选择器 特殊选择器this this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。 $(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值 属性与样式 attr()与.removeAttr() 用来获取和设置元素属性 attr()有4个表达式 attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } removeAttr()删除方法 .removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute） .html()及.text() .html() 获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 .text() 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .html处理的是元素内容，.text处理的是文本内容 .val() .val()方法 主要是用于处理表单元素的值，比如 input, select 和 textarea。 .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function ) ，一个用来返回设置值的函数 .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的&quot;value&quot;值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的&quot;value&quot;值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .addClass()和removeClass() addClass( className )方法 .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名 注意事项： .removeClass( )方法 .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名 注意事项 如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除 .toggleClass() 一次执行相当于addClass，再次执行相当于removeClass **.toggleClass( )方法：**在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类 .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意事项： toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加 .css() 获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 设置： .css(propertyName, value )：设置CSS .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 结点创建与属性 创建 插入 .append(), 内容在方法的后面，参数是将要插入的内容。 .appendTo()刚好相反，内容在方法前面，无论是一个选择器表达式 或创建作为标记上的标记它都将被插入到目标容器的末尾 作用是一样的"},{"title":"CSS学习笔记","date":"2020-04-26T03:57:42.000Z","url":"/2020/04/26/CSS/","content":"[TOC] CSS 穿衣服 CSS语法 选择符又名选择器，指明网页中要应用样式规则的元素 最后一条声明可以没有分号 /*这样写注释*/ CSS的三种用法及优先级 内联式 直接写在标签中 红 多条语句用;分开 红 嵌入式 外部式 创建一个单独的css文件 使用上面这句引用，通常写在head标签中 优先级 内联式 &gt; 嵌入式 &gt; 外部式 选择器 标签选择器 类选择器 使用&quot;.&quot;开头 ID选择器 类选择器和ID选择器的区别 ID选择器只可以使用一次，而类选择器可以使用多次 这是错的嗷 还可以这样写 亲戚关系选择器hhh 子选择器 选择class名为1下的子元素&lt;span&gt; 后代选择器 与子选择器的区别：子选择器只选择他的直接后代，而后代选择器把他的儿子孙子重孙都选上了,都变成粉色了 通用选择器 这下所以标签的元素都成粉的了 伪类选择器 给不存在的标签（或标签的某种状态）设置样式 当鼠标经过时变粉 分组选择器 相当于 继承，优先级和重要性 样式的继承性 什么是继承性？ 允许样式不仅应用于某个特定html标签，而且应用于后代 hhhhh是红色，wllll也是红色 但是某些CSS样式不具有继承性 选择器的优先级 1、如果一个元素使用了多个选择器,则会按照选择器的优先级来给定样式。 2、选择器的优先级依次是: 内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 权值 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 若多个选择器匹配到了一个标签上，那么谁的权值高就显示谁的样式 !important 带有!important的会被应用，无论其他的权值有多高 设置样式 关于字体 font-family font-size font-weight字体粗细 值 描述 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100/200/300/400/500/600/700/800/900 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 font-style字体样式 值 描述 normal 默认值。浏览器显示一个标准的字体样式。 italic 浏览器会显示一个斜体的字体样式。 oblique 浏览器会显示一个倾斜的字体样式。 inherit 规定应该从父元素继承字体样式。 color设置字体颜色 英文命令颜色 RGB 颜色 十六进制颜色 font家族的缩写 这么多行的代码其实可以缩写为一句： 想要使用这种简写方式，至少要指定font-size和font-family，其他属性未指定则会使用默认值 在缩写时 font-size 与 line-height 中间要加入“/”斜扛 关于文本 text-decoration给文本添加修饰 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 blink 定义闪烁的文本。 inherit 规定应该从父元素继承 text-decoration 属性的值。 text-indent为文本添加首行缩进 1em 等于当前的字体尺寸。 2em 等于当前字体尺寸的两倍。 例如，如果某元素以 12pt 显示，那么 2em 是24pt。 在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体 line-height为文字间设置行间距/行高 letter/word-spacing增加或减少字符间的空白 letter-spacing为文字或字母中间设置间隔 word-spacing为单词之间设置间距 text-align设置文本对齐方式 为块状元素设置对齐方式 值 描述 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承 text-align 属性的值。 盒模型 概念 在CSS中，HTML中的标签，被分为三类 块状元素 内联块元素 可以将内联元素转换为块状元素 内联元素 和其他元素都在一行上 元素的高度、宽度及顶部和底部边距不可设置 元素的宽度就是它包含的文字或图片的宽度，不可改变 可以将块状元素转换为内联元素 内联块状元素 和其他元素在一行上 高宽，行高，顶底边距都可设置 当display设置为none时，元素隐藏 使用 盒模型基本知识 padding 是盒子里的内容到盒子边框的距离 border 是盒子的边框 margin 是盒子边框距离别的盒子边框的距离 css内定义的宽（width）和高（height），指的是填充以里的内容范围。 因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 background-color背景色 border为盒子添加边框 值 描述 border-width 规定边框的宽度。参阅：border-width 中可能的值。 border-style 规定边框的样式。参阅：border-style 中可能的值。 border-color 规定边框的颜色。参阅：border-color 中可能的值。 可以简写为 border-方向 为盒子的某一边框设置样式 border-radius 为边框四个角分别设置圆角 顺序为左上、右上、右下、左下 也可以分开写： 如果四个圆角都为10px;可以这么写： 如果左上角和右下角圆角效果一样为10px，右上角和左下角圆角一样为20px，可以这么写： 需要特别注意的：一个正方形，当设置圆角效果值为元素宽度一半时，显示效果为圆形。例如： padding为盒子设置填充 上右下左 其他设置方法与border-radius类似 margin为盒子设置外边距 一样 布局模型 流动模型（Flow） 默认的网页布局模式 特征 块状元素会在所处的包含元素内，自上而下垂直延申分布(默认状态下块元素的宽度为100%) 内联元素都会在包含元素内从左到右水平分布 浮动模型(Float) 可以设置两个块状元素显示一行 设置靠左or靠右 也可以分别设置，使之一个靠左一个靠右 层模型 关于文档流可以看这篇 层模型有三种形式： 1、绝对定位(position: absolute) 这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 2、相对定位(position: relative) 它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 我的理解是，先正常生成元素，然后再浮起来，相对原来的位置进行移动 3、固定定位(position: fixed) fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响 弹性盒模型 这个好这个好 弹性盒子由弹性容器和弹性子元素组成 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。 常用属性 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 flex-direction 决定子元素排列方向 值 描述 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 flex-wrap flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 值 描述 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 可以取三个值： （1） nowrap (默认)：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 align-items align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 值 描述 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 justify-content justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 值 描述 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 弹性子元素属性 属性 描述 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 order属性 ：用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认为0。 flex-grow属性 ：一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。 flex-shrink属性 ：一个数字，规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。 flex-basis属性 ：一个长度单位或者一个百分比，规定元素的初始长度。 auto：默认值。长度等于元素的长度。如果该项目未指定长度，则长度将根据内容决定。 flex属性 flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。 flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。 值 描述 flex-grow 一个数字，规定项目将相对于其他元素进行扩展的量。 flex-shrink 一个数字，规定项目将相对于其他元素进行收缩的量。 flex-basis 项目的长度。合法值：“auto”、“inherit” 或一个后跟 “%”、“px”、“em” 或任何其他长度单位的数字。 auto 与 1 1 auto 相同。 none 与 0 0 auto 相同。 initial 设置该属性为它的默认值，即为 0 1 auto。 inherit 从父元素继承该属性。 align-self属性 值 描述 auto 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。 stretch 元素被拉伸以适应容器。 center 元素位于容器的中心。 flex-start 元素位于容器的开头。 flex-end 元素位于容器的结尾。 baseline 元素位于容器的基线上。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 作者：弓三水 链接： 来源：简书 写的很全很好很厉害，直接复制了，方便以后查阅"},{"title":"图（Graph）","date":"2020-04-26T01:40:33.000Z","url":"/2020/04/26/graph/","content":"[TOC] 图（Graph） 表示多对多的关系 包含 一组顶点:通常用V（Vertex）表示顶点集合 一组边：通常用E（Edge）表示边的集合 边是顶点对：（v,w）属于E，v,w属于V 有向边&lt;v,w&gt;表示从v指向w的边（单行线） 不考虑重边和自回路 抽象数据类型定义 类型名称：图（Graph） 操作对象集：G（V，E）由一个非空的有限顶点集合V和一个有限边集合E组成 操作集 Graph Create() Graph InsertVertex(Graph G,Vertex V) Graph InsertEdge(Graph G,Edge e) void DFS(Graph G,Vertex v) void BFS(Graph G,Vertex v) void ShortestPath(Graph G,Vertex v,int Dist[]) void MST(Graph G)最小生成树 如何表示一个图 邻接矩阵 有边记为1 优缺点 直观简单，方便查找任意一对顶点之间是否有边，方便查找任一顶点的所有邻接点（有边直接相连的顶点） 方便计算任意顶点的度 无向图：对应行或列非零元素个数 有向图：非零行是出度，非零列的入度 若是稀疏矩阵的话会造成空间浪费以及时间浪费 MGraph创建并初始化 向MGraph插入边 建立完整的MGraph 这个矩阵存的是顶点与顶点间的关系 邻接表 用一个指针数组，对应矩阵每行一个元素，只存非零元素 优缺点 对于稀疏矩阵在时间和空间上的表现都比较好 方便找任意顶点的邻接点 方便计算任一顶点的度 无向图：是 有向图：否，只能计算出度，需要构造逆邻接表 难以检查任意一对顶点间是否存在边 用一个长为N(N+1)/2的一维数组表示 Gij在这个数组中对应的下标为(i*(i+1)/2+j) 图的遍历 深度优先搜索(Depth First Search,DFS) 思路:从起点出发，挑视线内一盏灯点亮，然后走到刚刚点亮的等上，继续重复，如果视线内所有灯都被点亮，就原路返回，退后一格，然后继续看，直到退到起点 广度优先搜素(Breath First Search,BFS) 与树的层序遍历类似 思路：从起点开始，把所有邻接点压入队列，然后弹出一个，再把这的结点的所有邻接点压入队列，重复直至队列空 最短路问题 分类： 单源最短路径问题：从某固定点出发，求其到所有其他顶点的最短路径 有向无权图 有向有权图 多源最短路问题：求任意两顶点间的最短路径 单源有向无权图的最短路 无权图的最短路可以认为是，从起点到终点经过的顶点数最少的路 与BFS有点类似 因为每次找的都是这个结点的邻接点，因此最后出来的结果是最短的 path存储来这个结点的结点，只要一直网下推，就能推出整条最短路 单源有向有权图 **权重和最小 ** Dijkatra算法 令s = {源点s + 已经确定了从s到的最短路径的顶点v} 对于任何一个没有收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点，即{s -&gt; (v属于s) -&gt; v}的最小长度(这个最小长度不是最终的最小长度) 前提条件：路径是按照递增的顺序生成的 真正的最短路必须只经过s中的顶点，因为，假设一个顶点不在s中，但从源点到v经过他，这时就产生了矛盾，因为路径书按照递增顺序生成的 每次从未收录的顶点中选一个dist最小的收录 增加一个v进入s，可能会影响另外一个w的dist值 要产生这样的结果要满足 v在s到w的路径上 v到w一定有一条直接的边，因为路径按照递增顺序生成 "},{"title":"正则表达式","date":"2020-04-23T15:44:33.000Z","url":"/2020/04/23/Regular-expression/","content":"[TOC] 在JavaScript中创建一个正则表达式对象 正则表达式由两种基本字符类型组成 原义文本字符 代表要查找文本的原本意思的字符 元字符 在正则表达式中有特殊含义的非字母字符 字符类 一般情况下正则表达式一个字符对应字符串一个字符 要匹配某类字符使用[]构建一个类 类指符合某些特征的对象 [abc]意思就是把abc归为一类，匹配这类字符 [^abc]就是匹配出除abc以外的字符 范围类 可以使用[a-z]表示匹配a到z的任意字符 [a-zA-Z]表示匹配a到z和A到Z的任意字符 预定义类 字符 等价类 含义 . [^\\r\\n] 除了回车、换行符之外的其他字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符(字母、数字、下划线) \\W [^a-zA-Z_0-9] 非单词字符 边界 \\b单词边界,\\B非单词边界 ^表示以…开始，$表示以…结束 量词 字符 含义 ? 0或1 次 + ≥1 次 * ≥0 次（任意次） {n} n 次 {n,m} n到m 次 {n,} ≥n 次 贪婪模式 尽可能多的匹配 例如有一个字符串12345678 \\d{3,6}这样进行匹配的话结果是123456，并非123或1234或… 非贪婪模式 尽量少的匹配，一旦匹配成功就不再继续尝试 \\d{3,6}结果是123，456 JS默认使用贪婪模式，想使用非贪婪模式在量词后加上?即可 分组 使用()进行分组 假如你想匹配一个小写字母加数字连续出现3次就可以这样写([a-z]\\d){3},而这样是不行的[a-z]\\d{3}这样结果是匹配一个字母加三个数字 或 |表示或 假如想匹配123345和124445就可以这样写12(33|44)45 感觉功能上和[]有一点点重叠 反向引用 假如你想把2020-4-24变为24/4/2020就可以这样写(\\d{4})-(\\d{2}|\\d{1})-(\\d{2}|\\d{1}) 然后使用$1$2$3捕获分组写成$3/$2/$1 忽略分组 假如你不想捕获某个分组就可以 这样(\\d{4})-(\\d{2}|\\d{1})-(?:\\d{2}|\\d{1})这样就匹配不到日期了,$3就是没内容的 前瞻&amp;后顾 文本头叫前文本尾部叫后 前瞻就是在正则表达式匹配带规则时，向前检查是否符合断言，后顾与之相反 JS不支持后顾 既要符合exp正则，又要满足断言要求 正向/肯定 匹配：符合特定断言 负向/否定 匹配：不符合特定断言 名称 正则写法 含义 正向前瞻 exp(?=assert) 符合exp正则，且符合设置的断言 负向前瞻 exp(?!assert) 符合exp正则，且不符合设置的断言 断言部分只作为约束条件而存在，并不会参与字符本身的匹配和替换，匹配字符的是exp正则部分 假如你想匹配一个字母后加一个数字，但是只替换字母就可以 这样a1aaa3一个字符串[a-z](?=\\d) RegExp对象属性 名称 含义 global g：全文搜索，默认false ignoreCase i：大小写敏感，默认false multiline m：多行搜索，默认false lastIndex 下次匹配的起始位置 该属性只有设置标志g才能使用，实现遍历检索匹配 source 正则的文本字符串（正则主体） gim这三个对象都是只读的 RegExp对象方法 test()方法 返回true或false，测试字符串参数中是否存在所匹配正则的字符串 非全局调用 默认从字符串第一个字符出发，找到第一个符合条件的子字符串就停止 全局调用 如果reg1标志g的话，lastIndex就会起作用，可以通过不断调用reg1.test()对字符串进行遍历，找出所有符合条件的子字符串 每调用一次reg1.test()就会使lastIndex移动到上一次找出的字符串的最后一个字符的下一个字符上，当找不到符合条件的子字符串时，会将lastIndex重置为0 exec()方法 全局调用 返回一个数组，包含额外的属性 index 和 input，找不到返回null | 属性/索引 |描述 | 例子 | | ---------------- | ------------------ ------------- | ------------------------------------------------- | |[0] |匹配的全部字符串 |Quick Brown Fox Jumps | | [1], ...[*n* ] |括号中的分组捕获 |[1] = Brown[2] = Jumps | |index |匹配到的字符位于原始字符串的基于0的索引值 | 4 | | input |原始字符串 | The Quick Brown Fox Jumps Over The Lazy Dog | 非全局调用 与test()方法类似"},{"title":"JavaScript学习笔记","date":"2020-03-30T12:51:07.000Z","url":"/2020/03/30/JavaScript/","content":"[TOC] 插入JS 使用&lt;script&gt;&lt;/script&gt;标签 &lt;script type=“text/javascript”&gt;固定写法 JS也可以单独存在类似CSS 在JS文件中不需要&lt;script&gt;标签 通过上面这句来引用js文件 JS一般放在&lt;head&gt;或&lt;body&gt;里，浏览器读到时就会运行 基础 js的每句代码结束都需要; 用//添加注释，/*注释内容*/实现多行注释 使用var声明变量 JS中变量区分大小写 if和else用法与C语言几乎一样 函数使用function定义 定义好后不会自己执行，需要调用 输出 document.write() 直接使用引号 输出变量 输出多项内容 输出html标签 alert() 弹出一个消息对话框，包含一个确定按钮 点击确定前不能进行其他任何操作 互动 confirm() str是在对话框中显示的内容 返回值是Boolean 用户点击确定时返回ture，取消返回false prompt() str1是在对话框中显示的文本 str2是文本框中的内容 点确定返回文本框中的内容，取消返回null 窗口 window.open() 注意使用单引号 URL可选，在窗口中显示网页的网址或路径。如果省略，那么窗口就不显示任何文档 窗口名称可选，被打开窗口的名称 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。 窗口字符串 sample 打开网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口 window.close() 练习 1、新窗口打开时弹出确认框，是否打开 2、通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/ 3、打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。 变量 声明 Javascript使用 声明变量，可以存储数字、字符、字符串 表达式 结果是goodbyeverge 数组 声明 在括号内指定数组长度，虽然数组长度已经确定，但仍可以将数据储存在规定长度之外 赋值 实现同样的效果还有两种方法 可以使用未使用的下标，不断给数组添加成员 数组没有赋值直接输出的话会输出undefined 数组长度 可以使用 在你改变数组长度后，即使里面什么都没存，长度还是你改变后的。 如果，一个数组是这样var arr = [1,2,3] 长度为3，如果这是你进行 arr.length = 2,那么长度就会变成2，会把原来arr[2]的位置变为undefined 数组元素增加长度也会改变 二维数组 定义 函数 定义 调用函数 在&lt;script&gt;标签内直接调用 在HTML文件中调用，通过点击按钮调用定义好的函数 含有参数的函数 有返回值的函数 事件 事件是可以被Javascript侦测到的行为 onclick 鼠标点击事件 onload 加载事件 加载页面时会触发onload事件 可以理解为打开页面时会出发的事件 onubload卸载事件 当用户刷新，关闭页面时触发的事件 其他事件使用方式大同小异 对象 什么是对象 JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。 **对象的属性：**反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等； **对象的方法：**能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；就是在对象的基础上再进行操作 JavaScript 提供多个内建对象，比如 String、Date、Array 等等，使用对象前先定义，如下使用数组对象： 访问对象属性的语法: 如使用 Array 对象的 length 属性来获得数组的长度： 以上代码执行后，myl的值将是：6 访问对象的方法： 如使用string 对象的 toUpperCase() 方法来将文本转换为大写： 以上代码执行后，request的值是**：HELLO WORLD!** Date 日期对象 可以存储任意一个日期，可以精确到毫秒 初始值为当前电脑系统世间 自定义初始值可以 我们最好使用下面介绍的“方法”来严格定义时间。 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;” Date对象中处理时间和日期的常用方法： 返回/设置年份的方法 返回星期方法 返回/设置时间的方法 get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。 时间加一小时就是 String 字符串对象 charAT() 返回指定位置的字符 参数index即字符在字符串中的下标 返回一个字符长度为1的字符串 indexOf() 返回指定的字符串首次出现的位置 返回需要检索的字符串的第一个字符第一次出现的位置，如果没有则返回-1 split() 字符串分割 如果把空字符串 (&quot;&quot;) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 若达到分割的次数之后，后面分割出来的字串就不会输出，或者说到达分割的次数之后就不再分割 substring() 提取字符串 startPos和stopPos可以理解为字符串数组开始和结束的下标，两个参数相等的话就返回一个空串，如果stop比start大会先交换这两个参数 stopPos 假设一个字符串是abcdefg那么substring(0,4)提取出来的结果是abcd，到stopPos结束，并不包括stopPos substr() 提取指定数目字符串 **注意：**如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 如果startPos为负数且绝对值大于字符串长度，startPos为0 search() 检索字符串中指定的子字符串（正则） 返回第一个匹配结果的index，查找不到返回-1 search()不执行全局匹配，总是从字符串的开始进行检索 match() 检索字符串找到一个或多个与RegExp匹配的文本 参数 regexp 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你没有给出任何参数并直接使用match() 方法 ，你将会得到一 个包含空字符串的 Array ：[&quot;&quot;] 。 返回值 如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。 如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。 附加属性 如上所述，匹配的结果包含如下所述的附加特性。 groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。 index: 匹配的结果的开始位置 input: 搜索的字符串. 描述 如果正则表达式不包含 g 标志，str.match() 将返回与 RegExp.exec(). 相同的结果。 replace() 替换字符串中指定子字符串或正则匹配的结果 Math 对象 **注意：**Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 Math 对象属性 Math对象方法 Array 数组对象 concat() 数组连接 返回一个连接后的数组，不会改变原来的数组 可以这样写直接给数组后面在加上4，5，注意并不改变mya数组 join() 指定分隔符连接数组元素 若参数留空则默认使用，分开 reverse() 颠倒数组元素顺序 **注意：**该方法会改变原来的数组，而不会创建新的数组。 slice() 选定元素 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 sort() 数组排序 **sort()**方法使数组中的元素按照一定的顺序排列。 语法: 参数说明： 1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。 2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 所以，比较函数格式如下： 具体实现 运行结果： window对象 JavaScript定时器 setInterval() 载入页面后每隔指定时间执行代码 代码：要执行的代码 交互时间：周期执行的时间间隔，单位毫秒 返回值：是一个值，可以把这个值传给clearInterval()从而取消setInterval()的执行 调用函数格式(假设有一个clock()函数): clearInterval() setTimeout() 延迟时间到后执行代码 clearTimeout() 与clearInterval()相似 history对象 history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 **注意:从*窗口*被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 语法： **注意：**window可以省略。 History 对象属性 History 对象方法 使用length属性，当前窗口的浏览历史总长度，代码如下： go() 语法： 参数： location对象 location用于获取或设置窗体的URL，并且可以用于解析URL。 语法: location对象属性图示: location 对象属性： location 对象方法: navigator对象 DOM 什么是DOM 参考这个 获取元素 getElementById 获取的元素是一个对象，想要对这个元素操作还需要其他东西 这样是错误的 getElementsByName Element比上面那个多了个s 由于name属性可能是不唯一的，因此返回值是元素数组，同样也有length属性 getElementsByTagName Tagname是标签的名称，如p、a、img等标签名 返回值也是数组也有length getAttribute() 通过元素结点的属性名获取属性的值 操作元素 setAttribute() 1.name: 要设置的属性名。 2.value: 要设置的属性值 注意： 1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 innerHTML object是获取的元素 这样就对了 改变HTML样式 object是获取的元素 property 显示和隐藏 value的值 控制类名 获取元素class属性 为元素指定一个css样式 结点属性 在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document **二、nodeValue 属性：**节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问结点 访问子节点childNodes 返回值是所有子节点的列表，可以看作数组，没有子节点则返回一个不包含结点的列表 访问子节点的第一项和最后一项 一、**firstChild **属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： **说明：**与elementNode.childNodes[0]是同样的效果。 二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： **说明：**与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 访问父节点parentNode 一个结点只能有一个父结点 访问兄弟结点 nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。 语法： **说明：**如果无此节点，则该属性返回 null。 previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。 语法： **说明：**如果无此节点，则该属性返回 null。 插入结点 appendChild() 在指定节点的最后一个子节点列表之后添加一个新的子节点。 这里的newnode需要使用document.createElement(&quot;标签&quot;)来创建 insertBefore() 方法在参考节点之前插入一个拥有指定父节点的子节点 newnode: 要插入的新节点。 node: 指定此节点前插入节点。 而所谓的“拥有指定父节点”，就是指被参照的节点的父节点就是调用insertBefore方法的节点。 如果给定的子节点是对文档中现有节点的引用，insertBefore()会将其从当前位置移动到新位置。 如果给定的子节点是DocumentFragment，那么DocumentFragment的全部内容将被移动到指定父节点的子节点列表中。 删除节点 removeChild() child 是要移除的那个子节点. node 是child的父节点. oldChild保存对删除的子节点的引用. oldChild === child. 被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如上例中的oldChild来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被内存管理回收. replaceChild() replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 语法： 参数： newnode : 必需，用于替换 oldnew 的对象。 oldnew : 必需，被 newnode 替换的对象。"},{"title":"HTML学习笔记","date":"2020-03-28T12:01:31.000Z","url":"/2020/03/28/HTML/","content":"[TOC] html 基础 html文件的基本结构 标签 这些都很简单 body标签 一般网页需要展示出来的内容就存放在body标签里 p标签 段落标签 hx标签 共有h1到h6六个从大到小的标签 em和strong标签 em是斜体，strong是加粗 span标签 span本身没有什么作用，它就是用来设置单独的样式用的 q标签 短文本引用，引用后会自动给引用的部分加上引号 blockquote标签 长文本引用，这个不会加引号，但是会产生缩进 br标签和&amp;nbsp; html中回车空格是无效的，换行需要&lt;br /&gt;或&lt;br&gt;(常用&lt;br /&gt;) br与其他标签不同的是，br不需要成对出现 &amp;nbsp;就代表空格 hr标签 效果 写成&lt;hr&gt;或&lt;hr /&gt; address标签 效果 陕西西安 code标签 效果 while(1) pre标签 插入大段代码 列表/表格 ul ol标签 123 456 789 无序列表&lt;ul&gt; 123 456 789 有序列表&lt;ol&gt; div标签 可以用来划分区域 table标签和caption标签 这是标题 班级 学生数 平均成绩 一班 30 89 二班 35 85 进阶 a标签 链接显示的文本 默认情况下链接的网页是在档期浏览器窗口打开 z这样写就是在新窗口打开 malito标签 发送 mailto后若有多个参数的话，第一个参数用?开头，后面跟的参数用&amp;开头 mailto后是**&quot;:&quot;,其他参数后是&quot;=&quot;** img标签 图片使用src标识位置 alt当图像不可见时，显示的文本 title鼠标滑过时显示的文本 img也不需要成对出现 表单 可以把用户输入内容传到服务端 &lt;form&gt;标签成对出现 method数据的传输方式（get/post） action数据被传送到的地方 所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 标签之间 文本/密码输入框 &lt;input /&gt;单独出现 type=&quot;text&quot;时文本输入框 type=&quot;password&quot;时是密码输入框 name：文本框命名 value：文本框默认值，不输入时显示的内容 多行文本输入 单选框/复选框 type =radio为单选框 =checkbox为复选框 value提交到服务器的值 name为控件命名 check=checked时该项默认勾选 同一组的单选按钮name一定要相同这样才能实现单选 你是人 你不是🐖 1 2 3 下拉列表框 value是向服务器提交的值 selected=&quot;selected&quot;表示该项默认选中,没有这个默认第一项 1 2 使用下拉列表框进行多选 再&lt;select&gt;中添加multiple=“mutiple” 1 2 提交/重置按钮 type=&quot;submit&quot;这样设置才是提交按钮 value按钮上显示的内容 label标签 本来要选中控件就需要点中控件本身，有了label就可以把某些文字与控件关联，实现点击文字就聚焦到控件上 你是🐖 你是人 你是🐖 你是人 "},{"title":"算法竞赛入门经典笔记","date":"2020-03-23T07:06:21.000Z","url":"/2020/03/23/string/","content":"[TOC] 数组 程序3-1 逆序输出 数组声明在main函数外可以开的更大 数组不可以直接b=a，但可以使用memcpy(b,a,sizeof(int)*k),这个函数中的int需要根据数据类型不同，进行改变。这个函数包含在string.h中 程序3-2 开灯问题 开灯问题。有n盏灯，编号为1～n。第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉灯 将被打开，开着的灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？输入n和k，输出开着的灯的编号。k≤n≤1000。 样例输入： 7 3 样例输出： 1 5 6 7 模拟题 蛇形填数。在n×n方阵里填入1，2，…，n×n，要求填成蛇形。例如，n＝4时方阵为： 10 11 12 1 9 16 13 2 8 15 14 3 7 6 5 4 在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔。因为“悔棋”往往比较麻烦。 细心的读者也许会发现这里的一个“潜在bug”：如果越界，x+1会等a[x+1][y]将访问非法内存！幸运的是，这样的担心是不必要的。“&amp;&amp;”是短路运算符（还记得我们在哪里提到过吗？）。如果x+1&lt;n为假，将不会计算“!a[x+1][y]”，也就不会越界了。 字符数组 程序3-4 竖式问题 竖式问题。找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出(为了便于观察，竖式中的空格改用小数点显示，但所写程序中应该输出空格，而非小数点）。 样例输入： 2357 样例输出： &lt;1&gt; …775 X…33 .2325 25575 The number of solutions = 1 伪代码 strchr(): ​ 原型： ​ char *strchr(const char *str, int c) ​ 参数： ​ str–要被检索的C字符串 ​ c–在str中要搜索的字符 ​ 返回值： ​ 该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。 sprintf()： ​ 将格式化的数据写入字符串 ​ 原型： ​ int sprintf(char *str, char * format [, argument, …]); ​ 参数： ​ str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量 ​ 返回值： ​ 成功则返回参数str 字符串长度，失败则返回-1 strlen()： ​ 返回字符串实际长度 scanf(&quot;%s&quot;, s) ​ 使用该函数读取字符串，当遇到空格或TAB时，不会将他们读入 竞赛题目选讲 例题3-2 WERTYU（WERTYU, UVa10082） 把手放在键盘上时，稍不注意就会往右错一位。这样，输入Q会变成输入W，输入J会变成输入K等。键盘如图3-2所示。 输入一个错位后敲出的字符串（所有字母均大写），输出打字员本来想打出的句子。输入保证合法，即一定是错位之后的字符串。例如输入中不会出现大写字A。 样例输入： O S, GOMR YPFSU/ 样例输出： I AM FINE TODAY. 主要是常量数组的使用 输入一个字符串，判断它是否为回文串以及镜像串。输入字符串保证不含数字0。所谓回文串，就是反转以后和原串相同，如abba和madam。所有镜像串，就是左右镜像之后和原串相同，如2S和3AIAE。注意，并不是每个字符在镜像之后都能得到一个合法字符。在本题中，每个字符的镜像如图3-3所示（空白项表示该字符镜像后不能得到一个合法字符）。 输入的每行包含一个字符串（保证只有上述字符。不含空白字符），判断它是否为回文 串和镜像串（共4种组合）。每组数据之后输出一个空行。 样例输入： NOTAPALINDROME ISAPALINILAPASI 2A3MEAS ATOYOTA 样例输出： NOTAPALINDROME – is not a palindrome. ISAPALINILAPASI – is a regular palindrome. 2A3MEAS – is a mirrored string. ATOYOTA – is a mirrored palindrome. 头文件ctype.h中定义的isalpha，isdigit，isorint可以用来判断字符的属性，toupper，tolower可以用来转换大小写 例题3-4 猜数字游戏的提示（Master-Mind Hints, UVa 340） 实现一个经典&quot;猜数字&quot;游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。 输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。 样例输入： 4 1 3 5 5 1 1 2 3 4 3 3 5 6 5 5 1 6 1 3 5 1 3 5 5 0 0 0 0 10 1 2 2 2 4 5 6 6 6 9 1 2 3 4 5 6 7 8 9 1 1 1 2 2 3 3 4 4 5 5 1 2 1 3 1 5 1 6 1 9 1 2 2 5 5 5 6 6 6 7 0 0 0 0 0 0 0 0 0 0 样例输出： Game 1: (1,1) (2,0) (1,2) (1,2) (4,0) Game 2: (2,4) (3,2) (5,0) (7,0) 例题3-5 生成元（Digit Generator, ACM/ICPC Seoul 2005, UVa1583） 如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。 为了节省空间，提升效率，可以一次性把100000内所有数字的生成元计算出来，然后输出时直接调用 一个数的生成元可能有多个 例题3-6 环状序列（Circular Sequence, ACM/ICPC Seoul 2004, UVa1584） 长度为n的环状串有n种表示法，分别为从某个位置开始顺时针得到。例如，图3-4的环状串有10种表示： CGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称为&quot;最小表示&quot;。 输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是CCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。 我理解能力不行，基本上每个题都要看原题才看得懂（可以上vj上看） 字典序（lexicographical order）：就是字符串在字典中的排序。abc比bcd小，hi比his小，1，2，4，7比1，2，5小 习题 习题3-1 得分（Score, ACM/ICPC Seoul 2005, UVa1585） 题目地址： 习题3-2 分子量（Molar Mass, ACM/ICPC Seoul 2007, UVa1586） 又臭又长的烂代码，但是至少可以安慰自己这个代码好理解把，哈哈哈 这题考察的应该是ctype.h里的函数的应用，isalpha，isdigit，当时没想到isdigit这个函数，所以写的比较复杂 在vj的评论区看到了29行的代码，牛皮 习题3-3 数数字（Digit Counting , ACM/ICPC Danang 2007, UVa1225） 习题3-4 周期串（Periodic Strings, UVa455） 搞我心态。。 …到网上随便找了个oj，贡献了一发WA，改了改代码，再到vj上就就提交上去了，哈哈哈vj这是为了我好！！！ 这个代码在vj上没过，在台湾那个oj上过了，不得不说vj真是严格 调整了一下格式总算AC了 习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227） 这个代码没AC，格式有问题 写了一中午，在vj上获得两发persentation error之后脑子炸裂决定放弃 函数和递归 例题4-3 救济金发放（The Dole Queue, UVa 133） n(n&lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。 输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。 例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213） C++和STL 引用(与指针类似比指针弱) 直接再参数名之前加上一个&amp;，再函数内修改参数的值，也会修改函数的实参 字符串 C++中提供了一个string类型使处理字符数组更加简便，cin/cout可以直接读写string，还可以像整数一样相加 输入数据的每行包含若干个（至少一个）以空格隔开的整数，输出 每行中所有整数之和。如果只能使用字符与字符数组，一般有两种方案：一是使用getchar( )边读边算，代码较短，但容易写错，并且相对较难理解(5)；二是每次读取一行，然后再扫描该行的字符，同时计算结果。如果使用C＋＋，代码可以很简单。 string类在string头文件中，而stringstream在sstream头文件中 STL 一个总结 对于需要输入多组数据的题目，当第一组数据处理完之后，一定要及时初始化各种变量，因此，定义变量时，尽量把变量定义在需要用的地方的附近。 对于一些需要特定格式的题目，例如需要使用空格隔开字母，但最后一个字母后不能有空格，如果直到一共可以输出多少个，既可以做一个判断，最后一个字母后不接空格，如果不知道要输出多少个，可以把空格放在每个字母之前，对第一个进行特殊化 "},{"title":"PTA测试题（C语言程序设计）","date":"2020-03-12T13:13:29.000Z","url":"/2020/03/12/PTA-Pratice/","content":"循环测验 编程题 7-1 小于m的最大的10个素数 给定一个整数m（50&lt;m&lt;20000），找出小于m的最大的10个素数。 输入格式: 输入在一行中给出一个正整数m（50&lt;m&lt;20000）。 输出格式: 在一行中按递减顺序输出10个满足条件的素数，每个素数输出占6列。没有其它任何附加格式和字符。 输入样例: 输出样例: **思路：**输入m后，写一个循环体，判断每一个小于m的数字，若为素数则输出 7-3 求N分之一序列前N项和 本题要求编写程序，计算序列 1 + 1/2 + 1/3 + … 的前N项之和。 输入格式: 输入在一行中给出一个正整数N。 输出格式: 在一行中按照“sum = S”的格式输出部分和的值S，精确到小数点后6位。题目保证计算结果不超过双精度范围。 输入样例: 输出样例: 7-5 吃鱼还是吃肉 国家给出了 8 岁男宝宝的标准身高为 130 厘米、标准体重为 27 公斤；8 岁女宝宝的标准身高为 129 厘米、标准体重为 25 公斤。 现在你要根据小宝宝的身高体重，给出补充营养的建议。 输入格式： 输入在第一行给出一个不超过 10 的正整数 N，随后 N 行，每行给出一位宝宝的身体数据： 其中性别是 1 表示男生，0 表示女生。身高和体重都是不超过 200 的正整数。 输出格式： 对于每一位宝宝，在一行中给出你的建议： 如果太矮了，输出：duo chi yu!（多吃鱼）； 如果太瘦了，输出：duo chi rou!（多吃肉）； 如果正标准，输出：wan mei!（完美）； 如果太高了，输出：ni li hai!（你厉害）； 如果太胖了，输出：shao chi rou!（少吃肉）。 先评价身高，再评价体重。两句话之间要有 1 个空格。 输入样例： 输出样例： 选择测验 7-3新胖子公式 根据钱江晚报官方微博的报导，最新的肥胖计算方法为：体重(kg) / 身高(m) 的平方。如果超过 25，你就是胖子。于是本题就请你编写程序自动判断一个人到底算不算胖子。 输入格式： 输入在一行中给出两个正数，依次为一个人的体重（以 kg 为单位）和身高（以 m 为单位），其间以空格分隔。其中体重不超过 1000 kg，身高不超过 3.0 m。 输出格式： 首先输出将该人的体重和身高代入肥胖公式的计算结果，保留小数点后 1 位。如果这个数值大于 25，就在第二行输出 PANG，否则输出 Hai Xing。 输入样例 1： 输出样例 1： 输入样例 2： 输出样例 2： 7-6计算分段函数[1] 本题目要求计算下列分段函数f(x)的值： 输入格式: 输入在一行中给出实数x。 输出格式: 在一行中按“f(x) = result”的格式输出，其中x与result都保留一位小数。 输入样例1: 输出样例1: 输入样例2: 输出样例2: "},{"title":"树（Tree）","date":"2020-03-09T08:24:48.000Z","url":"/2020/03/09/tree/","content":"[TOC] 树（Tree） n个节点构成的有限集合 n = 0时，称为空树 非空树有以下性质： 树中有一个称为&quot;根（Root）&quot;的节点，用r表示 其余节点互不相交且有限，其中每个集合本身又是一棵树，称为原树的子树(SubTree) 子树是不相交的 除根节点外，每个节点有且仅有一个父节点 这些都不是树 一棵N个节点的树有N-1条边 树的一些基本术语 节点的度(Degree)：节点的子树个数 树的度：树的所有节点中最大的度数（上面那个树的度为3） 叶结点（Leaf）：度为零的节点，即没有子树 父结点（Parent）：有子树的节点是其子树的根节点的父节点 子结点（Child） 兄弟结点（Sibling）：具有同一父节点的各节点彼此 路径和路径长度： 祖先节点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个节点的祖先结点，比如从A到L，ABG都是L的祖先结点 子孙结点（Descendant） 结点的层次（Level）：规定根结点在1层，其他任一结点的层数是其父结点层数+1， 树的深度（Depth）：树中所有结点中的最大层次就是这棵树的深度 树的表示 为了节省空间和方便这里使用兄弟-儿子表示法 兄弟-儿子表示法 Element FirstChild NextSibling 链表的每个结点如上图 链接起来后如下图 这样的树被称为二叉树 二叉树（Binary Tree） 二叉树的定义 二叉树是一个有穷的结点集合 这个集合可以为空 若不为空，则它是由根节点和称为其左子树和右子树的两个不相交的二叉树组成 二叉树的五种基本形态 空树 只有根 只有左子树 只有右子树 左右子树都有 二叉树和其他度为2的树的不同在于二叉树的子树有左右顺序之分 特殊的二叉树 斜二叉树（Skewed Binary Tree） 只有左子树或只有右子树 完美二叉树（Perfect Binary Tree）/满二叉树（Full Binary Tree） 完全二叉树（Complete Binary Tree） 有n个结点的二叉树，对树中的结点按上图所示方式编号，编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同 将完美二叉树的叶结点，从有往左依次删除任意个数，所形成的二叉树就是完全二叉树 下图就不是一个完全二叉树 二叉树的几个性质 一个二叉树第i层的最大结点数为：2^(i-1) , i &gt;= 1 深度为k的二叉树有最大结点总数为：2^k - 1 ,k &gt;= 1 完美二叉树可以达到2^k - 1个结点 对于任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶结点个数，那么n0 = n2 + 1 二叉树的抽象数据类型定义 类型名称：二叉树 数据对象集： ​ 一个有穷结点集合。 ​ 若不为空，则有根节点和其左、右二叉树组成 操作集： Boolean IsEmpty(BinTree BT):判断二叉树是否为空 void Traversal(BinTree BT):遍历，按某种顺序访问每个结点 void PreOrderTraversal(BinTree BT):先序-根、左子树、右子树 void InOrderTraversal(BinTree BT):中序—左子树、根、右子树 void PostOrderTraversal(BinTree BT):后序—左子树、右子树、根 void LevelOrderTraversal(BinTree BT):层次遍历，从上到下、从左到右 BinTree CreatBinTree():创建二叉树 二叉树的存储结构 1. 顺序存储结构 完全二叉树可以方便的使用数组实现 共n个结点 结点 A B C D E 序号 1 2 3 4 5 非根结点（i &gt; 1）的父结点的序号是i/2 结点（i）的左孩子结点序号是2i（2i &lt;= n，否则没有左孩子） 结点（i）的右孩子结点的序号是2i+1（2i+1 &lt;= n,否则没有右孩子） 一般二叉树也可以使用数组实现，但是会造成空间浪费 2. 链表存储 结点的结构：|Left|Data|Right| 二叉树的遍历 遍历（递归） 简单但是浪费空间 先序遍历 遍历过程 访问根节点 先序遍历其左子树 先序遍历其右子树 看了这个图可能能更好地理解递归的过程 这个图更好，注意看箭头 中序遍历 中序遍历其左子树 访问其根节点 中序遍历其右节点 后序遍历 后序遍历其左节点 后序遍历其右节点 访问根节点 以上三种遍历过程，经过结点的路线一样，只是访问各结点的时机不同 遍历（非递归） 中序遍历（第二次碰到结点就printf） 遇到一个结点，就把它压栈，并去遍历它的左子树 当左子树遍历结束后，就从栈顶弹出这个结点并访问它 然后按其右指针再去中序遍历该节点的右子树 先序遍历（第一次碰到结点就printf） 由于走过的路径相同，只需要改变访问结点的时机就可以在中序遍历的基础上实现先序遍历 后序遍历（第三次碰到结点再printf） 层序遍历 二叉树遍历的核心问题：二维结构的线性化 问题在于当你访问完一个结点的左儿子或右儿子之后，剩下的一个儿子怎么办？如果没有存储右儿子或者自己，那么这些结点就丢失了，所以需要一种方法保存该节点或保存他的父结点 总的来说就是我们需要一个存储结构保存暂时不访问的结点 这里使用队列解决问题 先把根入队 根出队，并且让它的两个儿子入队，左儿子现右儿子后 依次让队列里的结点出队，并且让他的儿子入队 重复，直至队列空 二叉树遍历的应用 二叉树的同构 一个二叉树可以通过n次左右树交换就能变得和另一个一样，就称俩数同构 二叉搜索树（Binary Search Tree） 满足： 非空左子树的所有键值小于其根节点的键值 右子树大于根节点 左右子树都是搜索二叉树 操作集 Position Find(ElementType X,BinTree BST):查找X，返回结点的地址 Position FindMin(BinTree BST)：返回最小元素结点并返回 Position FindMax(BinTree BST)：最大 BinTree Insert(ElementType X,BinTree BST)：插入X BinTree Delete(ElementType X,BinTree BST)：删除X Find()思路： 从根节点开始，如果树为空返回NULL 非空就和X进行比较 若小于根就在左子树继续查找 大于则就在右子树里查找 相等就返回指针 递归实现 循环实现 FindMin()&amp;FindMax() 递归实现 循环实现 Insert() 关键是找到插入的位置 Delete() 有三种情况 叶结点，直接让他的父结点指向NULL 只有一个孩子，直接用它的儿子替代它‘ 有两个孩子， 平衡二叉树 查找效率高 平衡因子（Blance Factor，BF）：BF(T) = hL-hR hL,hR分别为T的左右子树的高度 平衡二叉树(Blance Binary Tree)(AVL树) 空树 任意结点左右子树高度差的绝对值不超过1 平衡二叉树的调整 给树插入结点时，有可能会破坏树的平衡，因此需要调整 平衡二叉树还是一个搜索二叉树，因此在调整过程中，依然要保持搜索二叉树的特性 堆 优先队列(Priority Queue):特殊的队列，取出元素的顺序按照元素的优先权（关键字）大小 两个特性： 结构性：用数组表示的完全二叉树 有序性：任意结点的关键字是其子树所有结点的最大值或最小值 最大堆（MaxHeap）也称大顶堆 最小堆（MinHeap）也称小顶堆 操作集 MaxHeap Create(int MaxSize) Boolean IsFull(MaxHeap H) Inser(MaxHeap H,ElementType item) Boolean IsEmpty(MaxHeap H) ElementType DeleteMax(MaxHeap H) 哨兵的一个作用就是，哨兵的值是堆中最大的，无论多大的结点来比较，到哨兵这里就会停止，可以减少一个判断条件i&gt;1，提高效率 基本思路：删除根之后，把树的最后一个节点（保证完全二叉树的特性）挪到根的位置，然后进行调整排序 建立最大堆 方法： 通过Insert操作，将元素一个一个插进去（O(NlogN)） 在线性时间复杂度下建立最大堆 将N个元素按顺序存入，先满足完全二叉树的特性 调整各节点位置，以满足有序特性 如何调整 哈夫曼树（最优二叉树）（Huffman Tree） **带权路径长度（WPL）：**设二叉树有n个叶结点，每个叶结点带有权值Wk，从根节点到每个叶结点的长度为Lk，WPL=每条路径长度乘权值的和 哈夫曼树：WPL最小 哈夫曼树的构造 思路:把所有元素按权值排列，然后拿出两个权值最小的合并成一个二叉树，然后再找两个最小的合并，直到合并完 特点： 没有度为1的结点 n个叶结点的哈夫曼树共有2n-1个结点 任意非叶结点的左右子树交换后仍是哈夫曼树 同一组权值存在不同构的两颗哈夫曼树 哈夫曼编码 为了将字符的存储空间降到最小还要避免二义性，就可以使用哈夫曼编码（编码不等长） 方法： 将每个字符出现的次数作为权值 创建一个哈夫曼树，保证每个字符都在叶结点上就不会出现二义性 集合 并查集：集合并，查某元素属于那个集合 存储实现：用树结构（并非二叉树），树的每个结点代表一个元素 用是链表实现 数组： 数组的每个分量都是一共结构，包含结点的值和父结点的下标，没有父结点则记为-1 查 并 分别找到两个集合的根节点 若不同根就设置一个集合的根节点的父结点为另一个集合的根节点 ​ 如果总是这样插的话可能会导致树越来越高，所以考虑将结点少的插到结点多的树底下 这使就需要考虑如何存储一个树的结点个数，如果在结构中再创建一个变量的话，由于只有根节点需要存储数据，会造成空间浪费，所以考虑继续使用本来的数组存储，可以使用原来标记结点为根节点的空间来存储，有x个结点就在数组中存为-x，到时候只需要判断正负就可以。 "},{"title":"队列","date":"2020-03-09T03:05:14.000Z","url":"/2020/03/09/queue/","content":"队列 只能在一段插入另一端删除 数据对象集：一个有0个或者多个元素的有穷线性表 操作集： Queue Create(int MaxSize) int IsFull(Queue Q,int Maxsize) void Add(Queue Q,ElementType item) int IsEmpty(Queue Q) ElementType Delete(Queue Q) 队列的顺序存储实现 为了使空间得到充分的使用循环队列（当数组满了之后，又从头开始） 如何实现？ 由一个一维数组和一个记录队列头元素位置的变量front和一个记录队列尾元素位置的变量rear 插入元素时rear前移一位，删除元素时front前移一位 如何判断队列是空还是满？ 用front和rear之间的距离来判断，当front和rear相差1时，队列满 为什么不是front和rear相等时未满？ 相等时由两种状态，有可能为空也有可能满。 当然这个问题可以引入一个标记来解决： 引入Size 每次Add时+1，Delete时-1，当Size为0是队列为空 引入Tag Add时Tag = 1，Delete时Tag = 0，当front和rear相等时判断Tag的值即可 这里当rear与front相差1时就判断队列满 1.Add 难点在于如何当rear到MaxSize时再+1就又返回起点 这里使用取余，当rear到达最大值时取MaxSize的余，就得到0 Delete 队列的链式存储实现 使用一个单链表实现，插入和删除分别在两头进行，**问题在于front和rear应该分别指向链表的哪一头 ** rear需要插入数据需要放在链表的尾部，插入时只需要前一个节点的地址，front要在链表的头部的的下一个节点，方法与堆栈类似 Delete Add "},{"title":"堆栈","date":"2020-03-06T02:29:13.000Z","url":"/2020/03/06/stack/","content":"堆栈 数据对象集：一个有0个或多个元素的有穷线性表 操作集： Stack CreateStack(int MaxSize) bool IsFull(Stacak S,int MaxSize) void Push(Stack S,ElementType item) bool IsEmpty(Stack S) ElementType Pop(Stack S) 堆栈的顺序存储实现 通常由一个一维数组和一个记录栈顶元素位置的变量组组成 创建 栈是否满了 3.栈是否为空 Push ++a是先自加再进行运算，a++是先运算再自加 Pop 用一个数组实现两个堆栈 思路：两个堆栈分别从数组头和尾开始，向中间，当两个顶指针相遇时，表示两个堆栈都满了 ​ -----&gt; &lt;------- ​ S.Top1 = -1 说明栈1空 ​ S.Top2 = MaxSize 说明栈2空 Push Pop 堆栈的链式存储实现 实际上是单向链表，叫链栈。插入和删除操作只能再链栈的栈顶进行，栈顶指针应该在链表的表头后其他节点之前，否则无法进行删除操作，因为前一个节点无法保存上一个节点的指针 Create 2.IsEmpty Push Pop 堆栈的应用 中缀表达式转后缀表达式 函数调用及递归实现 深度优先搜索 回溯算法 … "},{"title":"线性表","date":"2020-03-03T08:28:46.000Z","url":"/2020/03/03/linerlist/","content":"什么是线性表 线性表（Linear List）由同类型数据元素构成有序序列的线性结构 表中元素个数称为线性表的长度 线性表没有元素时，称为空表 表起始位置称为表头，结束位置称为表尾 数据对象集：n个元素构成的有序序列 操作集 L表示一个线性表，整数i表示位置，元素X属于ElementType ElementType表示一种数据类型，可以是整形也可以是实型，也可以是结构 List MakeEmpty():初始化一个空线性表 ElementType Findkth(int k,LIst L):返回位序K的元素 int Find(ElementType X,List L):查找X在L内第一次出现的位置 void insert(ElementType X,int i,List L):给L在位序i前插入一个元素X void Delete(int i,List L):删除L内位序为i的元素 int Lenth(List L):返回L的长度 线性表的顺序存储实现 访问下标为i的元素：L.Data[i]或PtrL-&gt;Data[i] 线性表的长度：L.Last+1或PtrL-&gt;Last+1 因为Last从0开始，所以长度为Last+1 &quot;-&gt;“表示取出PtrL指向的结构体中的某个数据，与”.“类似，当声明一个指针变量时想要取出该结构体中的数据就需要”-&gt;&quot;,而声明一个普通的变量是使用&quot;.&quot;即可 主要操作实现 初始化（建立空顺序表） 查找 O(n) 插入（第i（1&lt;=i&lt;=n+1）个位置上插入一个值位X的新元素） 在第i个位置插入实际上就是插在下标位i-1的位置，首先把原来的数据从i-1开始依次向后移（从后往前），然后把数据插到i-1， 删除（第i个位置） 线性表链式存储实现 在链表内插入只需要修改链，但是查找第i个元素和查看链表长度就比较复杂 求表长 查找 按序号查找 按值查找 插入（在i-1（1&lt;=i&lt;=n+1）个节点后插入一个值为X的新节点）之所以插入到i-1之后是因为，想给链表插入节点，需要知道前面一个节点的信息 删除 "},{"title":"malloc()函数的用法/动态内存分配","date":"2020-03-03T07:11:37.000Z","url":"/2020/03/03/malloc/","content":"计算机内存 计算机的内存从高位到低位分别是系统内核-栈-可自由分配的空间-堆-数据段-代码段 源代码编译后的二进制文件会加载到内存中的代码段 数据段包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。 栈存储区： 通常存放程序临时创建的局部变量（但不包括static声明的变量，static意味着在数据段中存放变量），即函数括大括号 “{ }” 中定义的变量，其中还包括函数调用时其形参，调用后的返回值等。 最后栈还具有“小内存、自动化、可能会溢出”的特点。栈顶的地址和栈的最大容量一般是系统预先规定好的，通常不会太大。由于栈中主要存放的是局部变量，而局部变量的占用的内存空间是其所在的代码段或函数段结束时由系统回收重新利用，所以栈的空间是循环利用自动管理的，一般不需要人为操作。如果某次局部变量申请的空间超过栈的剩余空间时就有可能出现 “栈的溢出”，进而导致意想不到的后果。所以一般不宜在栈中申请过大的空间，比如长度很大的数组、递归调用重复次数很多的函数等等。 堆存储区： **通常存放程序运行中动态分配的存储空间。**它的大小，并不固定，可动态扩张或缩放。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被提出（堆被缩减）。 (堆是低地址向高地址扩展的数据结构，是一块不连续的内存区域。在标准C语言上，使用malloc等内存分配函数是从堆中分配内存的 堆具有“大内存、手工分配管理、申请大小随意、可能会泄露”的特点，堆内存是操作系统划分给堆管理器来管理的，管理器向使用者（用户进程）提供API（malloc和free等）来使用堆内存。需要程序员手动分配释放，如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了（进程自身认为该内存没被使用，但是在堆内存记录中该内存仍然属于这个进程，所以当需要分配空间时又会重新去申请新的内存而不是重复利用这块内存），就是我们常说的内存泄漏，所以内存泄漏指的是堆内存被泄露了。 malloc()用法 malloc()函数的原型 功能 size应该为整型 分配一个size这么大的内存，返回一个指向这片内存空间的起始位置的一个指针，类型为void*、 若空间不足则或者其他原因没有成功申请到内存则返回NULL 如何使用 它的意思是：请求系统分配 4 字节的内存空间，并返回第一字节的地址，然后赋给指针变量 p。 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位） C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）。或者自己进行强制类型转换也可以 void*与void不同，void* 是定义一个无类型的指针变量，它可以指向任何类型的数据。任何类型的指针变量都可以直接赋给 void* 型的指针变量，无需进行强制类型转换。 注意，不能对 void 型的指针变量进行运算操作，如指针的运算、指针的移动等。原因很简单，前面讲int*型的指针变量加 1 就是移动 4 个单元，因为 int* 型的指针变量指向的是 int 型数据；但是 void* 型可以指向任何类型的数据，所以无法知道“1”所表示的是几个内存单元。* free() 用于释放使用malloc动态分配的内存 原型 参考： ​ "},{"title":"C语言中的*和&","date":"2020-03-02T07:17:28.000Z","url":"/2020/03/02/and-in-C/","content":" 结果： 10 6487620 6487620 10 为什么&amp;a和*b的值不是一样？ 变量a 本质上代表一个存储单元。CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。于是就有了二异性。 为了消除这种二义性，C语言规定a表示存储单元中的数据，&amp;a表示存储单元的地址。 a存储单元中的数据可以是一个普通数值，也可以是另一个存储单元的地址，比如：a = &amp;b; 语句就是将b的存储单元的地址存入a存储单元中。C语言规定 *a 代表a中存储的地址对应的存储单元中的数据，也就是访问*a就等于访问b，于是*a提供了通过a访问b中的数据的手段。 a表示a对应的存储单元中的数据。 &amp;a表示a对应的存储单元的地址。 *a表示：首先，要求a对应的存储单元中的数据一定是另一个存储单元的地址。 于是，*a表示另一个存储单元中的数据。 当a声明的类型是int时，a中存储的是一个整数数值，通过a可以访问（读取或修改）这个数值。 当a声明的类型是int*时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是一个整数数值；通过*a可以访问（读取或修改）这个数值。a == &amp;*a 都是该存储单元的地址。 当a声明的类型是int**时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是另外一个存储单元的地址，另外这个存储单元中存储的是一个整数数值；通过**a可以访问（读取或修改）这个数值。 最后，在C语言里地址叫指针。还有，在C语言中的数组本质上其实也是指针，即：*a 等同于 a[]。 ———————————————— 版权声明：本文为CSDN博主「kiraliam」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 原文链接："},{"title":"结构","date":"2020-02-13T07:27:39.000Z","url":"/2020/02/13/struct/","content":"结构 声明结构类型 在函数内声明的结构只可以在函数内使用 声明结构的三种形式 结构的初始化 结构成员 结构使用&quot;.&quot;来访问成员 today.year = xxxx; 结构运算 结构指针 与数组不同，结构的变量名并不是结构变量的地址，必须使用&amp; struct date *pDate = &amp;today; 结构与函数 结构作为函数参数 整个结构可以作为参数的值传入函数 实际上进行的操作是在函数内新疆一个结构变量，并复制调用者的结构的值 也可返回一个结构 typedef h表示声明一个结构，结构名为point"},{"title":"寒假C语言作业参考答案","date":"2020-02-05T06:37:44.000Z","url":"/2020/02/05/Answer-and-analysis-of-winter-vacation-C/","content":"按作业发布时间排序（顺序） 0218 1 阅读程序，写出程序所完成的功能。 计算1x1x2x3x4x5x6x7 即计算7！ 2 阅读程序，写出程序所完成的功能。 统计20个字符中字母和数字以及其他的个数 3 阅读程序，写出程序所完成的功能。 计算平均成绩和低于60分的人数 4 阅读程序，写出程序所完成的功能。 计算2的0到15次方并打印 作业20200212 1.从键盘输入一个正整数，判断是几位数？并输出其最高位的数字。 例如输入： 362 输出 3位数，最高位是3 2.猜棋子游戏。桌子上有25颗棋子。游戏双方分别是计算机和参与人。 轮流取子，每方每次最少取走一颗棋子，最多可取走3颗棋子。 双方一直轮流直到棋子取完。最终哪方所取得棋子数是偶数则胜出。 计算机取子数量由程序控制随机选取，参与人取子则键盘输入。 若由参与人先取，请编写程序完成游戏过程，显示计算机每次的取值。 计算机是否可以是“常胜将军”？ 计算机是否为常胜将军涉及到了博弈论，不会 作业20200201 题目 1.编写程序，对于给定的一个百分制整数成绩，输出相应的五等级成绩。 设：90–100为‘A’；80–89分为 ‘B’；70–79分为‘C’；60–69分为‘D’;60分以下为 ‘E’。 例如：输入 75 则输出 C 2.编写程序，用户输入星期的数字1—7，输出相应的英文表示. 例如：输入 1 则输出 Monday 3.编写程序，输入x op y，x和y是运算数据，op是运算符，然后输出该运算的结果。设定只能识别 + - * /四种运算。 例如：输入3+5 则输出 8 4.编写程序，输出分数序列：2/1，3/2，5/3，8/5，… 的前20项. 5.如果密码组成只能用a,b,c,d,e,f,g,h共8个字符，可以组成哪些4位的密码，共有多少个？编写程序进行解答。 "},{"title":"markdown基础语法","date":"2020-02-05T06:11:15.000Z","url":"/2020/02/05/markdown-Grammatical-summary/","content":"基础语法 强调 斜体可用两个*表示，将内容放入星号间即可 效果：123 加粗使用两个** 效果：123 标题 效果： 2 2 2 2 2 2 注意最后一个#与文字之间需要一个空格 引用 引用使用 &gt; 效果： 123 456 789 0 列表 有序列表 效果： 1 1 1 无序列表 效果： 1 2 1 2 1 2 *注意±不可混用 嵌套列表 1 1 2 2 3 1 分割线 三个或更多-_* 效果： 1 2"}]