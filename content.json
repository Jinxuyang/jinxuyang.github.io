{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于我","text":"","link":"/about/index.html"},{"title":"links","text":"","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"repository","text":"","link":"/repository/index.html"}],"posts":[{"title":"2020Review","text":"2020过的很快啊，忙忙碌碌倒也还算充实，写个博客记录记录这对我来说很有意义的一年 学习这一年学了很多东西，从只会一点C，到现在转投java拥抱spring全家桶，能自己写一点东西出来，很有成就感。但其他就比较拉跨了，几乎把所有时间所有精力放在了这方面，高数大物什么的都是速成的，绩点一般。 Github这一年完成了222次commit 前半年年时间都在学习，到了后半年，才开始慢慢自己写一些东西传到GitHub上，建了25个仓库其中自己写的感觉还有点用的就俩 yiban-auto-checkin https://github.com/Jinxuyang/yiban-auto-checkin 不是什么正经东西但是有用，收获了11个star，最顶峰的时候有1100+人使用，怂了关了 api-call-counter https://github.com/Jinxuyang/api-call-counter 这个现在就有基本的功能，用redis存储数据，只需要引入jar包配置redis，默认统计controller包下方法的调用次数，也可以通过给方法上打注解来统计指定方法，想把这个好好写写做的完善一点。 博客写了40篇博客，95%都是笔记没有什么深度，也就自己复习的时候可以看看 本来计划再写一篇关于Spring Security，一篇关于api-call-counter的，一拖再拖，看来得拖到明年了，属实拉跨 明年希望能写出一些有深度，有水平的博客，一周一篇，希望能坚持下去， 还有很多篇没有往博客上传，重装了一次电脑东西都搞没了hhh，也没再搞好 生活唉…也就那样，和往年一样，没去什么地方玩，也没干什么有趣的事情，也还没有女朋友 比较幸运，比较正确的事就是来铁头，东西也学了，饭也干了，认识了许多小伙伴，very good 游戏今年最让我记忆深刻的游戏非巫师3：狂猎莫属 没有可以完成成就，没有专门收集装备，开了最低难度，就看了剧情，游戏初期感觉很拖沓，感觉很无聊，许许多多奇怪的名字 搞得人….差点错过了这部游戏，47块本体加DLC绝对物超所值 游戏的配乐也极其好听，导致 总之，绝对不要错过 还有两个我特别喜欢的游戏 一个是 Factorio 很好玩，很费肝 另一个是Oxygen Not Include 同样值得尝试 憧憬 代码能力更上一层楼 写个 50+star 的项目？ 能出去走走 没有什么特别想去的地方，总之不想一直待在学校了 身体健康 找个女朋友 很惨，2020快结束的时候感冒了….浑身难受 最后，大家新年快乐！！！","link":"/2020/12/30/2020Review/"},{"title":"寒假C语言作业参考答案","text":"按作业发布时间排序（顺序） 0218 1 阅读程序，写出程序所完成的功能。 12345678&gt;#include &lt;stdio.h&gt;&gt;int main ( ){ int i, s=1; for (i=1;i&lt;=7;i++) //1到7循环7次 s=s*i; //i从1开始变化直到7 printf (&quot; %d &quot;, s); return 0;&gt;} 计算1x1x2x3x4x5x6x7 即计算7！ 2 阅读程序，写出程序所完成的功能。 123456789101112131415161718&gt;#include &lt;stdio.h&gt; &gt;int main ( ){ int digit, i, letter, other; char ch; digit = letter = other = 0; printf (&quot;Enter 20 characters: &quot;); for (i = 1; i &lt;= 20; i++) //循环20次{ ch = getchar(); //依次读取每个字符 if ((ch&gt;= 'a'&amp;&amp;ch&lt;= 'z')||(ch&gt;= 'A'&amp;&amp;ch&lt;= 'Z')) //判断是否属于大写或小写字母 letter ++; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') //是否为数字 digit ++; else other ++; } printf( &quot;%d, %d, %d\\n&quot;, letter, digit, other); return 0;&gt;} 统计20个字符中字母和数字以及其他的个数 3 阅读程序，写出程序所完成的功能。 1234567891011121314151617181920&gt;#include &lt;stdio.h&gt;&gt;int main( ){ int count, num; double grade, total; num = 0; total = 0; count = 0; printf(&quot;Enter grades: &quot;); scanf (&quot;%lf&quot;, &amp;grade); while(grade &gt;= 0){ //输入一个负数就停止输入 total = total + grade; //计算总成绩 num++; //计算人数 if (grade &lt; 60) count++; //计算小于60分的人数 scanf (&quot;%lf&quot;, &amp;grade); } if(num != 0){ printf(&quot; %.2f\\n&quot;, total / num); printf(&quot; %d\\n&quot;, count); } return 0; &gt;} 计算平均成绩和低于60分的人数 4 阅读程序，写出程序所完成的功能。 1234567891011&gt;#include &lt;stdio.h&gt;&gt;#include &lt;math.h&gt; &gt;int main ( ){ int i, n; double power; for (i = 0; i &lt;= 15 ; i++){ //从0到15 power = pow(2,i); //计算2的i次方 printf (&quot;pow(2,%d)= %.0f\\n&quot;, i,power); } return 0;&gt;} 计算2的0到15次方并打印 作业20200212 1.从键盘输入一个正整数，判断是几位数？并输出其最高位的数字。 例如输入： 362 输出 3位数，最高位是3 1234567891011121314151617181920#include&lt;stdio.h&gt;int main(){ int x,c = 0,high; scanf(&quot;%d&quot;,&amp;x); if(x == 0){//对0进行特殊化 c = 1; high = 0; } else{ while(x){//循环直至x为0时停止 if(x &lt; 10 ){//当x只剩下一位时，这一位即为最高位 high = x; } x /= 10; //去掉数字的末尾位 c++; //数字位数+1 } } printf(&quot;%d位数，最高位是%d&quot;,c,high);} 2.猜棋子游戏。桌子上有25颗棋子。游戏双方分别是计算机和参与人。 轮流取子，每方每次最少取走一颗棋子，最多可取走3颗棋子。 双方一直轮流直到棋子取完。最终哪方所取得棋子数是偶数则胜出。 计算机取子数量由程序控制随机选取，参与人取子则键盘输入。 若由参与人先取，请编写程序完成游戏过程，显示计算机每次的取值。 计算机是否可以是“常胜将军”？ 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(){ int p,r; int x = 25,pt = 0,rt = 0; while(x){ printf(&quot;请输入1-3中的一个数\\n&quot;); start: scanf(&quot;%d&quot;,&amp;p); if(p &gt;= 1 &amp;&amp; p &lt;= 3 &amp;&amp; p &lt;= x){ //确保p在1-3之间且避免出现有两个棋子拿3个的情况 x -= p; //棋子数-p pt += p; //你拥有的棋子火速+p printf(&quot;现在还剩%d个棋子,你共有%d个棋子\\n&quot;,x,pt); } else{ printf(&quot;数据超出范围,请重新输入\\n&quot;); goto start; //我觉得用goto不太好，但是没想到更好的办法 } if(x == 0) //防止出现棋子都取完了，计算机还再取一次的情况 break; do{ srand(time(NULL));// 播种 r = rand() % 3 + 1; //取一个1-3之间的随机数 }while(r &gt; x); //若这个数大于总数则重新取 rt += r; x -= r; printf(&quot;计算机取走%d个棋子,现在还剩%d个棋子,计算机共有%d个棋子\\n&quot;,r,x,rt); } printf(&quot;\\n你共取走%d个棋子，计算机共取走%d个棋子\\n&quot;,pt,rt); if(pt % 2 == 0){//判断你手上的棋子是否位偶数 printf(&quot;\\n你获胜了&quot;); } else{ printf(&quot;\\n计算机获胜&quot;); } } 计算机是否为常胜将军涉及到了博弈论，不会 作业20200201题目 1.编写程序，对于给定的一个百分制整数成绩，输出相应的五等级成绩。 设：90–100为‘A’；80–89分为 ‘B’；70–79分为‘C’；60–69分为‘D’;60分以下为 ‘E’。 例如：输入 75 则输出 C 123456789101112131415161718192021222324252627282930313233//第一题可以使用if判断成绩的范围输出相应结果，也可使用switch，这里使用swiitch//原谅我乱七八糟的变量名#include&lt;stdio.h&gt;int main(){ int x,temp; char g; //定义变量g，用于储存成绩的等级 scanf(&quot;%d&quot;,&amp;x); //输入成绩 temp = x / 10; //取成绩的十位数字 if(x &gt; 100 || x &lt;0){ //判断输入成绩是否越界 printf(&quot;error&quot;); return 0; } switch(temp){ case 10: case 9: g = 'A'; //判断成绩，并将等级赋给g break; case 8: g = 'B'; break; case 7: g = 'C'; break; case 6: g = 'D'; break; default: g = 'E'; break; }printf(&quot;%c&quot;,g); //输出等级} 2.编写程序，用户输入星期的数字1—7，输出相应的英文表示. 例如：输入 1 则输出 Monday 1234567891011121314151617181920212223// 与第一题思路相同，可以使用switch也可以使用if#include&lt;stdio.h&gt;int main(){ int x; scanf(&quot;%d&quot;,&amp;x); if(x == 1) printf(&quot;Monday&quot;); else if(x == 2) printf(&quot;Tusday&quot;); else if(x == 3) printf(&quot;Wednesday&quot;); else if(x == 4) printf(&quot;Thursday&quot;); else if(x == 5) printf(&quot;Friday&quot;); else if(x == 6) printf(&quot;Saturday&quot;); else if(x == 7) printf(&quot;Sunday&quot;); else printf(&quot;error&quot;);} 3.编写程序，输入x op y，x和y是运算数据，op是运算符，然后输出该运算的结果。设定只能识别 + - * /四种运算。 例如：输入3+5 则输出 8 123456789101112131415161718192021// 思路大概就是将输入拆分，分别对应x，op，y，xy储存两个数字，op储存运算符号，用if进行判断做出相应运算#include&lt;stdio.h&gt;int sum(int x,char op,int y){ //此函数用于判断和计算 int res; if(op == '+') res = x + y; else if(op == '-') res = x - y; else if(op == '*') res = x * y; else if(op == '/') res = x / y; return res;}int main(){ int x,y,op; scanf(&quot;%d%c%d&quot;,&amp;x,&amp;op,&amp;y);//读取数字和运算符 printf(&quot;%d&quot;,sum(x,op,y)); //输出答案}//这题还有跟简单的做法，只不过我不会 4.编写程序，输出分数序列：2/1，3/2，5/3，8/5，…… 的前20项. 1234567891011//可以看出这是一道找规律的题#include&lt;stdio.h&gt;int main(){ int i,x = 2,y = 1; for(i = 0;i &lt; 20;i++){ //for循环输出前20项 printf(&quot;%d/%d &quot;,x,y); x += y; //这两句就是规律 y++; }} 5.如果密码组成只能用a,b,c,d,e,f,g,h共8个字符，可以组成哪些4位的密码，共有多少个？编写程序进行解答。 1234567891011121314151617181920//用四重for循环，应该是对的#include&lt;stdio.h&gt;int main(){ char x[9] = {'a','b','c','d','e','f','g','h'}; //用一个数组把这几个数存起来 int a,b,c,d,num = 0; for(a = 0;a &lt; 8;a++){ //遍历数组下标 for(b = 0;b &lt; 8;b++){ for(c = 0;c &lt; 8;c++){ for(d = 0;d &lt; 8;d++){ printf(&quot;%c%c%c%c &quot;,x[a],x[b],x[c],x[d]); num++; //计数 } } } } printf(&quot;\\n共计%d种组合&quot;,num);}//应该也有更简单的方法","link":"/2020/02/05/Answer-and-analysis-of-winter-vacation-C/"},{"title":"Spring boot解决跨域问题","text":"spring boot 解决跨域问题代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.fehead.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CORSConfig { @Bean public CorsFilter corsFilter(){ //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(&quot;*&quot;); config.addAllowedHeader(&quot;*&quot;); // 允许任何头 config.addAllowedMethod(&quot;*&quot;); // 允许任何方法（post、get等） //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(&quot;OPTIONS&quot;); config.addAllowedMethod(&quot;HEAD&quot;); config.addAllowedMethod(&quot;GET&quot;); config.addAllowedMethod(&quot;PUT&quot;); config.addAllowedMethod(&quot;POST&quot;); config.addAllowedMethod(&quot;DELETE&quot;); config.addAllowedMethod(&quot;PATCH&quot;); // 4）允许的头信息 config.addAllowedHeader(&quot;*&quot;); // 5)配置有效时长 config.setMaxAge(3600*24L); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(&quot;/**&quot;, config); //3.返回新的CorsFilter. return new CorsFilter(configSource); }}","link":"/2020/09/15/CORS/"},{"title":"数据库连接池","text":"什么是数据库连接池数据库连接池就是一个存放数据库连接的容器 当系统初始化完成后，容器就被创建，容器中会申请一些连接对象，当用户来访问数据时，从容器中获取连接对象，用户访问完后，将连接对象归还给容器 实现 接口：DataSource 方法 获取连接：getConnection() 归还连接：Connection.close() 如果连接是从数据库连接池中获得的就归还给连接池，而不是关闭连接 由数据库厂商实现\\ 数据库连接池技术 C3P0 Druid C3P0使用 导入jar包 定义配置文件： c3p0.properties/c3p0-config.xml 放在src文件夹下 创建核心对象 数据库连接池对象 ComboPooledDataSource( ) Druid使用 导入jar包 配置文件 xxx.properties 可以叫任意名称，放在任意目录下 加载配置文件 Properties 数据库连接池对象 DruidDataSourceFactory 参数：字节流对象 方法：createDataSource获取一个DataSource对象 123456789101112private static DataSource dataSource; static { try { Properties pro = new Properties(); pro.load(DruidUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); dataSource = DruidDataSourceFactory.createDataSource(pro); } catch (Exception e) { e.printStackTrace(); } }","link":"/2020/06/01/DataSource/"},{"title":"ES学习笔记","text":"下载安装下载（docker）1docker pull elasticsearch 配置1234mkdir -p /mydata/elasticsearch/configmkdir -p /mydata/elasticsearch/dataecho &quot;http.host: 0.0.0.0&quot; &gt;/mydata/elasticsearch/config/elasticsearch.ymlchmod -R 777 /mydata/elasticsearch/ 启动1234567docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\-e &quot;discovery.type=single-node&quot; \\-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-d elasticsearch:7.6.2 设置开机自启1docker update elasticsearch --restart=always 概念 索引相当于数据库 类型相当于数据表(慢慢会被弃用) 文档相当于数据库的数据行 字段：文档中的kv对 词：表示文本中的一个单词 标记：表示在字段中出现的词 倒排索引IK分词器github地址：https://github.com/medcl/elasticsearch-analysis-ik 分词器版本和es版本对应 解压后放入ex的plugins目录下 ik_smart最少切分 12345GET _analyze{ &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;好好生活&quot;} 结果 123456789101112131415161718{ &quot;tokens&quot; : [ { &quot;token&quot; : &quot;好好&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 }, { &quot;token&quot; : &quot;生活&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 } ]} ik_max_word穷尽可能 12345GET _analyze{ &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;好好生活&quot;} 1234567891011121314151617181920212223242526{ &quot;tokens&quot; : [ { &quot;token&quot; : &quot;好好&quot;, &quot;start_offset&quot; : 0, &quot;end_offset&quot; : 2, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 0 }, { &quot;token&quot; : &quot;好生&quot;, &quot;start_offset&quot; : 1, &quot;end_offset&quot; : 3, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 1 }, { &quot;token&quot; : &quot;生活&quot;, &quot;start_offset&quot; : 2, &quot;end_offset&quot; : 4, &quot;type&quot; : &quot;CN_WORD&quot;, &quot;position&quot; : 2 } ]} 增加词库Rest风格api GET: 获取 POST: 更新 PUT:创建 DELETE:删除 创建索引（PUT）发送PUT请求到 http://localhost:9200/&lt;index&gt;/&lt;type&gt;/&lt;id&gt; 例： 123456PUT http://192.168.56.10:9200/movies/movie/1{ &quot;title&quot;: &quot;The Godfather&quot;, &quot;director&quot;: &quot;Francis Ford Coppola&quot;, &quot;year&quot;: 1972} 返回结果 1234567891011121314{ &quot;_index&quot;: &quot;movies&quot;, &quot;_type&quot;: &quot;movie&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 1, &quot;result&quot;: &quot;created&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;_seq_no&quot;: 0, &quot;_primary_term&quot;: 1} 更新索引使用完全相同的索引类型id，再次发送PUT请求,带上新的JSON对象 1234567PUT http://192.168.56.10:9200/movies/movie/1{ &quot;title&quot;: &quot;The Godfather&quot;, &quot;director&quot;: &quot;Francis Ford Coppola&quot;, &quot;year&quot;: 1972, &quot;genres&quot;: [&quot;Crime&quot;, &quot;Drama&quot;]} 返回结果 1234567891011121314{ &quot;_index&quot;: &quot;movies&quot;, &quot;_type&quot;: &quot;movie&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 2, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;_seq_no&quot;: 4, &quot;_primary_term&quot;: 1} _version加一 reslult为update 通过ID获取文档/索引发送GET到http://localhost:9200/movies/movie/1 返回结果 123456789101112131415161718{ &quot;_index&quot;: &quot;movies&quot;, &quot;_type&quot;: &quot;movie&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 6, &quot;_seq_no&quot;: 5, &quot;_primary_term&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: { &quot;title&quot;: &quot;The Godfather&quot;, &quot;director&quot;: &quot;Francis Ford Coppola&quot;, &quot;year&quot;: 1972, &quot;genres&quot;: [ &quot;Crime&quot;, &quot;Drama&quot; ] }} 删除文档发送DELETE到http://localhost:9200/movies/movie/1 返回结果 1234567891011121314{ &quot;_index&quot;: &quot;movies&quot;, &quot;_type&quot;: &quot;movie&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 7, &quot;result&quot;: &quot;deleted&quot;, &quot;_shards&quot;: { &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 }, &quot;_seq_no&quot;: 6, &quot;_primary_term&quot;: 1} 核心功能：搜索http://localhost:9200/_search http://localhost:9200/movies/_search - 在电影索引中搜索所有类型 http://localhost:9200/movies/movie/_search - 在电影索引中显式搜索电影类型的文档。 搜索请求正文和DSL12345{ &quot;query&quot;: { //Query DSL here }} 例 123456789101112131415GET /_search{ &quot;query&quot;: { 1 &quot;bool&quot;: { 2 &quot;must&quot;: [ { &quot;match&quot;: { &quot;title&quot;: &quot;Search&quot; }}, { &quot;match&quot;: { &quot;content&quot;: &quot;Elasticsearch&quot; }} ], &quot;filter&quot;: [ 3 { &quot;term&quot;: { &quot;status&quot;: &quot;published&quot; }}, { &quot;range&quot;: { &quot;publish_date&quot;: { &quot;gte&quot;: &quot;2015-01-01&quot; }}} ] } }} query包含查询上下文 两个match被用来给每个匹配到的文档评分 filter会过滤掉不符合条件的 复合查询符合查询包括 bool query：默认 boosting query：返回文档匹配到positive，同时减少匹配到negative的文档的分数 constant_score query: 所有匹配的文档将被给予相同分数 dis_max query function_score query Boolean query Occur 表头 must 文档中必须包含，匹配到会有加分 filter 文档中必须包含，但不会加分 should 文档中应该出现 must_not 文档中不能出现，分数将被忽略 123456789101112131415161718192021222324POST _search{ &quot;query&quot;: { &quot;bool&quot; : { &quot;must&quot; : { &quot;term&quot; : { &quot;user.id&quot; : &quot;kimchy&quot; } }, &quot;filter&quot;: { &quot;term&quot; : { &quot;tags&quot; : &quot;production&quot; } }, &quot;must_not&quot; : { &quot;range&quot; : { &quot;age&quot; : { &quot;gte&quot; : 10, &quot;lte&quot; : 20 } } }, &quot;should&quot; : [ { &quot;term&quot; : { &quot;tags&quot; : &quot;env1&quot; } }, { &quot;term&quot; : { &quot;tags&quot; : &quot;deployed&quot; } } ], &quot;minimum_should_match&quot; : 1, &quot;boost&quot; : 1.0 } }} 整合Spring Boot","link":"/2020/12/22/ElasticSearch/"},{"title":"Docker学习笔记","text":"docker 安装mysql docker pull mysql:5.7 冒号后加版本，在https://hub.docker.com/_/mysql查看 启动 123456 docker run -p 6000:3306 --name mysql-6000 \\ -v /mydata/mysql-6000/log:/var/log/mysql \\ -v /mydata/mysql6000/data:/var/lib/mysql \\ -v /mydata/mysql6000/conf:/etc/mysql \\ -e MYSQL_ROOT_PASSWORD=JINXUyang123 \\-d mysql:5.7 -p设置端口及映射端口 linux端口:docker容器端口 –name 设置容器名称 -v设置挂载 -e MYSQL_ROOT_PASSWORD=root 设置MySQL密码 docker安装redis docker pull redis 启动 123docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf","link":"/2020/12/18/Docker/"},{"title":"JDBC学习笔记","text":"JDBC是啥JDBC(Java DataBase connectivity)(Java 数据库连接) 由SUN公司定义的一系列操作关系型数据库的接口，后由数据库厂商对接口进行实现，提供数据库驱动jar包 使用导入jar包加载驱动1Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//把com.mysql.jdbc.Driver这个字节码文件加载到内存里 连接数据库host = jdbc:mysql://host /db 1Connection conn = DriverManager.getConnection(host,username,passwd); 连接时发现报错 The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方法 host后加上?serverTimezone=UTC 对象详解 DriverManage驱动管理 注册驱动 MySQL5以后可以自动注册 获取数据库连接 static getConnection(String url,String user,String password) url = jdbc:mysql://ip地址:端口号/数据库名 Connection数据库连接对象 获取执行sql语句的对象 Statement CreateStatement(String sql) Prestatement prepareStatement(String sql) 管理事务 Statement执行sql语句 执行sql int executeUpdate(String sql)：执行DML(insert,update,delete)，DDL(create,alter,drop) 返回值是操作后影响的行数 可以用来判断成功与否 ResultSet executeQuery(String sql):执行DQL(select) ResultSet查询结果的封装 boolean next()游标向下移动一行(默认指向表头)，判断是否有数据 getXxx(“列名/列的编号，从1开始”)获取数据Xxx代表类型 PreparedStatement SQL注入问题:在拼接sql‘语句时，有一些特殊的词参与拼接会造成安全问题 使用PreparedStatem对象解决问题 定义sql语句时使用?作为占位符，替换参数 使用setXxx(？的编号从1开始，参数的值) 执行sql语句时不再需要传参 Spring JDBCSpring框架提供的JDBC简单封装 提供一个JDBCTemplate 使用 导入jar包 创建JdbcTemplate，依赖于DataSource JdbcTemplate template = new JdbcTemplate 调用JdbcTemplate的方法完成CRUD操作 update()增删改 queryForMap()将查询结果封装为map集合 queryForList()将查询结果封装为list集合 query()查询结果，将查询结果封装为JavaBean对象 queryForObject()将查询结果封装为对象","link":"/2020/05/30/JDBC/"},{"title":"HTML学习笔记","text":"[TOC] html基础html文件的基本结构1234567891011&lt;!DOCTYPE HTML&gt;&lt;!--注释是这样写的--&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;这里是head,title里的内容会显示在浏览器标题栏里&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这里是body&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 标签这些都很简单body标签一般网页需要展示出来的内容就存放在body标签里 p标签段落标签 hx标签共有h1到h6六个从大到小的标签 em和strong标签em是斜体，strong是加粗 span标签span本身没有什么作用，它就是用来设置单独的样式用的 q标签短文本引用，引用后会自动给引用的部分加上引号 blockquote标签长文本引用，这个不会加引号，但是会产生缩进 br标签和&amp;nbsp;html中回车空格是无效的，换行需要&lt;br /&gt;或&lt;br&gt;(常用&lt;br /&gt;) br与其他标签不同的是，br不需要成对出现 &amp;nbsp;就代表空格 hr标签效果 写成&lt;hr&gt;或&lt;hr /&gt; address标签效果 陕西西安 code标签效果 while(1) pre标签插入大段代码 #include using namespace std; int main(){ cout < \"Hello Word\" < endl; }","link":"/2020/03/28/HTML/"},{"title":"MyBatis学习笔记","text":"[TOC] 环境搭建 创建实体类和实体类的接口 User IUserDao 配置主配置文件 SqlMapConfig.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 配置 mybatis 的环境 default属性没有固定的值 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置 mysql 的环境 这里的ID需要和environments标签中的default属性相同--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置连接数据库的信息：用的是数据源(连接池) --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://121.36.19.47:3306/mybatis_learn&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 告知 mybatis 映射配置的位置 每个Dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建映射配置文件 IUserDao.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- namespace写类的全限定类名 --&gt;&lt;mapper namespace=&quot;dao.IUserDao&quot;&gt; &lt;!-- 配置查询所有操作 ID填写方法名 resultType填写要封装成的JavaBean--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;domain.User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 注意： MyBatis的映射配置文件位置必须和Dao接口的包结构相同 映射配置文件的mapper标签的namespace属性取值必须是Dao接口的全限定类名 映射配置文件的操作配置，id属性的取值必须是dao接口的方法名 ​ 遵从这三点，在开发中就无需实现IUserDao的类，MyBatis代替我们完成 使用 读取配置文件 1InputStream in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); 创建SqlSessionFactory工厂 12SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();SqlSessionFactory factory = builder.build(in); 创建SqlSession对象 1SqlSession session = factory.openSession(); 创建Dao接口的代理对象 1IUserDao userDao = session.getMapper(IUserDao.class); 释放资源 12session.close();in.close(); 注解使用 省略映射配置文件 在要实现的接口上写 1@Select(&quot;Sql语句&quot;) 主配置文件&lt;mapper&gt;标签下使用class属性指定被注解的Dao全限定类名 123&lt;mappers&gt; &lt;mapper class=&quot;dao.IUserDao&quot; /&gt;&lt;/mappers&gt; CURD增配置文件写法1234&lt;insert id=&quot;addUser&quot; parameterType=&quot;domain.User&quot;&gt; INSERT INTO user(username,sex,address) VALUS(#{username},#{sex},#{address});&lt;/insert&gt; 注解写法 1@Insert(&quot;INSERT INTO user(username,sex,address) VALUS(#{username},#{sex},#{address})&quot;) 需要向接口中传入一个User对象 最后需要commit 1session.commit(); 获取插入数据的ID1234567&lt;insert id=&quot;addUser&quot; parameterType=&quot;domain.User&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; keyColumn=”id“ resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; SELECT last_insert_id(); &lt;/selectKey&gt; INSERT INTO user(username,sex,address) VALUS(#{username},#{sex},#{address});&lt;/insert&gt; keyProperty表示返回值的名称 order表示执行该命令的时间，AFTER表示插入之后再执行 改、删与增加操作类似只需要改变标签名称或注解的@Xxx 1234567&lt;update id=&quot;Xxx&quot; parameterType=&quot;xx.xx&quot;&gt; Sql语句&lt;/update&gt;&lt;delete id=&quot;Xxx&quot; parameterType=&quot;xx.xx&quot;&gt; Sql语句&lt;/delete&gt; 12@Update(&quot;....&quot;)@Delete(&quot;....&quot;) 查获取用户总记录的条数123&lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt; SELECT count(id) FROM user;&lt;/select&gt; OGNL表达式Object Graphic Navigation Language 连接池与事务控制MyBatis中的连接池mybatis中提供了3种方式配置 在SqlMapConfig.xml中的dataSource标签中，type属性就是配置采用何种连接池的方式 POOLED 采用传统javax.sql.DataSource规范中的连接池 UNPOOLED 虽然实现了javax.sql.DataSource，但没有使用池的思想 JNDI 事务可以在创造SqlSession对象时，给OpenSession中传一个true，就可以实现自动提交 动态SQL语句&lt;if&gt;标签123456789&lt;select id=&quot;findUser&quot; resultType=&quot;domain.User&quot; parameterType=&quot;domain.User&quot;&gt; SELECT * FROM user WHERE 1=1 &lt;if test=&quot;username != NULL&quot;&gt; AND username = #{username} &lt;/if&gt; &lt;if test=&quot;...&quot;&gt; AND ... &lt;/if&gt;&lt;/select&gt; &lt;where&gt;1234567891011&lt;select id=&quot;findUser&quot; resultType=&quot;domain.User&quot; parameterType=&quot;domain.User&quot;&gt; SELECT * FROM user &lt;where&gt; &lt;if test=&quot;username != NULL&quot;&gt; AND username = #{username} &lt;/if&gt; &lt;if test=&quot;...&quot;&gt; AND ... &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 多表查询I don’t have a favorite singer, but a film soundtrack composer whose name is hans zimmer is my favorite composer. I know him from a film called Interstellar. At the same time, Interstellar is also my favorite film. It is because of this excellent OST that there are such excellent film。 Let’s enjoy it together","link":"/2020/06/22/MyBatis/"},{"title":"MySQL学习笔记","text":"登录登出1mysql -u用户名 -p密码 -P端口号 -h服务器名称 1mysql &gt; exit;退出 修改MySQL提示符登陆时 1mysql -u用户名 -p密码 -P端口号 -h服务器名称 --prompt 提示符 登陆后 1prompt 提示符 1\\D完整日期 \\d当前数据库 \\h服务器名称 \\u当前用户 MySQL常用命令 关键字与函数名全部大写 数据库名，表名称，字段名称全部小写 MySQL语句必须以分号结尾 创建数据库1CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name","link":"/2020/05/06/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"PHP学习笔记","text":"[TOC] 一些小细节php代码需要写在&lt;?php ?&gt;之间 echo用来输出 php连接两个字符串使用.而不是+ php每条语句都以;结尾 //表示注释 PHP的新东西数组1$x = array(); PHP有两种数组：索引数组、关联数组。 索引数组索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 1$fruit = array(&quot;苹果&quot;,&quot;香蕉&quot;,&quot;菠萝&quot;); 可以使用print_r($fruit);语句输出数组键及对应的值 赋值$arr[0]='苹果'; array('0'=&gt;'苹果'); array(&quot;苹果&quot;,&quot;香蕉&quot;); 读取$arr[&quot;0&quot;];/$arr[0]; 关联数组关联数组是指数组的键是字符串的数组 12345$fruit = array( 'apple'=&gt;&quot;苹果&quot;, 'banana'=&gt;&quot;香蕉&quot;, 'pineapple'=&gt;&quot;菠萝&quot;); 可以使用print_r($fruit);语句输出数组键及对应的值。 赋值$arr['apple']='苹果'; array('apple'=&gt;'苹果'); 读取$fruit['banana']; 类与对象类是一类东西的结构描述，而对象则是一类东西的一个具体实例 定义一个类 1234567891011//定义一个类class Car { //定义属性 public $name = '汽车'; //定义方法 public function getName() { //方法内部可以使用$this伪变量调用对象的属性或者方法 return $this-&gt;name; }} 对象通过new关键字进行实例化： 1234$car = new Car();//也可以采用变量来创建$className = 'Car';$car = new $className(); 类的属性在类中定义的变量称之为属性 属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成 public：公开的protected：受保护的private：私有的 12345678class Car { //定义公共属性 public $name = '汽车'; //定义受保护的属性 protected $corlor = '白色'; //定义私有属性 private $price = '100000';} 默认都为public，外部可以访问。一般通过-&gt;对象操作符来访问对象的属性或者方法，对于静态属性则使用::双冒号进行访问。当在类成员方法内部调用的时候，可以使用$this伪变量调用当前对象的属性。 1234$car = new Car();echo $car-&gt;name; //调用对象的属性echo $car-&gt;color; //错误 受保护的属性不允许外部调用echo $car-&gt;price; //错误 私有属性不允许外部调用 受保护的属性与私有属性不允许外部调用，在类的成员方法内部是可以调用的。 123456class Car{ private $price = '1000'; public function getPrice() { return $this-&gt;price; //内部访问私有属性 }} 类的方法方法就是在类中的function 的方法也具有public，protected 以及 private 的访问控制。 1234567class Car { public function getName() { return '汽车'; }}$car = new Car();echo $car-&gt;getName(); 使用关键字static修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号:: 123456class Car { public static function getName() { return '汽车'; }}echo Car::getName(); //结果为“汽车” 构造函数和析构函数PHP5可以在类中使用**__construct()**定义一个构造函数，具有构造函数的类，会在每次对象创建的时候调用该函数 123456class Car { function __construct() { print &quot;构造函数被调用\\n&quot;; }}$car = new Car(); //实例化的时候 会自动调用构造函数__construct，这里会输出一个字符串 在子类中如果定义了__construct则不会调用父类的__construct，如果需要同时调用父类的构造函数，需要使用parent::__construct()显式的调用 PHP5支持析构函数，使用**__destruct()**进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数 1234567891011class Car { function __construct() { print &quot;构造函数被调用 \\n&quot;; } function __destruct() { print &quot;析构函数被调用 \\n&quot;; }}$car = new Car(); //实例化时会调用构造函数echo '使用后，准备销毁car对象 \\n';unset($car); //销毁时会调用析构函数 静态关键字静态属性与方法可以在不实例化类的情况下调用，直接使用类名::方法名的方式进行调用。静态属性不允许对象使用-&gt;操作符调用。 1234567class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; }}echo Car::getSpeed(); //调用静态方法 静态方法也可以通过变量来进行动态调用 123$func = 'getSpeed';$className = 'Car';echo $className::$func(); //动态调用静态方法 静态方法中，$this伪变量不允许使用。可以使用self，parent，static在内部调用静态方法与属性。 12345678910111213141516class Car { private static $speed = 10; public static function getSpeed() { return self::$speed; } public static function speedUp() { return self::$speed+=10; }}class BigCar extends Car { public static function start() { parent::speedUp(); }}BigCar::start();echo BigCar::getSpeed(); 访问控制访问控制通过关键字public，protected和private来实现。 被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的类成员则只能被其定义所在的类访问。 默认为公有 123456789101112131415class Car { private function __construct() { echo 'object create'; } private static $_object = null; public static function getInstance() { if (empty(self::$_object)) { self::$_object = new Car(); //内部方法可以调用私有方法，因此这里可以创建对象 } return self::$_object; }}//$car = new Car(); //这里不允许直接实例化对象$car = Car::getInstance(); //通过静态方法来获得一个实例 对象继承123456class Truck extends Car{ public function speedUp() { $this-&gt;speed += 50; return $this-&gt;speed; }} 使用extends 重载cookie设置cookie文件系统异常处理12345678try{ //可能出现错误或异常的代码 //catch表示捕获，Exception是php已定义好的异常类} catch(Exception $e){ //对异常处理，方法： //1、自己处理 //2、不处理，将其再次抛出} 抛出异常1234567891011121314151617//创建可抛出一个异常的函数function checkNum($number){ if($number&gt;1){ throw new Exception(&quot;异常提示-数字必须小于等于1&quot;); } return true; } //在 &quot;try&quot; 代码块中触发异常 try{ checkNum(2); //如果异常被抛出，那么下面一行代码将不会被输出 echo '如果能看到这个提示，说明你的数字小于等于1'; }catch(Exception $e){ //捕获异常 echo '捕获异常: ' .$e-&gt;getMessage(); } 异常处理类PHP具有很多异常处理类，其中Exception是所有异常处理的基类。 Exception具有几个基本属性与方法，其中包括了： message 异常消息内容code 异常代码file 抛出异常的文件名line 抛出异常在该文件的行数 其中常用的方法有： getTrace 获取异常追踪信息getTraceAsString 获取异常追踪信息的字符串getMessage 获取出错信息 捕获异常信息1234567try { throw new Exception('wrong');} catch(Exception $ex) { echo 'Error:'.$ex-&gt;getMessage().'&lt;br&gt;'; echo $ex-&gt;getTraceAsString().'&lt;br&gt;';}echo '异常处理后，继续执行其他代码'; 将错误信息写入错误日志12345678910try { throw new Exception('wrong');} catch(Exception $ex) { $msg = 'Error:'.$ex-&gt;getMessage().&quot;\\n&quot;; $msg.= $ex-&gt;getTraceAsString().&quot;\\n&quot;; $msg.= '异常行号：'.$ex-&gt;getLine().&quot;\\n&quot;; $msg.= '所在文件：'.$ex-&gt;getFile().&quot;\\n&quot;; //将异常信息记录到日志中file_put_contents('error.log', $msg);} PHP数据库123456$host = '127.0.0.1';$user = 'code1';$pass = '';mysql_connect($host,$user,$pass);//连接数据库mysql_select_db('code1');//选择数据库mysql_query(&quot;set names 'utf8'&quot;);//设置字符编码 查询在数据库建立连接以后就可以进行查询，采用mysql_query加sql语句的形式向数据库发送查询指令。 1$res = mysql_query('select * from user limit 1'); 对于查询类的语句会返回一个资源句柄（resource），可以通过该资源获取查询结果集中的数据。 12$row = mysql_fetch_array($res);var_dump($row); 插入1mysql_query(&quot;insert into user(name, age, class) values('李四', 18, '高三一班')&quot;); //执行插入语句 在mysql中，执行插入语句以后，可以得到自增的主键id,通过PHP的mysql_insert_id函数可以获取该id。 1$uid = mysql_insert_id(); 取得数据查询结果","link":"/2020/04/29/PHP/"},{"title":"Redis学习笔记","text":"Redis学习笔记NoSQL（Not only SQL） 泛指非关系型数据库 Redis数据类型String一个 key 对应一个 value，二进制安全，可以存放jpg图片或者序列化的对象 123set key valueget keykeys * // 获取所有key 1234incr key 自增1decr key 自减1INCRBY key 10 增10DECRBY key 10 减10 123GETRANGE key 0 3 获取字符串的0-3GETRANGE key 0 -1 获取整个字符串SETRANGE key 1 xxxxx 替换指定开始位置字符串 12345setex(set with expire)设置过期时间setnx(set if not exist)不存在在设置setex key 30 &quot;xxx&quot;设置字符串过期时间30ssetnx key &quot;xxx&quot;当可以不存在时设置，否则创建失败 1234mset k1 v1 k2 v2 k3 v3 一次设置多个值msetnx k1 v1 k2 v2 设置k1 k2时同时成功同时失败mget k1 k2 k3 一次获取多个值 12set user:1 {name:zhangsan,age:18} 设置一个user:1 对象，值为json字符串mset user:1:name zhangsan user:1:age 2 1getset 先get再set List所有List命令都是l开头 List中的值可以重复 1234567891011121314151617181920LPUSH list xxx 向列表头部插或多个RPUSH list xxx 向尾部插LANGELPOP list移除头RPOP list移除尾Lindex list 1 获取第一个（通过下标获取值）Llen list 返回列表长度Lrem list 1 one 移除列表中的一个oneLrem list 2 three 移除列表中的两个threetrim list 1 2修剪，只要1到2的值rpoplpush list newlist 从list pop,push到newlistlset list 0 xxx 往0处插xxxLINSERT list before &quot;xxx&quot; &quot;yyy&quot; LINSERT list after &quot;xxx&quot; &quot;yyy&quot; Setset中的值不可重复 12345678910111213141516sadd set &quot;xxx&quot;smembers set 查看所有valuesmember set xxx 判断xxx是否在set中scard set 获取set中元素个数srem set xxx 移除xxxsrandmember set 随机抽出元素srandmember set 2 随机抽出2个元素smove set newset xxx 将xxx从set移动到newsetspop随机删除一个元素sdiff set1 set2 看两个set的不同元素sinter set1 set2 看交集 sunion set1 set2 看并集 Hashkey-map key-&lt;key,map&gt; 1234567hsethmsethgethmgethdelhgetallhlen Zset 在set的基础上增加了一个值 123zsetzadd zset 1000 xxxzrangescore zset -inf +inf 排序 事务Redis单条命令保存原子性，事务不保证原子性 Redis没有隔离级别的概念 Redis事务本质一组命令的集合 ；一个事务中所有命令都会被序列化，在事务执行过程中，会按顺序执行；一次性顺序性排他性 1234multi 开启事务，下面输入的命令都会暂时放在队列里exec执行队列中的命令discard取消事务 有错误的命令（例如getset）其他所有的命令都不会执行 命令不存在语法性错误，命令执行时其他命令是我可以执行的 Redis实现乐观锁 乐观锁 认为什么时候都不会出现问题，不会上锁，更新数据时判断，在此期间是否有人修改过这个数据，数据被更改事务执行失败 悲观锁 认为什么时候都会出现问题，无论做什么都加锁 1234watch xxx 监视xxxmulti 命令exec 若xxx在事务期间改变会执行失败 Jedispom 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt; 1Jedis jedis = new Jedis(&quot;host&quot;,6379);","link":"/2020/11/11/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"正则表达式","text":"[TOC] 123var string = 'a1b2c3';string = string.replace(/[abc]/g, 'X');console.log(string); 在JavaScript中创建一个正则表达式对象 12var a = new RegExp();var b = /表达式/属性(g/i/m) 正则表达式由两种基本字符类型组成 原义文本字符 代表要查找文本的原本意思的字符 元字符 在正则表达式中有特殊含义的非字母字符 1*+?$^.|\\()[]{} 字符类 一般情况下正则表达式一个字符对应字符串一个字符 要匹配某类字符使用[]构建一个类 类指符合某些特征的对象 [abc]意思就是把abc归为一类，匹配这类字符 [^abc]就是匹配出除abc以外的字符 范围类 可以使用[a-z]表示匹配a到z的任意字符 [a-zA-Z]表示匹配a到z和A到Z的任意字符 预定义类 字符 等价类 含义 . [^\\r\\n] 除了回车、换行符之外的其他字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符(字母、数字、下划线) \\W [^a-zA-Z_0-9] 非单词字符 边界 \\b单词边界,\\B非单词边界 ^表示以…开始，$表示以…结束 量词 字符 含义 ? 0或1 次 + ≥1 次 * ≥0 次（任意次） {n} n 次 {n,m} n到m 次 {n,} ≥n 次 贪婪模式尽可能多的匹配 例如有一个字符串12345678 \\d{3,6}这样进行匹配的话结果是123456，并非123或1234或…. 非贪婪模式尽量少的匹配，一旦匹配成功就不再继续尝试 \\d{3,6}结果是123，456 JS默认使用贪婪模式，想使用非贪婪模式在量词后加上?即可 分组使用()进行分组 假如你想匹配一个小写字母加数字连续出现3次就可以这样写([a-z]\\d){3},而这样是不行的[a-z]\\d{3}这样结果是匹配一个字母加三个数字 或|表示或 假如想匹配123345和124445就可以这样写12(33|44)45 感觉功能上和[]有一点点重叠 反向引用假如你想把2020-4-24变为24/4/2020就可以这样写(\\d{4})-(\\d{2}|\\d{1})-(\\d{2}|\\d{1}) 然后使用$1$2$3捕获分组写成$3/$2/$1 忽略分组假如你不想捕获某个分组就可以 这样(\\d{4})-(\\d{2}|\\d{1})-(?:\\d{2}|\\d{1})这样就匹配不到日期了,$3就是没内容的 前瞻&amp;后顾文本头叫前文本尾部叫后 前瞻就是在正则表达式匹配带规则时，向前检查是否符合断言，后顾与之相反 JS不支持后顾 既要符合exp正则，又要满足断言要求 正向/肯定 匹配：符合特定断言负向/否定 匹配：不符合特定断言 名称 正则写法 含义 正向前瞻 exp(?=assert) 符合exp正则，且符合设置的断言 负向前瞻 exp(?!assert) 符合exp正则，且不符合设置的断言 断言部分只作为约束条件而存在，并不会参与字符本身的匹配和替换，匹配字符的是exp正则部分 假如你想匹配一个字母后加一个数字，但是只替换字母就可以 这样a1aaa3一个字符串[a-z](?=\\d) RegExp对象属性 名称 含义 global g：全文搜索，默认false ignoreCase i：大小写敏感，默认false multiline m：多行搜索，默认false lastIndex 下次匹配的起始位置 该属性只有设置标志g才能使用，实现遍历检索匹配 source 正则的文本字符串（正则主体） gim这三个对象都是只读的 RegExp对象方法test()方法1reg1.test(字符串) 返回true或false，测试字符串参数中是否存在所匹配正则的字符串 非全局调用 默认从字符串第一个字符出发，找到第一个符合条件的子字符串就停止 全局调用 如果reg1标志g的话，lastIndex就会起作用，可以通过不断调用reg1.test()对字符串进行遍历，找出所有符合条件的子字符串 每调用一次reg1.test()就会使lastIndex移动到上一次找出的字符串的最后一个字符的下一个字符上，当找不到符合条件的子字符串时，会将lastIndex重置为0 exec()方法1reg1.exec(字符串); 全局调用 返回一个数组，包含额外的属性 index 和 input，找不到返回null 12var re = /quick\\s(brown).+?(jumps)/ig;var result = re.exec('The Quick Brown Fox Jumps Over The Lazy Dog'); 属性/索引 描述 例子 [0] 匹配的全部字符串 Quick Brown Fox Jumps [1], ...[*n* ] 括号中的分组捕获 [1] = Brown[2] = Jumps index 匹配到的字符位于原始字符串的基于0的索引值 4 input 原始字符串 The Quick Brown Fox Jumps Over The Lazy Dog 非全局调用 与test()方法类似","link":"/2020/04/23/Regular-expression/"},{"title":"Servlet学习笔记","text":"[TOC] 什么是ServletServlet(Service applet)运行在服务器的小程序 Servlet就是一个接口，定义了某个Java类能被tomcat识别的规则 如何使用 新建一个类 实现servlet的接口 实现接口中的抽象类 配置servlet Servlet的执行流程 Servlet基础配置Servlet123456789&lt;servlet&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;servlet-class&gt;Servlet的地址&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;name&lt;/servlet-name&gt; &lt;url-pattern&gt;访问Servlet的地址&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 当 Servlet启动时自动装载1234&lt;servlet&gt;//加上这些代码 &lt;loadon-startup&gt;num&lt;/loadon-startup&gt;&lt;/servlet&gt; num越小优先级越高 使用注解@WebServlet(&quot;url&quot;) 就不用在web.xml里面配置了 声明周期第一次访问后，servlet创建，第二次访问时不需要创建，直接使用，当服务器关闭时，servlet销毁 Servlet结构Servlet接口下有两个实现类 HttpServlet和GenericServlet GenericServlet除了service类外，对Servlet接口的其他类都进行了空实现 以后使用Servlet时，对该类进行继承就行 HttpServlet对http协议进行了封装，简化操作 Request对象继承体系123456ServletRequest --接口继承HttpServletRequest --接口实现org.apache.catalina.connector.RequestFacade(tomcat实现) 获取数据库获取请求行 getMethod获取请求方法 getContextPath取虚拟目录 getServletPath获取Servlet路径 getQueryString获取请求参数 获取请求URI getRequestURI getRequestURL getProtocol获取协议版本 getRemoteAddr获取客户机IP地址 获取请求头 getHeader(String name)通过请求头的名称获得请求头 Enumeration&lt;String&gt; getHeaderNames()获取所有请求头的名称 获取请求体 只有POST有请求体 获取流对象 BufferReader getReader()获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()获取字节输入流，可以操作所有数据类型 从流对象中获取数据 其他（重要） 获取请求参数的通用方式（兼容GET&amp;POST） String getParameter(String name)根据参数名获取参数值 String[] getParameterValues(String name)根据参数名获取参数值的数组 – hobby=吃饭&amp;hobby=睡觉 Enumeration&lt;String&gt; getParameterNames()获取所有请求参数的名称 Map&lt;String,String[]&gt; getParameterMap()获取所有参数的map集合 请求转发 步骤 通过request对象获取请求转发器对象：RequestDispatcher get RequestDispatcher(String path) 使用RequestDispatcher对象进行转发：forward(ServletRequest request,ServletResponse response) request.getRequestDispatcher(&quot;/path&quot;).forward(request,response) 特点 浏览器地址栏不变化 只能转发到当前服务器内部资源 访问带转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj)存储数据 Object getAttribute(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext 1.","link":"/2020/05/30/Servlet/"},{"title":"Spring Cloud学习笔记","text":"[TOC] Spring Cloud 学习笔记版本选择通过访问https://start.spring.io/actuator/info 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111{ &quot;git&quot;: { &quot;branch&quot;: &quot;82af3869647d62a1e520a076908c14eee4715d8d&quot;, &quot;commit&quot;: { &quot;id&quot;: &quot;82af386&quot;, &quot;time&quot;: &quot;2020-11-02T15:56:02Z&quot; } }, &quot;build&quot;: { &quot;version&quot;: &quot;0.0.1-SNAPSHOT&quot;, &quot;artifact&quot;: &quot;start-site&quot;, &quot;versions&quot;: { &quot;spring-boot&quot;: &quot;2.3.5.RELEASE&quot;, &quot;initializr&quot;: &quot;0.10.0-SNAPSHOT&quot; }, &quot;name&quot;: &quot;start.spring.io website&quot;, &quot;time&quot;: &quot;2020-11-02T16:15:14.702Z&quot;, &quot;group&quot;: &quot;io.spring.start&quot; }, &quot;bom-ranges&quot;: { &quot;azure&quot;: { &quot;2.0.10&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE and &lt;2.1.0.RELEASE&quot;, &quot;2.1.10&quot;: &quot;Spring Boot &gt;=2.1.0.RELEASE and &lt;2.2.0.M1&quot;, &quot;2.2.4&quot;: &quot;Spring Boot &gt;=2.2.0.M1 and &lt;2.3.0.M1&quot;, &quot;2.3.5&quot;: &quot;Spring Boot &gt;=2.3.0.M1&quot; }, &quot;codecentric-spring-boot-admin&quot;: { &quot;2.0.6&quot;: &quot;Spring Boot &gt;=2.0.0.M1 and &lt;2.1.0.M1&quot;, &quot;2.1.6&quot;: &quot;Spring Boot &gt;=2.1.0.M1 and &lt;2.2.0.M1&quot;, &quot;2.2.4&quot;: &quot;Spring Boot &gt;=2.2.0.M1 and &lt;2.3.0.M1&quot;, &quot;2.3.0&quot;: &quot;Spring Boot &gt;=2.3.0.M1 and &lt;2.4.0-M1&quot; }, &quot;solace-spring-boot&quot;: { &quot;1.0.0&quot;: &quot;Spring Boot &gt;=2.2.0.RELEASE and &lt;2.3.0.M1&quot;, &quot;1.1.0&quot;: &quot;Spring Boot &gt;=2.3.0.M1&quot; }, &quot;solace-spring-cloud&quot;: { &quot;1.0.0&quot;: &quot;Spring Boot &gt;=2.2.0.RELEASE and &lt;2.3.0.M1&quot;, &quot;1.1.1&quot;: &quot;Spring Boot &gt;=2.3.0.M1&quot; }, &quot;spring-cloud&quot;: { &quot;Finchley.M2&quot;: &quot;Spring Boot &gt;=2.0.0.M3 and &lt;2.0.0.M5&quot;, &quot;Finchley.M3&quot;: &quot;Spring Boot &gt;=2.0.0.M5 and &lt;=2.0.0.M5&quot;, &quot;Finchley.M4&quot;: &quot;Spring Boot &gt;=2.0.0.M6 and &lt;=2.0.0.M6&quot;, &quot;Finchley.M5&quot;: &quot;Spring Boot &gt;=2.0.0.M7 and &lt;=2.0.0.M7&quot;, &quot;Finchley.M6&quot;: &quot;Spring Boot &gt;=2.0.0.RC1 and &lt;=2.0.0.RC1&quot;, &quot;Finchley.M7&quot;: &quot;Spring Boot &gt;=2.0.0.RC2 and &lt;=2.0.0.RC2&quot;, &quot;Finchley.M9&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE and &lt;=2.0.0.RELEASE&quot;, &quot;Finchley.RC1&quot;: &quot;Spring Boot &gt;=2.0.1.RELEASE and &lt;2.0.2.RELEASE&quot;, &quot;Finchley.RC2&quot;: &quot;Spring Boot &gt;=2.0.2.RELEASE and &lt;2.0.3.RELEASE&quot;, &quot;Finchley.SR4&quot;: &quot;Spring Boot &gt;=2.0.3.RELEASE and &lt;2.0.999.BUILD-SNAPSHOT&quot;, &quot;Finchley.BUILD-SNAPSHOT&quot;: &quot;Spring Boot &gt;=2.0.999.BUILD-SNAPSHOT and &lt;2.1.0.M3&quot;, &quot;Greenwich.M1&quot;: &quot;Spring Boot &gt;=2.1.0.M3 and &lt;2.1.0.RELEASE&quot;, &quot;Greenwich.SR6&quot;: &quot;Spring Boot &gt;=2.1.0.RELEASE and &lt;2.1.999.BUILD-SNAPSHOT&quot;, &quot;Greenwich.BUILD-SNAPSHOT&quot;: &quot;Spring Boot &gt;=2.1.999.BUILD-SNAPSHOT and &lt;2.2.0.M4&quot;, &quot;Hoxton.SR8&quot;: &quot;Spring Boot &gt;=2.2.0.M4 and &lt;2.3.6.BUILD-SNAPSHOT&quot;, &quot;Hoxton.BUILD-SNAPSHOT&quot;: &quot;Spring Boot &gt;=2.3.6.BUILD-SNAPSHOT and &lt;2.4.0.M1&quot;, &quot;2020.0.0-M3&quot;: &quot;Spring Boot &gt;=2.4.0.M1 and &lt;=2.4.0.M1&quot;, &quot;2020.0.0-M4&quot;: &quot;Spring Boot &gt;=2.4.0.M2 and &lt;=2.4.0-M3&quot;, &quot;2020.0.0-SNAPSHOT&quot;: &quot;Spring Boot &gt;=2.4.0-M4&quot; }, &quot;spring-cloud-alibaba&quot;: { &quot;2.2.1.RELEASE&quot;: &quot;Spring Boot &gt;=2.2.0.RELEASE and &lt;2.3.0.M1&quot; }, &quot;spring-cloud-services&quot;: { &quot;2.0.3.RELEASE&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE and &lt;2.1.0.RELEASE&quot;, &quot;2.1.8.RELEASE&quot;: &quot;Spring Boot &gt;=2.1.0.RELEASE and &lt;2.2.0.RELEASE&quot;, &quot;2.2.6.RELEASE&quot;: &quot;Spring Boot &gt;=2.2.0.RELEASE and &lt;2.3.0.RELEASE&quot;, &quot;2.3.0.RELEASE&quot;: &quot;Spring Boot &gt;=2.3.0.RELEASE and &lt;2.4.0-M1&quot; }, &quot;spring-statemachine&quot;: { &quot;2.0.0.M4&quot;: &quot;Spring Boot &gt;=2.0.0.RC1 and &lt;=2.0.0.RC1&quot;, &quot;2.0.0.M5&quot;: &quot;Spring Boot &gt;=2.0.0.RC2 and &lt;=2.0.0.RC2&quot;, &quot;2.0.1.RELEASE&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE&quot; }, &quot;vaadin&quot;: { &quot;10.0.17&quot;: &quot;Spring Boot &gt;=2.0.0.M1 and &lt;2.1.0.M1&quot;, &quot;14.4.2&quot;: &quot;Spring Boot &gt;=2.1.0.M1 and &lt;2.4.0-M1&quot; }, &quot;wavefront&quot;: { &quot;2.0.2&quot;: &quot;Spring Boot &gt;=2.1.0.RELEASE and &lt;2.4.0-M1&quot;, &quot;2.1.0-SNAPSHOT&quot;: &quot;Spring Boot &gt;=2.4.0-M1&quot; } }, &quot;dependency-ranges&quot;: { &quot;okta&quot;: { &quot;1.2.1&quot;: &quot;Spring Boot &gt;=2.1.2.RELEASE and &lt;2.2.0.M1&quot;, &quot;1.4.0&quot;: &quot;Spring Boot &gt;=2.2.0.M1 and &lt;2.4.0-M1&quot; }, &quot;mybatis&quot;: { &quot;2.0.1&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE and &lt;2.1.0.RELEASE&quot;, &quot;2.1.3&quot;: &quot;Spring Boot &gt;=2.1.0.RELEASE and &lt;2.4.0-M1&quot; }, &quot;geode&quot;: { &quot;1.2.10.RELEASE&quot;: &quot;Spring Boot &gt;=2.2.0.M5 and &lt;2.3.0.M1&quot;, &quot;1.3.4.RELEASE&quot;: &quot;Spring Boot &gt;=2.3.0.M1 and &lt;2.4.0-M1&quot;, &quot;1.4.0-M4&quot;: &quot;Spring Boot &gt;=2.4.0-M1&quot; }, &quot;camel&quot;: { &quot;2.22.4&quot;: &quot;Spring Boot &gt;=2.0.0.M1 and &lt;2.1.0.M1&quot;, &quot;2.25.2&quot;: &quot;Spring Boot &gt;=2.1.0.M1 and &lt;2.2.0.M1&quot;, &quot;3.3.0&quot;: &quot;Spring Boot &gt;=2.2.0.M1 and &lt;2.3.0.M1&quot;, &quot;3.5.0&quot;: &quot;Spring Boot &gt;=2.3.0.M1 and &lt;2.4.0-M1&quot; }, &quot;open-service-broker&quot;: { &quot;2.1.3.RELEASE&quot;: &quot;Spring Boot &gt;=2.0.0.RELEASE and &lt;2.1.0.M1&quot;, &quot;3.0.4.RELEASE&quot;: &quot;Spring Boot &gt;=2.1.0.M1 and &lt;2.2.0.M1&quot;, &quot;3.1.1.RELEASE&quot;: &quot;Spring Boot &gt;=2.2.0.M1 and &lt;2.4.0-M1&quot; } }} 选择Spring boot版本和Spring cloud版本 引入spring cloud alibaba1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 然后在 dependencies 中添加自己所需使用的依赖即可使用。 版本管理规范项目的版本号格式为 x.x.x 的形式，其中 x 的数值类型为数字，从 0 开始取值，且不限于 0~9 这个范围。项目处于孵化器阶段时，第一位版本号固定使用 0，即版本号为 0.x.x 的格式。 由于 Spring Boot 1 和 Spring Boot 2 在 Actuator 模块的接口和注解有很大的变更，且 spring-cloud-commons 从 1.x.x 版本升级到 2.0.0 版本也有较大的变更，因此我们采取跟 SpringBoot 版本号一致的版本: 1.5.x 版本适用于 Spring Boot 1.5.x 2.0.x 版本适用于 Spring Boot 2.0.x 2.1.x 版本适用于 Spring Boot 2.1.x 2.2.x 版本适用于 Spring Boot 2.2.x 使用nacos下载安装下载地址https://github.com/alibaba/nacos/releases windows上运行下载.zip文件，运行startup.cmd 默认端口为8848 注册配置文件 1234567spring: cloud: nacos: discovery: server-addr: localhost:8848 application: name: application name 使用OpenFeign引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 写接口123456@FeignClient(&quot;要调用的服务名&quot;)public interface CouponFeignService { @RequestMapping(&quot;路径&quot;) public R list(@RequestParam Map&lt;String, Object&gt; params);// 与被调用的方法相同} 开启远程调用功能在spring启动类中添加 1@EnableFeignClients(basePackages = &quot;接口所在包&quot;) Nacos配置中心引入依赖1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件新建bootstrap.yml 1234567spring: cloud: nacos: config: server-addr: localhost:8848 application: name: gulimall-coupon 配置中心添加应用名.后缀 动态获取配置1@RefreshScope 配置中心和本地配置冲突时，优先使用配置中心 其他命名空间：配置隔离例如： 开发环境，测试环境，生产环境 微服务 修改默认命名空间 123456spring: cloud: nacos: config: server-addr: localhost:8848 namespace: 5c990c25-30e9-4490-8e52-aaa45d8bbeb9 命名空间id 配置集配置分组网关Spring Cloud Gateway引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 出现the ‘Access-Control-Allow-Origin’ header contains multiple values 这是spring的一个问题 可以通过修改配置文件解决 12345spring: cloud: gateway: default-filters: - DedupeResponseHeader=Access-Control-Allow-Origin Access-Control-Allow-Credentials, RETAIN_UNIQUE","link":"/2020/11/09/Spring%20Cloud%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Spring学习笔记","text":"[TOC] IoC(控制反转)将对象的创建交给框架 目的：降低程序间的耦合 如何使用 Maven项目引入一下依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在项目的src文件下创建bean.xml(可以是任何名称文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 配置bean标签 123&lt;!-- bean标签：用于配置让spring创建对象，并且存入ioc容器之中 --&gt;&lt;!-- id属性：对象的唯一标识。 class属性：指定要创建对象的全限定类名 --&gt;&lt;bean id=&quot;xxx&quot; class=&quot;com.xxx.xxx.xxx&quot;&gt;&lt;/bean&gt; 创建对象 1234567public static void main(String[] args) { //1.使用ApplicationContext接口获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据bean的id获取对象 Object ObjectName = (Object) ac.getBean(&quot;bean.xml里的id&quot;); } } BeanFactory与ApplicationContext BeanFactory是顶层接口 ApplicationContext是BeanFactory的子接口 不同：对象的创建时间不同 BeanFactory 什么时候用什么时候创建 ApplicationContext默认情况下读取完配置文件之后就创建 （一般用它） ApplicationContext的实现类 ClassPathXmlApplicationContext：它是从类的根路径下加载配置文件 推荐 FileSystemXmlApplicationContext：它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext:当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。 Bean标签属性： 作用 用于配置对象让Spring创建 默认调用对象的无参构造器构造 属性 id:给对象指定唯一标识符 class：指定对象的全限定类名 scope：指定对象的作用范围 singleton :默认值，单例的. prototype :多例的. request :WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. session :WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中. global session :WEB项目中,应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session. init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 实例化Bean 使用默认无参构造函数 1&lt;bean id=&quot;Xxx&quot; class=&quot;xxx.xxx.xxx.Xxx&quot;/&gt; 使用静态工厂 12345public class StaticFactory { public static Xxx name(){ return new Xxx(); } } 12345&lt;!-- 此种方式是: 使用StaticFactory类中的静态方法name创建对象，并存入spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法 --&gt;&lt;bean id=&quot;xxx&quot; class=&quot;xxx.xxx.xxx.StaticFactory&quot; factory-method=&quot;name&quot;&gt;&lt;/bean&gt; 实例工厂 12345public class InstanceFactory { public Xxx name(){ return new Xxx(); } } 12345&lt;!-- 此种方式是： 先把工厂的创建交给spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。 --&gt;&lt;bean id=&quot;instancFactory&quot; class=&quot;xxx.xxx.xxx.InstanceFactory&quot;&gt;&lt;/bean&gt;&lt;!--工厂类--&gt; &lt;bean id=&quot;xxx&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;name&quot;&gt;&lt;/bean&gt; &lt;!--工厂中的方法--&gt; 依赖注入理解控制反转和依赖注入：https://zhuanlan.zhihu.com/p/33492169 构造函数注入使用类中的构造函数，给成员变量赋值 1234567891011121314151617&lt;!-- constructor-arg : 属性： index:指定参数在构造函数参数列表的索引位置，从0开始 type:指定参数在构造函数中的数据类型 name:指定参数在构造函数中的名称 value:它能赋的值是基本数据类型和String类型 ref:它能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean--&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; set方法注入123456789101112&lt;!-- 通过配置文件给bean中的属性传值：使用set方法的方式 (常用)property 属性： name：找的是类中set方法后面的部分 ref：给属性赋值是其他bean类型的 value：给属性赋值是基本数据类型和string类型的 --&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 注入集合属性12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;&lt;!-- 给数组注入数据 --&gt;&lt;property name=&quot;myStrs&quot;&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!-- 注入 list 集合数据 --&gt;&lt;property name=&quot;myList&quot;&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt;&lt;/property&gt;&lt;!-- 注入 set 集合数据 --&gt;&lt;property name=&quot;mySet&quot;&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- 注入 Map 数据 --&gt;&lt;property name=&quot;myMap&quot;&gt; &lt;props&gt; &lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;!-- 注入 properties 数据 --&gt;&lt;property name=&quot;myProps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;testB&quot;&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;/bean&gt; AOP注解创建对象@Component ​ 用于把当前类对象存入Spring容器种，相当于配置文件里的&lt;bean&gt;&lt;/bean&gt; 这个注解有一个属性value用于指定bean的id，默认值为当前类名，首字母小写 @Controller @Service @Repository 这三个注解的作用和属性与@Component相同，只是提供了更加明确的语义化 注入数据相当于&lt;property name=”” ref=””&gt; @AutoWired 自动按照类型注入 使用注解注入属性时， set 方法可以省略 当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找 @Qualifier 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。 给字段注入时不能独立使用，必须和@Autowire 一起使用;给方法参数注入时，可以独立使用。 属性：value，bean 的id @Resource 直接按照 Bean 的 id 注入 属性：value，bean 的id @Value 注入基本数据类型和 String 类型数据的 value：用于指定值","link":"/2020/05/30/Spring/"},{"title":"XML学习笔记","text":"什么是XMLXML(Extensible Markup Language)可扩展标记语言 可扩展：标签都是可以自定义的 语法严格 啥用 存储数据 配置文件 在网络中传输 基本语法123456789101112&lt;? version = '1.0' ?&gt;&lt;users&gt; &lt;user id = '1'&gt; &lt;name&gt;1&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/user&gt; &lt;user id = '2'&gt; &lt;name&gt;1&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/user&gt;&lt;/users&gt; 第一行必须为版本声明（必须是第一行，第一行是空行都不行） 有且只能有一个根标签(&lt;users&gt;&lt;/users&gt;) 属性值必须用 引号引起来（单双都行） 标签都是成对出现（除首行） 标签名称区分大小写","link":"/2020/05/31/XML/"},{"title":"算法学习笔记","text":"[TOC] 枚举 一一列举 不重复，不遗漏 优化枚举的基本思路减少枚举次数 选择合适的枚举对象 选择合适的枚举方向 ——方便排除非法和不是最优的情况 选择合适的数据维护方法 ——转化问题 例1.最大正方形题目 在一个N*N（N&lt;100）的矩阵中求一个最大的正方形使得该正方形的四个顶点是由“#”构成 ##**# ***** **##* #*#*#* *#*#* 思路 几个点可以确定一个正方形？ 对角线上的两个点确定一个正方形 明确思路使用枚举法，枚举所有两个点的组合，判断剩下两个点是否是#，是的话记录面积不是就继续枚举下一个组合，直至枚举完所有集合 前缀和对于一个数列，再开一个数组，第n个数就存前n个数字的和 例2 数列求和问题给定一个数列{an}（1&lt;= n &lt;= 100000）,有q（1&lt;= n &lt;= 100000）次询问，每次询问从i到j的元素之和 思路 暴力，直接算（范围大的话必超时） 先便利数据，求前缀和，存到数组中 使用时直接求aj-ai即可 差分例3 数列修改问题给定一个数列{an}（1&lt;= n &lt;= 100000）,有q（1&lt;= n &lt;= 100000）次修改，每次修改把从i到j的每个元素加上k，求所有修改之后的每个数值 思路 暴力，每次修改都遍历区间（时间复杂度太大） 思考问题，进行修改时区间什么没有变，什么变了 区间内各个元素之间的差值未变 端点处的差值改变 把修改的地方从整个区间变到区间的端点，就可以大大减少时间复杂度 当我们对第i到j个数加上k的话，i与i-1的差值增加了k，j与j加一的差值减少了k，区间内部相邻两数差值不变 因此可以使用一个数组来维护第i个数和第i-1个数的差值（默认第一个数的前一个数是0），将[i,j]这个区间的每个数+1时，只需要修改i和j+1（i+k，j+1-k） 对这个数组求前缀和，即可得到数列的值 这种方法叫差分 差分与前缀和的关系差分和前缀和是一对对称的操作 差分数组求前缀和就是原数组，对前缀和求差分也能得到原数组 尺取法给定长度为n的正整数数列以及整数S，求出总和不小于S的连续子串的长度的最小值，如果接不存在，输出0 暴力，枚举两个点的所有组合，选择和大于等于S的最短子串（时间复杂度爆炸）（O（n3）） 优化，使用前缀和省去计算和的那一步复杂度变为（O（n2）），依然不低 使用尺取法（O（n）） 确定两个端点，从数组0开始 首先向右移动右边的端点，判断和是否大于S，若大于S就移动左边的端点，一直移动直至再移动一次就不大于S时，记录长度 继续移动右端点，重复2，直至数组结束 得出最小距离 贪心 对问题求解时，总是做出在当前看来最好的选择，不从整体上考虑，做出的选择是局部是上最优解 使用贪心算法解决的问题都是能够证贪心出的局部最优解是所求的全局最优解 STL算法类 **sort(beg,end,comp)**给数组排序，返回排号的数组,cmp可以不写，comp用来定义比较方法 int a[10]= {1, 5, 8, 9, 6, 7, 3, 4, 2, 0}; sort(a, a+10); //两个参数，第一个是你要排的的开始位置的指针，第二个是结束处的指针的下一位 //可以理解为从a开始，要排几位 //STL遵循[a,b)原则，因此是a到a+10 search **binary_search(起始地址，结束地址，要查找的值)**，返回布尔值，匹配返回true **lower_bound(beg,end,val)**返回可插入的最小位置的迭代器（可以理解为指针） 例插入3 1 2 2 2 (可以被插到这) 3 3 3 4 5 返回加粗3处的指针 第一个大于等于你查询的数的位置 **upper_bound(beg,end,val)**返回可插入的最大位置的迭代器（可以理解为指针） 1 2 2 2 3 3 3 (可以被插到这) 4 5 返回加粗4处的指针 第一个大于你查询的数的位置 使用前数组一定要排序 **find(beg,end,val)**返回val第一次出现的地址 count(beg,end,val)**返回val的出现次数 返回一个ptrdiff_t**(typedef long long ptrdiff_t)我也不知道这是个啥 **swap(a,b)**交换两个数 二分、三分二分查找","link":"/2020/07/21/algorithm/"},{"title":"C语言中的*和&amp;","text":"1234567int a = 10;int *b = &amp;a；printf(“%d\\n”, a);printf(“%d\\n”, &amp;a);printf(“%d\\n”, b);printf(“%d\\n”, *b); 结果：106487620648762010 *为什么&amp;a和b的值不是一样？** 变量a 本质上代表一个存储单元。CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。于是就有了二异性。 为了消除这种二义性，C语言规定a表示存储单元中的数据，&amp;a表示存储单元的地址。a存储单元中的数据可以是一个普通数值，也可以是另一个存储单元的地址，比如：a = &b; 语句就是将b的存储单元的地址存入a存储单元中。C语言规定 *a 代表a中存储的地址对应的存储单元中的数据，也就是访问*a就等于访问b，于是*a提供了通过a访问b中的数据的手段。 a表示a对应的存储单元中的数据。&amp;a表示a对应的存储单元的地址。 *a表示：首先，要求a对应的存储单元中的数据一定是另一个存储单元的地址。于是，*a表示另一个存储单元中的数据。当a声明的类型是int时，a中存储的是一个整数数值，通过a可以访问（读取或修改）这个数值。当a声明的类型是int*时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是一个整数数值；通过*a可以访问（读取或修改）这个数值。a == &amp;*a 都是该存储单元的地址。当a声明的类型是int**时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是另外一个存储单元的地址，另外这个存储单元中存储的是一个整数数值；通过**a可以访问（读取或修改）这个数值。最后，在C语言里地址叫指针。还有，在C语言中的数组本质上其实也是指针，即：*a 等同于 a[]。————————————————版权声明：本文为CSDN博主「kiraliam」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_27445903/article/details/82563059","link":"/2020/03/02/and-in-C/"},{"title":"cookie&amp;session","text":"会话什么是会话一次会话中包含多次请求和响应 一次会话：浏览器第一次给服务器发送请求，会话建立，指导一方断开为止 有什么用在一次会话范围内的多次请求共享数据 怎么实现 客户端会话技术（数据存放在客户端）：Cookie 服务端会话技术（数据存放在服务端）：Session Cookie如何使用 创建Cookie对象】 new Cookie(String name,String value) 发送Ciookie对象 response.addCookie(Cookie cookie) 获取Cookie Cookie[] request.getCookies() 原理 基于请求头Cookie和响应头Set-Cookie实现 细节 一次可以发送多个Cookie（创建多个Cookie对象，多次调用AddCookie） Cookie可以保存多长时间 默认情况下，浏览器关闭后Cookie销毁 持久化存储 setMaxAge(int seconds) 正数，将Cookie数据写道硬盘中，设置Cookie存货时间，单位s 负数，默认值，结束会话删除 0，删除Cookie信息 Cookie的获取范围 特点和作用 cookie储存在客户端 浏览器对于单个Cookie大小有限制4kb，对一个域名下总cookie数量有限制20个 Session 使用 获取HttpSession对象(域对象) request.getSession() 方法 Object getAttribute(String name) void setAttribute(String name,Object value) void removeAttribute(String name) 原理Session的实现依赖于Cookie 首次使用时服务器向浏览器发送一个Cookie包含一个JSESSIONID，再次访问时，浏览器向服务器发送JSESSIONID，服务器通过这个ID，确保两次访问使用的是同一个HttpSeesion对象 细节 客户端关闭服务器不关闭，两次访问不是同一个Session 若需要相同可以设置Cookie的存活时间 服务器关闭客户端不关闭，两次访问不是同一个Session session钝化： session活化 Session失效时间 服务器关闭 调用一个自杀方法 默认失效时间30min 特点 存储一次会话的数据，存在服务端 可以存储任意类型数据，任意大小 比Cookie安全","link":"/2020/06/01/cookie-session/"},{"title":"图（Graph）","text":"[TOC] 图（Graph） 表示多对多的关系 包含 一组顶点:通常用V（Vertex）表示顶点集合 一组边：通常用E（Edge）表示边的集合 边是顶点对：（v,w）属于E，v,w属于V 有向边&lt;v,w&gt;表示从v指向w的边（单行线） 不考虑重边和自回路 抽象数据类型定义 类型名称：图（Graph） 操作对象集：G（V，E）由一个非空的有限顶点集合V和一个有限边集合E组成 操作集 Graph Create() Graph InsertVertex(Graph G,Vertex V) Graph InsertEdge(Graph G,Edge e) void DFS(Graph G,Vertex v) void BFS(Graph G,Vertex v) void ShortestPath(Graph G,Vertex v,int Dist[]) void MST(Graph G)最小生成树 如何表示一个图 邻接矩阵 有边记为1 优缺点 直观简单，方便查找任意一对顶点之间是否有边，方便查找任一顶点的所有邻接点（有边直接相连的顶点） 方便计算任意顶点的度 无向图：对应行或列非零元素个数 有向图：非零行是出度，非零列的入度 若是稀疏矩阵的话会造成空间浪费以及时间浪费 12345678typedef struct GNode *PtrToGNode;struct GNode{ int Nv;//定点数 int Ne;//边数 WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum]; //顶点包含的数据}typedef PtrToGNode MGraph; MGraph创建并初始化 123456789101112131415typedef int Vertex;MGraph CreateGraph(int VertexNum){ Vertex V,W; MGraph Graph; Graph = (MGraph)mallcon(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; //把Graph全部置为0 for(V = 0;V &lt; Graph-&gt;Nv;V++){ for(W = 0;W &lt; Graph-&gt;Nv;W++){ Graph-&gt;G[V][W] = 0; } }} 向MGraph插入边 1234567891011typedef struct ENode *PtrToENode;struct ENode{ Vertex V1,V2; WeightType Weight;};typedef PtrToENode Edge;void InsertEdge(MGraph Graph,Edge E){ Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; //若为无向图，则还要插入边（V2，V1） Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;} 建立完整的MGraph 1234567891011121314151617181920212223MGraph BuildGraph(){ MGraph Grpah; Edge E; Vertex V; int Nv,i; scanf(&quot;%d&quot;,&amp;Nv); Graph = CreateGraph(Nv); scnaf(&quot;%d&quot;,&amp;(Graph-&gt;Ne)); if(Graph-&gt;Ne != 0){ E = (Edge)malloc(sizeof(struct ENode)); for(i = 0;i &lt; Graph-&gt;Ne;i++){ scanf(&quot;%d %d %d&quot;,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight); InsertEdge(Graph,E); } //读入数据 for(V = 0;V &lt; Graph-&gt;Nv;V++){ scanf(&quot;%c&quot;,&amp;(Graph-&gt;Data[V])); } return Graph; }} 这个矩阵存的是顶点与顶点间的关系 邻接表 用一个指针数组，对应矩阵每行一个元素，只存非零元素 优缺点 对于稀疏矩阵在时间和空间上的表现都比较好 方便找任意顶点的邻接点 方便计算任一顶点的度 无向图：是 有向图：否，只能计算出度，需要构造逆邻接表 难以检查任意一对顶点间是否存在边 用一个长为N(N+1)/2的一维数组表示 Gij在这个数组中对应的下标为(i*(i+1)/2+j) 12345678910111213typedef struct Vnode(){ PtrToAdjVNode FirstEdge; DataType Data;}AdjList[MaxVertexNum];typedef struct GNode *PtrToGNode;struct GNode{ int Nv; int Ne; AdjList G;};typedef PtrToGNode LGraph; 图的遍历深度优先搜索(Depth First Search,DFS)思路:从起点出发，挑视线内一盏灯点亮，然后走到刚刚点亮的等上，继续重复，如果视线内所有灯都被点亮，就原路返回，退后一格，然后继续看，直到退到起点 123456void DFS(Vertex V){ visited[V] = ture; for(V的每个邻接点W){ if(!visited[W]) DFS(W); }} 广度优先搜素(Breath First Search,BFS)与树的层序遍历类似 思路：从起点开始，把所有邻接点压入队列，然后弹出一个，再把这的结点的所有邻接点压入队列，重复直至队列空 12345678910111213void BFS(Vertex V){ visited[V] = true; Enqueue(V,Q); while(!IsEmpty(Q)){ V = Dequeue(Q); for(V的每个邻接点W){ if(!visited[W]){ visited[W] = true; Enqueue(W,Q); } } }} 最短路问题分类： 单源最短路径问题：从某固定点出发，求其到所有其他顶点的最短路径 有向无权图 有向有权图 多源最短路问题：求任意两顶点间的最短路径 单源有向无权图的最短路无权图的最短路可以认为是，从起点到终点经过的顶点数最少的路 与BFS有点类似 123456789101112void Unweighted(Vertex S){ Enqueue(S,Q);//先把这个结点入队 while(!IsEmpty(Q)){ V = Dequeue(Q);//弹出一个元素 for(V 的每个邻接点 W)//遍历V的每个邻接点 if(dist[W] == -1){//如果W没有被访问过就执行以下操作 dist[W] = dist[V]+1;//S到W的距离变成，S到他前一个结点V的距离+1 path[W] = V;//要到达W就要经过V，把v存起来 Enqueue(W,Q);//把这个结点入队 } }} 因为每次找的都是这个结点的邻接点，因此最后出来的结果是最短的 path存储来这个结点的结点，只要一直网下推，就能推出整条最短路 单源有向有权图**权重和最小 ** Dijkatra算法 令s = {源点s + 已经确定了从s到的最短路径的顶点v} 对于任何一个没有收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点，即{s -&gt; (v属于s) -&gt; v}的最小长度(这个最小长度不是最终的最小长度) 前提条件：路径是按照递增的顺序生成的 真正的最短路必须只经过s中的顶点，因为，假设一个顶点不在s中，但从源点到v经过他，这时就产生了矛盾，因为路径书按照递增顺序生成的 每次从未收录的顶点中选一个dist最小的收录 增加一个v进入s，可能会影响另外一个w的dist值 要产生这样的结果要满足 v在s到w的路径上 v到w一定有一条直接的边，因为路径按照递增顺序生成 12345678910111213void Dijkstra(Vertex s){ while(1){ V = 为收录顶点中dist最小者; if(这样的V不存在) break; collected[V] = true;//用来标记结点是否被收录 for(V 的每个邻接点 W) if(collected[W] == false) if(dist[V] + E(v到w的距离) &lt; dist[W]){//如果原来s到w的距离大于，s到v加上v到w的距离那么就改变s到w的最短路径 dist[W] = dist[V]+E(V到W的距离); path[W] = V; } }}","link":"/2020/04/26/graph/"},{"title":"jQuery学习笔记","text":"[TOC] 环境搭建123456789101112&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://www.imooc.com/static/lib/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;title&gt;环境搭建&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert($) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 想要使用jQuery只需要在&lt;head&gt;标签中 1&lt;script type=&quot;text/javascript&quot; src=&quot;https://www.imooc.com/static/lib/jquery/1.9.1/jquery.js&quot;&gt;&lt;/script&gt; 注意：一定千万不要在引用jquery的script标签里再写js了，重新写一个script标签 可以在这里https://jquery.com/download/下载使用jQuery的其他版本 网速慢的话 https://www.bootcdn.cn/jquery/ 这样操作 选择器id选择器1$( &quot;#id&quot; ) id若多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素，按理来说id需要唯一 类选择器1$(&quot;.class&quot;) 假如你想改变某一类标签内容的样式可以直接使用$(.class).css(),不再像原生js一样需要循环 标签选择器1$(&quot;tag&quot;) 全能选择器1$(&quot;*&quot;) 获取文档中的所有元素 层级选择器文档中的所有的节点之间都是有这样或者那样的关系。我们可以把节点之间的关系可以用传统的家族关系来描述，可以把文档树当作一个家谱，那么节点与节点直接就会存在父子，兄弟，祖孙的关系了。 基本筛选选择器 假如你使用标签选择器选取了所有div标签，但是你只想要第一个就可以这样 123$(&quot;div:first&quot;)//选择第一个$(&quot;div:eq(0)&quot;)//选择索引值为0的那个$(&quot;div:lt(1)&quot;)//选择索引值小于1的 内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。 :parent与:empty是相反的，两者所涉及的子元素，包括文本节点 可见性筛选选择器 我们有几种方式可以隐藏一个元素： CSS display的值是none。 type=”hidden”的表单元素。 宽度和高度都显式设置为0。 一个祖先元素是隐藏的，该元素是不会在页面上显示 CSS visibility的值是hidden CSS opacity的值是0 属性筛选选择器 用法 1$(&quot;一个元素集合[属性 | 属性 运算符 &quot;value&quot;]&quot;) 子元素筛选选择器 :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) :last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素 如果子元素只有一个的话，:first-child与:last-child是同一个 :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配 jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的 nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算 表单元素选择器 表单对象属性筛选选择器 特殊选择器this this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值 属性与样式attr()与.removeAttr()用来获取和设置元素属性 attr()有4个表达式 attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … } removeAttr()删除方法 .removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute） 1234&lt;a id=&quot;10086&quot;&gt;移动&lt;/a&gt;$(&quot;#10086&quot;).attr(id,10001);$(&quot;#10001&quot;).attr(id); .html()及.text().html() 获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数 .text() 得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数 .html处理的是元素内容，.text处理的是文本内容 .val().val()方法 主要是用于处理表单元素的值，比如 input, select 和 textarea。 .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function ) ，一个用来返回设置值的函数 .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .addClass()和removeClass()addClass( className )方法 .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名 注意事项： 1.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上 .removeClass( )方法 .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名 注意事项 如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除 .toggleClass()一次执行相当于addClass，再次执行相当于removeClass .toggleClass( )方法：在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类 .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数 注意事项： toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加 .css()获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 1.css(&quot;background-color&quot;) .css( propertyNames )：传递一组数组，返回一个对象结果 1.css(['width','height']) 设置： .css(propertyName, value )：设置CSS 1.css(&quot;background-color&quot;,&quot;red&quot;) .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 123456.css(&quot;width&quot;,function(index,value){ //value带单位，先分解 value = value.split('px'); //返回一个新的值，在原有的值上，增加50px return (Number(value[0]) + 50) + value[1]; }) .css( properties )：可以传一个对象，同时设置多个样式 12345css({ 'font-size' :&quot;15px&quot;, &quot;background-color&quot; :&quot;#40E0D0&quot;, &quot;border&quot; :&quot;1px solid red&quot; }) 结点创建与属性创建1$(&quot;&lt;div class='right'&gt;&lt;div class='aaron'&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;) 插入 .append(), 内容在方法的后面，参数是将要插入的内容。 .appendTo()刚好相反，内容在方法前面，无论是一个选择器表达式 或创建作为标记上的标记它都将被插入到目标容器的末尾 12append()前面是被插入的对象，后面是要在对象内插入的元素内容appendTo()前面是要插入的元素内容，而后面是被插入的对象 作用是一样的","link":"/2020/04/27/jQuery/"},{"title":"线性表","text":"什么是线性表线性表（Linear List）由同类型数据元素构成有序序列的线性结构 表中元素个数称为线性表的长度 线性表没有元素时，称为空表 表起始位置称为表头，结束位置称为表尾 数据对象集：n个元素构成的有序序列 操作集L表示一个线性表，整数i表示位置，元素X属于ElementType ElementType表示一种数据类型，可以是整形也可以是实型，也可以是结构 List MakeEmpty():初始化一个空线性表 ElementType Findkth(int k,LIst L):返回位序K的元素 int Find(ElementType X,List L):查找X在L内第一次出现的位置 void insert(ElementType X,int i,List L):给L在位序i前插入一个元素X void Delete(int i,List L):删除L内位序为i的元素 int Lenth(List L):返回L的长度 线性表的顺序存储实现1234567typedef struct LNode *List//List存放该结构的地址struct LNode{//定义一个名为LNode的结构 ElementType Data[MAXSIZE]; int Last;//线性表最后一位的位序}；struct LNode L; //声明一个结构体List PtrL; //声明该结构体的指针 访问 下标为i的元素：L.Data[i]或PtrL-&gt;Data[i] 线性表的长度：L.Last+1或PtrL-&gt;Last+1 因为Last从0开始，所以长度为Last+1 “-&gt;”表示取出PtrL指向的结构体中的某个数据，与”.”类似，当声明一个指针变量时想要取出该结构体中的数据就需要”-&gt;”,而声明一个普通的变量是使用”.”即可 主要操作实现 初始化（建立空顺序表） 123456List MakeEmpty(){ List Ptrl; //声明该结构体的指针 PtrL = (List)malloc(sizeof (struct LNode)); Ptrl-&gt;Last = -1;//当表内没有数据时Last为-1 return Ptrl;} 查找 O(n) 12345678910int Find(ElementType X,List PtrL){ int i = 9; while(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= x){//循环结束有两个原因一个是i&gt;last说明，找完了还没有，另一个是Data[i] = X说明找到了 i++; } if(i &gt; PtrL-&gt;Last) return -1; else return i;} 插入（第i（1&lt;=i&lt;=n+1）个位置上插入一个值位X的新元素） 在第i个位置插入实际上就是插在下标位i-1的位置，首先把原来的数据从i-1开始依次向后移（从后往前），然后把数据插到i-1， 12345678910111213141516void Insert(ElementType X,int i,List PtrL){ int j; if(PtrL-&gt;Last == MAXSIZE-1){ //判断表的最后一位是否已经到达MAXSIZE，-1是因为表的下标从0开始 printf(&quot;表满&quot;); return; } if(i &lt; 1 || i &gt; PtrL-&gt;Last+2){ //或者可以写成（i-1 &lt; 0 || i-1 &gt; PtrL-&gt;Last+1）+1确保还有剩余位置 printf(&quot;位置不合法&quot;); return; } for(j = PtrL-&gt;Last;j &gt;= i-1;j++){ //从最后一位开始，循环到i-1这个位置（O(n)） Ptrl-&gt;Data[j+1] = Ptrl-&gt;Data[j];//每个数据往后移动一位 } PtrL-&gt;Data[i-1] = X;//令原本下标为i-1的位置为X PtrL-&gt;Last++;//表长+1} 删除（第i个位置） 123456789101112void Delete(int i,List PtrL){ int j; if(i &lt; 1 || PtrL-&gt;Last+1){ //此处为删除因此不需要保存余量，只需小于Last+1即可 printf(&quot;不存在&quot;); return; } for(j = i;j &lt;= PtrL-&gt;Last;j++){//从i+1开始到结束的值都向前移动一位 PtrL-&gt;Data[j-1] = PtrL-&gt;Data[j]; } PtrL-&gt;Last--; return;} 线性表链式存储实现在链表内插入只需要修改链，但是查找第i个元素和查看链表长度就比较复杂 1234567typedef struct LNode *List;struct LNode{ ElementType Data;//存储数据 List Next;//下一个链表的头。};Struct LNode L;List PrtL; 求表长 123456789int Length(List PtrL){ List p = PtrL; //p指向表的第一个节点 int j = 0; while(p){//若返回NULL即到最后一位，则循停止 p = p-&gt;Next; //指向下一个节点 j++;//计数 } return j;} 查找 按序号查找 123456789101112List FindKth(int K,List PtrL){ List p = PtrL; int i = 1; //表头为一 while(p != NULL &amp;&amp; i &lt; K){//第一个条件是表不能到结尾，第二个是刚好遍历到K就停止 p = p-&gt;Next;//转到下一节点 i++;//计数 } if(i == K) //等于说明找到了 return p;//返回该节点的指针 else return NULL;} 按值查找 12345678910List Find(ElementType X,List PtrL){ List p = Prtl; while(X != P-&gt;Data &amp;&amp; p != NULL){ p = p-&gt;Next } if(p-&gt;Data == X) return p; else return NULL;} 插入（在i-1（1&lt;=i&lt;=n+1）个节点后插入一个值为X的新节点）之所以插入到i-1之后是因为，想给链表插入节点，需要知道前面一个节点的信息 123456789101112131415161718192021List insert(ElementType X,int i,List PtrL){//List PtrL 传入的是表头的指针 List p,s; if(i == 1){//1在表头位置需要特殊处理 s = (List)malloc(sizeof(struct LNode));//申请一块空间 s-&gt;Data = X; s-&gt;Next = PtrL;//将这下个节点的Next赋给此节点的Next return s;//返回表头 } p = FindKth(i-1,PtrL); if(p == NULL){ printf(&quot;error&quot;); return NULL; } else{ s = (List)malloc(sizeof(struct LNode)); s-&gt;Data = X; s-&gt;Next = p-&gt;Next;//把i-1的链接给要插入的节点 p-&gt;Next = s;//把要插入的节点的链接给i-1 return PtrL; }} 删除 12345678910111213141516171819202122232425List Delete(int i,List PtrL){ List p,s; if(i == 1){//1特殊化 s = PtrL; if(PtrL!=NULL) //查看这个表是否无节点 PtrL = PtrL-&gt;Next; //是表头变为下一个节点 else return NULL; free(s); //释放被删除的节点 return PtrL; } p = FindKth(i-1,List PtrL); //查找第i-1个节点 if(p == NULL){ //判断输入的i是否在范围内 printf(&quot;第%d个节点不存在&quot;，i-1); } else if(p-&gt;Next == NULL){ //判断输入的节点是否是表的结尾 printf(&quot;第%d个节点不存在&quot;，i); } else{ s = p-&gt;Next; p-&gt;Next = s-&gt;Next; free(s); return PtrL; }}","link":"/2020/03/03/linerlist/"},{"title":"Linxu命令","text":"防火墙 开发80端口 firewall-cmd --zone=public --add-port=80/tcp --permanent 查询端口号80 是否开启firewall-cmd --query-port=80/tcp 重启防火墙 firewall-cmd --reload 查询有哪些端口是开启的firewall-cmd --list-port 参数说明--zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效","link":"/2020/09/14/linxu-command/"},{"title":"malloc()函数的用法&#x2F;动态内存分配","text":"计算机内存计算机的内存从高位到低位分别是系统内核-栈-可自由分配的空间-堆-数据段-代码段 源代码编译后的二进制文件会加载到内存中的代码段 数据段包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。 栈存储区： 通常存放程序临时创建的局部变量（但不包括static声明的变量，static意味着在数据段中存放变量），即函数括大括号 “{ }” 中定义的变量，其中还包括函数调用时其形参，调用后的返回值等。 最后栈还具有“小内存、自动化、可能会溢出”的特点。栈顶的地址和栈的最大容量一般是系统预先规定好的，通常不会太大。由于栈中主要存放的是局部变量，而局部变量的占用的内存空间是其所在的代码段或函数段结束时由系统回收重新利用，所以栈的空间是循环利用自动管理的，一般不需要人为操作。如果某次局部变量申请的空间超过栈的剩余空间时就有可能出现 “栈的溢出”，进而导致意想不到的后果。所以一般不宜在栈中申请过大的空间，比如长度很大的数组、递归调用重复次数很多的函数等等。 堆存储区： 通常存放程序运行中动态分配的存储空间。它的大小，并不固定，可动态扩张或缩放。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被提出（堆被缩减）。 (堆是低地址向高地址扩展的数据结构，是一块不连续的内存区域。在标准C语言上，使用malloc等内存分配函数是从堆中分配内存的 堆具有“大内存、手工分配管理、申请大小随意、可能会泄露”的特点，堆内存是操作系统划分给堆管理器来管理的，管理器向使用者（用户进程）提供API（malloc和free等）来使用堆内存。需要程序员手动分配释放，如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了（进程自身认为该内存没被使用，但是在堆内存记录中该内存仍然属于这个进程，所以当需要分配空间时又会重新去申请新的内存而不是重复利用这块内存），就是我们常说的内存泄漏，所以内存泄漏指的是堆内存被泄露了。 malloc()用法malloc()函数的原型12#include&lt;stdlib.h&gt;void *malloc(unsigned long size); 功能size应该为整型 分配一个size这么大的内存，返回一个指向这片内存空间的起始位置的一个指针，类型为void*、 若空间不足则或者其他原因没有成功申请到内存则返回NULL 如何使用1int *p = (int *)malloc(4); 它的意思是：请求系统分配 4 字节的内存空间，并返回第一字节的地址，然后赋给指针变量 p。 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位） C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）。或者自己进行强制类型转换也可以 void*与void不同，void* 是定义一个无类型的指针变量，它可以指向任何类型的数据。任何类型的指针变量都可以直接赋给 void* 型的指针变量，无需进行强制类型转换。 注意，不能对 void* 型的指针变量进行运算操作，如指针的运算、指针的移动等。原因很简单，前面讲int型的指针变量加 1 就是移动 4 个单元，因为 int\\ 型的指针变量指向的是 int 型数据；但是 void* 型可以指向任何类型的数据，所以无法知道“1”所表示的是几个内存单元。 free()用于释放使用malloc动态分配的内存 原型1void free(void *ptr); 参考：http://c.biancheng.net/view/223.html ​ https://blog.csdn.net/weixin_39371711/article/details/81783780","link":"/2020/03/03/malloc/"},{"title":"markdown基础语法","text":"基础语法强调斜体可用两个*表示，将内容放入星号间即可 效果：123 加粗使用两个** 效果：123 标题123456# 2## 2### 2#### 2##### 2 ###### 2 效果： 222222注意最后一个#与文字之间需要一个空格 引用引用使用 &gt; 12345&gt; 123&gt; 456&gt;&gt; 789&gt; //表示嵌套结束&gt; 0 效果： 123456 789 0 列表有序列表1231. 12. 14. 1 //实际显示与编号不一致 效果： 1 1 1 无序列表123456789- 1- 2+ 1+ 2* 1* 2 效果： 1 2 1 2 1 2 *注意+-不可混用 嵌套列表123456- 1- 1 - 2 - 2 - 3- 1 //使用一个制表符表示提高一级 1 1 2 2 3 1 分割线三个或更多-_* 效果： 1 2","link":"/2020/02/05/markdown-Grammatical-summary/"},{"title":"数据结构-队列（Queue）学习笔记","text":"队列只能在一段插入另一端删除 数据对象集：一个有0个或者多个元素的有穷线性表 操作集： Queue Create(int MaxSize) int IsFull(Queue Q,int Maxsize) void Add(Queue Q,ElementType item) int IsEmpty(Queue Q) ElementType Delete(Queue Q) 队列的顺序存储实现为了使空间得到充分的使用循环队列（当数组满了之后，又从头开始） 如何实现？ 由一个一维数组和一个记录队列头元素位置的变量front和一个记录队列尾元素位置的变量rear 插入元素时rear前移一位，删除元素时front前移一位 如何判断队列是空还是满？ 用front和rear之间的距离来判断，当front和rear相差1时，队列满 为什么不是front和rear相等时未满？ 相等时由两种状态，有可能为空也有可能满。 当然这个问题可以引入一个标记来解决： 引入Size 每次Add时+1，Delete时-1，当Size为0是队列为空 引入Tag Add时Tag = 1，Delete时Tag = 0，当front和rear相等时判断Tag的值即可 这里当rear与front相差1时就判断队列满 1234567#define MaxSize 元素最大数struct QNode{ ElementType Data[NaxSize]; int rear; int front;};typedef struct QNode *Queue; 1.Add 难点在于如何当rear到MaxSize时再+1就又返回起点 这里使用取余，当rear到达最大值时取MaxSize的余，就得到0 123456789void Add(Queue Q,ElementType item){ if(IsFull(Q)){ printf(&quot;队列满&quot;); } else{ Q-&gt;rear = (Q-&gt;rear+1) % MaxSize; Q-&gt;Data[Q-&gt;rear] = item; //把item放到数组里 } } Delete 1234567891011ElementType Delete(Queue Q){ if(IsEmpty(Q)){ printf(&quot;队列空&quot;)； return; } else{ Q-&gt;front = (Q-&gt;front + 1) % MaxSize; return Q-&gt;Data[Q-&gt;front]; } } 队列的链式存储实现使用一个单链表实现，插入和删除分别在两头进行，**问题在于front和rear应该分别指向链表的哪一头 ** rear需要插入数据需要放在链表的尾部，插入时只需要前一个节点的地址，front要在链表的头部的的下一个节点，方法与堆栈类似 12345678910struct Node{ ElementType Data; struct Node *Next;}struct QNode{ struct Node *rear; struct Node *front;};typedef struct QNode *Queue;Queue PtrQ; Delete 1234567891011121314151617ElementType Delete(Queue PtrQ){ struct Node *FrontCell; ElementType FrontElem; if(PtrQ-&gt;front == NULL){//若头节点之后没有节点则队列时空的 printf(&quot;队列空&quot;); return; } FrontCell = PtrQ-&gt;front;//储存第二个节点 if(PtrQ-&gt;front == PtrQ-&gt;rear) //若队列只有一个元素 PtrQ-&gt;front = PtrQ-&gt;rear = NULL; //则删除完后队列置空 else PrtQ-&gt;front = ptrQ-&gt;rear-&gt;Next;// FrontElem = Front-&gt;Data; free(FrontCell); return FrontElem;} Add 12345678void Add(Queue PtrQ,ElementType item){ struct Node TempCell;//创建新节点 TempCell = (Queue)malloc(sizeof(struct Node));//申请空间 TempCell-&gt;Data = item; PtrQ-&gt;rear-&gt;Next = TempCell;//将链表与新节点链接起来 PtrQ-&gt;rear = TempCell;//移动rear }","link":"/2020/03/09/queue/"},{"title":"数据结构-堆栈（Stack）学习笔记","text":"堆栈数据对象集：一个有0个或多个元素的有穷线性表 操作集： Stack CreateStack(int MaxSize) bool IsFull(Stacak S,int MaxSize) void Push(Stack S,ElementType item) bool IsEmpty(Stack S) ElementType Pop(Stack S) 堆栈的顺序存储实现通常由一个一维数组和一个记录栈顶元素位置的变量组组成 1234567#define MaxSize 元素最大个数typedef struct SNode *Stack;struct SNode{ ElementType *Data; int Top; int MaxSize;}; 创建 1234567Stack CreateStack(int MaxSize){ Stack S = (Stack)malloc(sizeof(struct SNode));//申请一块空间，存放Stack这个结构 S-&gt;Data = (ElementType *)malloc(MaxSize * sizeof(ElementType))//申请一块空间存放MaxSize个ElementType S-&gt;Top = -1;//初始状态栈顶为-1 S-&gt;MaxSize = MaxSize; return S;} 栈是否满了 123456bool IsFull(Stack S,int MaxSize){ if(S-&gt;Top == S-&gt;MaxSize - 1) return true; else return false;} 3.栈是否为空 123456bool IsEmpty(Stack S){ if(S-&gt;Top == -1) return true; else return false;} Push 1234567891011bool Push(Stack S,ElemenType item){ if(IsFull(S) == true) printf(&quot;栈满&quot;)； return false; else{ S-&gt;Data[++(S-&gt;Top)] = item; //Top先加一，在进行运算 return true; }} ++a是先自加再进行运算，a++是先运算再自加 Pop 12345678910ElementType Pop( Stack S ){ if ( IsEmpty(S) ){ printf(&quot;栈空&quot;); return false; } else{ return s-&gt;Data[(S-&gt;Top)--]; }} 用一个数组实现两个堆栈思路：两个堆栈分别从数组头和尾开始，向中间，当两个顶指针相遇时，表示两个堆栈都满了 ​ —–&gt; &lt;——- 12345678#define MaxSize 元素最大个数typedef struct DStack *PtrS;struct DStack{ ElementType *Data; int Top1; int Top2;}; ​ S.Top1 = -1 说明栈1空 ​ S.Top2 = MaxSize 说明栈2空 Push 12345678910void Push(PtrS S,ElementType item,int Tag){ if(S-&gt;Top2 - S-&gt;Top1 == 1){//两栈相遇时Top相差1 printf(&quot;堆栈满&quot;); return; } if(Tag == 1) S-&gt;Data[++(S-&gt;Top1)] = item; else S-&gt;Data[--(S-&gt;Top2)] = item;//注意因为堆栈2是倒着来的，所以是--} Pop 1234567891011121314151617181920ElementType Pop(PtrS S,int Tag){ if(Tag == 1){ if(S-&gt;Top1 == -1){ printf(&quot;堆栈1空&quot;)； return; } else{ return S-&gt;Data[(S-&gt;Top1)--]; } } else{ if(S-&gt;Top2 == MaxSize){ printf(&quot;堆栈1空&quot;)； return; } else{ return S-&gt;Data[(S-&gt;Top2)++]; } }} 堆栈的链式存储实现实际上是单向链表，叫链栈。插入和删除操作只能再链栈的栈顶进行，栈顶指针应该在链表的表头后其他节点之前，否则无法进行删除操作，因为前一个节点无法保存上一个节点的指针 12345typedef struct SNode *Stack;struct SNode{ ElementType Data; struct SNode *Next; //记录下一个节点的指针}; Create 123456Stack CreateStack(){//构建指针头节点 Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next == NULL; return S;} 2.IsEmpty 123int IsEmpty(Stack S){ return (S-&gt;Next == NULL); //若头节点的Next为NULL则堆栈为空} Push 12345678void Push(ElementType item,Stack S){ Stack TempCell; TempCell = (Stack)malloc(sizeof(Struct SNode)); TempCell-&gt;Data = item; TempCell-&gt;Next = S-&gt;Next; S-&gt;Next = TempCell; //插到头节点之后其他节点之前} Pop 12345678910111213141516ElementType Pop(Stack S){ if(IsEmpty(S)){ printf(&quot;堆栈空&quot;); return NULL; } else{ Stack TopCell;//为了找到第三个节点和释放空间而声明的 ElemtType TopElem; TopCell = S-&gt;Next;//把第二个节点的地址给TopCell S-&gt;Next = TopCell-&gt;Next;//把第三个节点给S的Next，就跳过了第二个节点即删除了第二个节点 TopElem = TopCell-&gt;Element; free(TopCell); return TopElem; } } 堆栈的应用 中缀表达式转后缀表达式 函数调用及递归实现 深度优先搜索 回溯算法 …….","link":"/2020/03/06/stack/"},{"title":"C语言中struct用法","text":"结构声明结构类型1234567struct date{ int year; int month; int day;};//声明一种结构，结构内包含year，month，day三个成员struct date today;//定义一个变量today，这个变量的类型是date 在函数内声明的结构只可以在函数内使用 声明结构的三种形式123456struct point { int x; int y;};struct point p1,p2; 1234struct { int x; int y;}p1,p2;//只定义了两个变量 1234struct point { int x; int y;}p1,p2; 结构的初始化12struct date today = {2020,02,13};struct date yesterday = {.month = 2, .year = 2020}; 结构成员结构使用”.”来访问成员 today.year = xxxx; 结构运算12p1 = (struct point){5,10};//相当于怕p1.x = 5;p2.y = 10; p1 = p2; //相当于p1.x = p2.x;p1.y = p2.y; 结构指针 与数组不同，结构的变量名并不是结构变量的地址，必须使用&amp; struct date *pDate = &today; 结构与函数结构作为函数参数 整个结构可以作为参数的值传入函数 实际上进行的操作是在函数内新疆一个结构变量，并复制调用者的结构的值 也可返回一个结构 typedef1234typedef struct{ int x; int y;}point; h表示声明一个结构，结构名为point","link":"/2020/02/13/struct/"},{"title":"CSS学习笔记","text":"[TOC] CSS穿衣服 CSS语法 选择符又名选择器，指明网页中要应用样式规则的元素 最后一条声明可以没有分号 /这样写注释\\/ CSS的三种用法及优先级内联式直接写在标签中 123&lt;p style=&quot;color:red&quot;&gt; 红&lt;/p&gt; 红 多条语句用;分开 1&lt;p style=&quot;color:red;font-size:12px&quot;&gt;红&lt;/p&gt; 红 嵌入式12345678&lt;style type=&quot;text/css&quot;&gt; p{ color:blue; }&lt;/style&gt;&lt;p &gt; 我是蓝的&lt;/p&gt; 外部式创建一个单独的css文件 1&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; 使用上面这句引用，通常写在head标签中 优先级内联式 &gt; 嵌入式 &gt; 外部式 选择器标签选择器1p{font-size:12px;} 类选择器使用”.“开头 123456.1{ color:pink;}&lt;span class=&quot;1&quot;&gt; 粉🐖&lt;/span&gt; ID选择器123456#1{ color:pink;}&lt;span id=&quot;1&quot;&gt; 粉🐖&lt;/span&gt; 类选择器和ID选择器的区别 ID选择器只可以使用一次，而类选择器可以使用多次 12&lt;span id=&quot;1&quot;&gt;我不是&lt;/span&gt;&lt;span id=&quot;1&quot;&gt;🐖&lt;/span&gt; 这是错的嗷 还可以这样写 1234567.1{ color:pink;}.2{ font-size:200px;}&lt;span class=”1 2“&gt;大粉🐖&lt;/span&gt; 亲戚关系选择器hhh子选择器123&lt;p class=&quot;1&quot;&gt; &lt;span&gt;🐖&lt;/span&gt;&lt;/p&gt; 1.1&gt;sapn{color:pink} 选择class名为1下的子元素&lt;span&gt; 后代选择器1.1 span{color:pink} 与子选择器的区别：子选择器只选择他的直接后代，而后代选择器把他的儿子孙子重孙都选上了,都变成粉色了 通用选择器1*{color:pink;} 这下所以标签的元素都成粉的了 伪类选择器给不存在的标签（或标签的某种状态）设置样式 1a:hover{color:pink;} 当鼠标经过时变粉 分组选择器1h1,span{color:pink;} 相当于 12h1{color:pink;}span{color:pink;} 继承，优先级和重要性样式的继承性什么是继承性？ 允许样式不仅应用于某个特定html标签，而且应用于后代 12p{color:red;}&lt;p&gt;hhhhh&lt;sapn&gt;wllll&lt;/span&gt;&lt;/p&gt; hhhhh是红色，wllll也是红色 但是某些CSS样式不具有继承性 选择器的优先级1、如果一个元素使用了多个选择器,则会按照选择器的优先级来给定样式。 2、选择器的优先级依次是: 内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 权值标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100 若多个选择器匹配到了一个标签上，那么谁的权值高就显示谁的样式 12345p{color:red;} /*权值为1*/p span{color:green;} /*权值为1+1=2*/.warning{color:white;} /*权值为10*/p span.warning{color:purple;} /*权值为1+1+10=12*/#footer .note p{color:yellow;} /*权值为100+10+1=111*/ !important123p{color:red!important;}p{color:green;}&lt;p class=&quot;first&quot;&gt;三年级时，我还是一个&lt;span&gt;胆小如鼠&lt;/span&gt;的小女孩。&lt;/p&gt; 带有!important的会被应用，无论其他的权值有多高 设置样式关于字体font-family12body{font-family:&quot;Microsoft Yahei&quot;;}body{font-family:&quot;微软雅黑&quot;;} font-size1body{font-size:12px;} font-weight字体粗细1p span{font-weight:bold;} 值 描述 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100/200/300/400/500/600/700/800/900 定义由粗到细的字符。400 等同于 normal，而 700 等同于 bold。 inherit 规定应该从父元素继承字体的粗细。 font-style字体样式1p{font-style:normal;} 值 描述 normal 默认值。浏览器显示一个标准的字体样式。 italic 浏览器会显示一个斜体的字体样式。 oblique 浏览器会显示一个倾斜的字体样式。 inherit 规定应该从父元素继承字体样式。 color设置字体颜色 英文命令颜色 1p{color:red;} RGB 颜色 1p{color:rgb(133,45,200);} 1p{color:rgb(20%,33%,25%);} 十六进制颜色 1p{color:#00ffff;} font家族的缩写 1234567body{ font-style:italic; font-weight:bold; font-size:12px; line-height:1.5em; font-family:&quot;宋体&quot;,sans-serif;} 这么多行的代码其实可以缩写为一句： 123body{ font:italic bold 12px/1.5em &quot;宋体&quot;,sans-serif;} 想要使用这种简写方式，至少要指定font-size和font-family，其他属性未指定则会使用默认值 在缩写时 font-size 与 line-height 中间要加入“/”斜扛 关于文本1h1 {text-decoration:none} text-decoration给文本添加修饰 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 blink 定义闪烁的文本。 inherit 规定应该从父元素继承 text-decoration 属性的值。 text-indent为文本添加首行缩进1p{text-indent:2em;} 1em 等于当前的字体尺寸。 2em 等于当前字体尺寸的两倍。 例如，如果某元素以 12pt 显示，那么 2em 是24pt。 在 CSS 中，em 是非常有用的单位，因为它可以自动适应用户所使用的字体 line-height为文字间设置行间距/行高1p{line-height:1.5em;} letter/word-spacing增加或减少字符间的空白letter-spacing为文字或字母中间设置间隔 1h1{letter-spacing:50px;} word-spacing为单词之间设置间距 text-align设置文本对齐方式为块状元素设置对齐方式 1h1 {text-align:center} 值 描述 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 inherit 规定应该从父元素继承 text-align 属性的值。 盒模型概念在CSS中，HTML中的标签，被分为三类 块状元素 ```html、、...、、、、、、 、 12345- 内联元素 - ```html &lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联块元素 &lt;img&gt;、&lt;input&gt; 1234567891011#### 块级元素- 每个块级元素都从新的一行开始- 元素高度、宽度、行高、顶边底边距都可设置- 元素宽度在不设置的情况下，是他本身父容器的100%，即和父元素宽度一致通过```cssa{display:block;} 可以将内联元素转换为块状元素 内联元素 和其他元素都在一行上 元素的高度、宽度及顶部和底部边距不可设置 元素的宽度就是它包含的文字或图片的宽度，不可改变 1div{display:inline;} 可以将块状元素转换为内联元素 内联块状元素 和其他元素在一行上 高宽，行高，顶底边距都可设置 1div{display:inline-block;} 当display设置为none时，元素隐藏 使用盒模型基本知识 padding 是盒子里的内容到盒子边框的距离 border 是盒子的边框 margin 是盒子边框距离别的盒子边框的距离 css内定义的宽（width）和高（height），指的是填充以里的内容范围。 因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 background-color背景色12div{background-color:red;}//为块状元素设置a{background-color:green;}//为行内元素设置 border为盒子添加边框 值 描述 border-width 规定边框的宽度。参阅：border-width 中可能的值。 border-style 规定边框的样式。参阅：border-style 中可能的值。 border-color 规定边框的颜色。参阅：border-color 中可能的值。 12345div{ border-width:2px; border-style:solid; border-color:red;} 可以简写为 123div{ border:2px solid red;} border-方向 为盒子的某一边框设置样式1div{border-bottom/top/left/right:xxx xxx} border-radius 为边框四个角分别设置圆角1div{border-radius: 20px 10px 15px 30px;} 顺序为左上、右上、右下、左下 也可以分开写： 123456div{ border-top-left-radius: 20px; border-top-right-radius: 10px; border-bottom-right-radius: 15px; border-bottom-left-radius: 30px;} 如果四个圆角都为10px;可以这么写： 1div{ border-radius:10px;} 如果左上角和右下角圆角效果一样为10px，右上角和左下角圆角一样为20px，可以这么写： 1div{ border-radius:10px 20px;} 需要特别注意的：一个正方形，当设置圆角效果值为元素宽度一半时，显示效果为圆形。例如： 123456div { width: 200px; height: 200px; border: 5px solid red; border-radius: 100px/50%; } padding为盒子设置填充1div{padding:20px 10px 15px 30px;} 上右下左 其他设置方法与border-radius类似 margin为盒子设置外边距1div{margin:20px 10px 15px 30px;} 一样 布局模型流动模型（Flow）默认的网页布局模式 特征 块状元素会在所处的包含元素内，自上而下垂直延申分布(默认状态下块元素的宽度为100%) 内联元素都会在包含元素内从左到右水平分布 浮动模型(Float)可以设置两个块状元素显示一行 1div{float:left/right;} 设置靠左or靠右 也可以分别设置，使之一个靠左一个靠右 12div1{float:left;}#div2{float:right;} 层模型关于文档流可以看这篇https://blog.csdn.net/wayne1998/article/details/80230608 层模型有三种形式： 1、绝对定位(position: absolute) 这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 2、相对定位(position: relative) 它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 我的理解是，先正常生成元素，然后再浮起来，相对原来的位置进行移动 3、固定定位(position: fixed) fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响 12345678#div1{ width:200px; height:200px; border:2px red solid; position:fixed; left:100px; top:50px;} 弹性盒模型这个好这个好https://www.jianshu.com/p/5856c4ae91f2 弹性盒子由弹性容器和弹性子元素组成 1display:flex | inline-flex; 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。 常用属性 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 flex-direction决定子元素排列方向 1.flex-container { flex-direction: row | row-reverse | column | column-reverse; } 值 描述 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 flex-wrapflex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 值 描述 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 可以取三个值：（1） nowrap (默认)：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1.flex-container { flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt; } align-itemsalign-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 值 描述 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 justify-contentjustify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 值 描述 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 弹性子元素属性 属性 描述 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 order属性1.flex-container .flex-item { order: &lt;integer&gt;; } ：用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认为0。 flex-grow属性1.flex-container .flex-item { flex-grow: &lt;integer&gt;; } ：一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。 flex-shrink属性1.flex-container .flex-item { flex-shrink: &lt;integer&gt;; } ：一个数字，规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。 flex-basis属性1.flex-container .flex-item { flex-basis: &lt;integer&gt; | auto; } ：一个长度单位或者一个百分比，规定元素的初始长度。 auto：默认值。长度等于元素的长度。如果该项目未指定长度，则长度将根据内容决定。 flex属性flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。 flex 属性是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。 1.flex-container .flex-item { flex: flex-grow flex-shrink flex-basis | auto | initial | inherit; } 值 描述 flex-grow 一个数字，规定项目将相对于其他元素进行扩展的量。 flex-shrink 一个数字，规定项目将相对于其他元素进行收缩的量。 flex-basis 项目的长度。合法值：”auto”、”inherit” 或一个后跟 “%”、”px”、”em” 或任何其他长度单位的数字。 auto 与 1 1 auto 相同。 none 与 0 0 auto 相同。 initial 设置该属性为它的默认值，即为 0 1 auto。 inherit 从父元素继承该属性。 align-self属性123.flex-container .flex-item { align-self: auto | stretch | center | flex-start | flex-end | baseline | initial | inherit;} 值 描述 auto 默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。 stretch 元素被拉伸以适应容器。 center 元素位于容器的中心。 flex-start 元素位于容器的开头。 flex-end 元素位于容器的结尾。 baseline 元素位于容器的基线上。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 作者：弓三水链接：https://www.jianshu.com/p/5856c4ae91f2来源：简书写的很全很好很厉害，直接复制了，方便以后查阅","link":"/2020/04/26/CSS/"},{"title":"JavaScript学习笔记","text":"[TOC] 插入JS使用&lt;script&gt;&lt;/script&gt;标签 &lt;script type=”text/javascript”&gt;固定写法 123&lt;script type=&quot;text/javascript&quot;&gt; JS写在这里&lt;/script&gt; JS也可以单独存在类似CSS 在JS文件中不需要&lt;script&gt;标签 1&lt;script src=&quot;js文件的路径&quot;&gt;&lt;/script&gt; 通过上面这句来引用js文件 JS一般放在&lt;head&gt;或&lt;body&gt;里，浏览器读到时就会运行 基础 js的每句代码结束都需要; 用//添加注释，/*注释内容*/实现多行注释 使用var声明变量 JS中变量区分大小写 if和else用法与C语言几乎一样 函数使用function定义 123function name(){ code;} 定义好后不会自己执行，需要调用 输出document.write() 直接使用引号 1document.write(&quot;哈哈&quot;); 输出变量 12var str=&quot;hahah&quot;;document.write(str); 输出多项内容 12var str=&quot;java&quot;;documen.write(str+&quot;script&quot;); 输出html标签 1documen.write(&quot;&lt;br&gt;&quot;); alert()1alert(字符串或变量)； 弹出一个消息对话框，包含一个确定按钮 点击确定前不能进行其他任何操作 互动confirm()1confirm(str); str是在对话框中显示的内容 返回值是Boolean 用户点击确定时返回ture，取消返回false prompt()1prompt(str1,str2); str1是在对话框中显示的文本 str2是文本框中的内容 点确定返回文本框中的内容，取消返回null 窗口window.open()注意使用单引号 1window.open('URL','窗口名称','参数字符串,多个用逗号隔开'); URL可选，在窗口中显示网页的网址或路径。如果省略，那么窗口就不显示任何文档 窗口名称可选，被打开窗口的名称 1.该名称由字母、数字和下划线字符组成。 2.”_top”、”_blank”、”_self”具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。 窗口字符串 sample 12&lt;script type=&quot;text/javascript&quot;&gt; window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')&lt;/script&gt; 打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口 window.close()1window.close();//关闭本窗口 1234&lt;script type=&quot;text/javascript&quot;&gt; var mywin=window.open('http://www.imooc.com'); //将新打的窗口对象，存储在变量mywin中 mywin.close();&lt;/script&gt; 练习 1、新窗口打开时弹出确认框，是否打开 1提示: 使用 if 判断确认框是否点击了确定，如点击弹出输入对话框，否则没有任何操作。 2、通过输入对话框，确定打开的网址，默认为 http：//www.imooc.com/ 3、打开的窗口要求，宽400像素，高500像素，无菜单栏、无工具栏。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; new document &lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gbk&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; function openWindow(){ var sta = confirm(&quot;是否打开窗口&quot;); if(sta == true){ var url = prompt(&quot;请填写网址&quot;,&quot; http：//www.imooc.com/&quot;) window.open('url','width=400,height=500,toolbar=no,menubar=no'); } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;新窗口打开网站&quot; onclick=&quot;openWindow()&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 变量声明Javascript使用 1var x; 声明变量，可以存储数字、字符、字符串 表达式1234var a = &quot;goodbye&quot;;var b = &quot;verge&quot;;var c = a + b;alert(c); 结果是goodbyeverge 数组声明1var myarr = new Array(); 在括号内指定数组长度，虽然数组长度已经确定，但仍可以将数据储存在规定长度之外 赋值123var myarr = new Array(2);myarr[0] = 1;myarr[1] = 2; 实现同样的效果还有两种方法 1var myarr = new Array(1,2); 1var myarr = [1,2]; 可以使用未使用的下标，不断给数组添加成员 1myarr[2] = 3; 数组没有赋值直接输出的话会输出undefined 数组长度1myarr.length; 可以使用 1myarr.length = 一个数字;//改变数组长度 在你改变数组长度后，即使里面什么都没存，长度还是你改变后的。 如果，一个数组是这样var arr = [1,2,3] 长度为3，如果这是你进行 arr.length = 2,那么长度就会变成2，会把原来arr[2]的位置变为undefined 数组元素增加长度也会改变 1234var myarr = [1,2,3];alert(myarr.length);myarr[3] = 4;alert(myarr.length); 二维数组1myarr[][]; 定义1234567var myarr=new Array(); //先声明一维 for(var i=0;i&lt;2;i++){ //一维长度为2 myarr[i]=new Array(); //再声明二维 for(var j=0;j&lt;3;j++){ //二维长度为3 myarr[i][j]=i+j; // 赋值，每个数组元素的值为i+j }} 1var myarr = [[0,1,2],[1,2,3]];//两行三列 1var myarr[0][1] = 123; 函数定义123function funname(){ do something;} 调用函数 在&lt;script&gt;标签内直接调用 123&lt;script type=&quot;text/javascript&quot;&gt; funname(); &lt;/script&gt; 在HTML文件中调用，通过点击按钮调用定义好的函数 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function add2() { sum = 5 + 6; alert(sum); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;click it&quot; onclick=&quot;add2()&quot;&gt; //按钮,onclick点击事件，直接写函数名 &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 含有参数的函数123function add(x,y){ document.write(x+y);} 有返回值的函数123456function add(x,y){ document.write(x+y); return x+y;}res = add(x,y); 事件事件是可以被Javascript侦测到的行为 onclick 鼠标点击事件1&lt;input type = &quot;button&quot; value = &quot;点我调用add()&quot; onclick=&quot;add()&quot; &gt; onload 加载事件加载页面时会触发onload事件 可以理解为打开页面时会出发的事件 onubload卸载事件当用户刷新，关闭页面时触发的事件 其他事件使用方式大同小异对象什么是对象JavaScript 中的所有事物都是对象，如:字符串、数值、数组、函数等，每个对象带有属性和方法。 对象的属性：反映该对象某些特定的性质的，如：字符串的长度、图像的长宽等； 对象的方法：能够在对象上执行的动作。例如，表单的“提交”(Submit)，时间的“获取”(getYear)等；就是在对象的基础上再进行操作 JavaScript 提供多个内建对象，比如 String、Date、Array 等等，使用对象前先定义，如下使用数组对象： 123 var objectName =new Array();//使用new关键字定义对象或者 var objectName =[]; 访问对象属性的语法: 1objectName.propertyName 如使用 Array 对象的 length 属性来获得数组的长度： 12var myarray=new Array(6);//定义数组对象var myl=myarray.length;//访问数组长度length属性 以上代码执行后，myl的值将是：6 访问对象的方法： 1objectName.methodName() 如使用string 对象的 toUpperCase() 方法来将文本转换为大写： 12var mystr=&quot;Hello world!&quot;;//创建一个字符串var request=mystr.toUpperCase(); //使用字符串对象方法 以上代码执行后，request的值是：HELLO WORLD! Date 日期对象可以存储任意一个日期，可以精确到毫秒 1var date1 = new Date(); 初始值为当前电脑系统世间 自定义初始值可以 12var date1 = new Date(2020,2,23);var date1 = new Date('Apr 23,2020'); 我们最好使用下面介绍的“方法”来严格定义时间。 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;” Date对象中处理时间和日期的常用方法： 返回/设置年份的方法123var mydate = new Date();mydate.setFullYear(20);//不同浏览器结果不同，有可能是20或0020var myyear = mydate.getFullYear(); 返回星期方法1mydate.getDay()//返回的是0-6的一个数字，0是周日 返回/设置时间的方法get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。 时间加一小时就是 1mydate.setTime(mydate.getTime()+60*60*1000); String 字符串对象123var str = &quot;jinxuyang&quot;;var srtlen = str.length;//返回字符串长度var STR = str.toUpperCase();//转换为大写,toLowerCase()转换为小写 charAT() 返回指定位置的字符1stringOject.charAt(index) 参数index即字符在字符串中的下标 返回一个字符长度为1的字符串 indexOf() 返回指定的字符串首次出现的位置1stringObject.indexOf(substring, startpos) 返回需要检索的字符串的第一个字符第一次出现的位置，如果没有则返回-1 split() 字符串分割1stringObject.split(separator,limit) 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 若达到分割的次数之后，后面分割出来的字串就不会输出，或者说到达分割的次数之后就不再分割 substring() 提取字符串1stringObject.substring(startPos,stopPos) startPos和stopPos可以理解为字符串数组开始和结束的下标，两个参数相等的话就返回一个空串，如果stop比start大会先交换这两个参数 stopPos 假设一个字符串是abcdefg那么substring(0,4)提取出来的结果是abcd，到stopPos结束，并不包括stopPos substr() 提取指定数目字符串1stringObject.substr(startPos,length) 注意：如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 如果startPos为负数且绝对值大于字符串长度，startPos为0 search() 检索字符串中指定的子字符串（正则）1stringObject.search(reg/str) 返回第一个匹配结果的index，查找不到返回-1 search()不执行全局匹配，总是从字符串的开始进行检索 match() 检索字符串找到一个或多个与RegExp匹配的文本1str.match(regexp) 参数 regexp 一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp 。如果你没有给出任何参数并直接使用match() 方法 ，你将会得到一 个包含空字符串的 Array ：[“”] 。 返回值 如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。 如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。 附加属性 如上所述，匹配的结果包含如下所述的附加特性。 groups: 一个捕获组数组 或 undefined（如果没有定义命名捕获组）。 index: 匹配的结果的开始位置 input: 搜索的字符串. 描述 如果正则表达式不包含 g 标志，str.match() 将返回与 RegExp.exec(). 相同的结果。 replace() 替换字符串中指定子字符串或正则匹配的结果12str.replace(regexp,&quot;替换成的内容&quot;)str.replace(&quot;要替换的内容&quot;，&quot;替换成的内容&quot;) Math 对象注意：Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 Math 对象属性 Math对象方法 Array 数组对象concat() 数组连接1arrayObject.concat(array1,array2,...,arrayN) 返回一个连接后的数组，不会改变原来的数组 12345var mya = new Array(3); mya[0] = &quot;1&quot;; mya[1] = &quot;2&quot;; mya[2] = &quot;3&quot;; document.write(mya.concat(4,5)); 可以这样写直接给数组后面在加上4，5，注意并不改变mya数组 join() 指定分隔符连接数组元素1arrayObject.join(分隔符) 若参数留空则默认使用，分开 reverse() 颠倒数组元素顺序1arrayObject.reverse() 注意：该方法会改变原来的数组，而不会创建新的数组。 slice() 选定元素1arrayObject.slice(start,end) 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 sort() 数组排序**sort()**方法使数组中的元素按照一定的顺序排列。 语法: 1arrayObject.sort(方法函数) 参数说明： 1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。 2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。 1myArray.sort(compareFunction); 如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前。 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 所以，比较函数格式如下： 12345678910function compare(a, b) { if (a &lt; b ) { // 按某种排序标准进行比较, a 小于 b return -1; } if (a &gt; b ) { return 1; } // a must be equal to b return 0;} 具体实现 123456789&lt;script type=&quot;text/javascript&quot;&gt; function sortNum(a,b) { return a - b; //升序，如降序，把“a - b”该成“b - a”} var myarr = new Array(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;); document.write(myarr + &quot;&lt;br&gt;&quot;); document.write(myarr.sort(sortNum));&lt;/script&gt; 运行结果： 1280,16,50,6,100,11,6,16,50,80,100 window对象 JavaScript定时器 setInterval()载入页面后每隔指定时间执行代码 1setInterval(代码，交互时间) 代码：要执行的代码 交互时间：周期执行的时间间隔，单位毫秒 返回值：是一个值，可以把这个值传给clearInterval()从而取消setInterval()的执行 调用函数格式(**假设有一个clock()函数):** 123setInterval(&quot;clock()&quot;,1000)或setInterval(clock,1000) clearInterval()1clearInterval(id_of_setInterval) setTimeout()1setTimeout(代码，延迟时间); 延迟时间到后执行代码 clearTimeout()与clearInterval()相似 history对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意:从\\窗口**被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。** 语法： 1window.history.[属性|方法] 注意：window可以省略。 History 对象属性 History 对象方法 使用length属性，当前窗口的浏览历史总长度，代码如下： 1234&lt;script type=&quot;text/javascript&quot;&gt; var HL = window.history.length; document.write(HL);&lt;/script&gt; go()语法： 1window.history.go(number); 参数： location对象location用于获取或设置窗体的URL，并且可以用于解析URL。 语法: 1location.[属性|方法] location对象属性图示: location 对象属性： location 对象方法: navigator对象 DOM什么是DOM参考这个 获取元素getElementById1document.getElementById(&quot;id&quot;); 获取的元素是一个对象，想要对这个元素操作还需要其他东西 12345&lt;p id=&quot;1&quot;&gt;text&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var str = document.getElementById(&quot;1&quot;); documen.write(str);&lt;/script&gt; 这样是错误的 getElementsByNameElement比上面那个多了个s 1document.getElementsByName(); 由于name属性可能是不唯一的，因此返回值是元素数组，同样也有length属性 getElementsByTagName1document.getElementsByTagName(Tagname) Tagname是标签的名称，如p、a、img等标签名 返回值也是数组也有length getAttribute()通过元素结点的属性名获取属性的值 1elementNode.getAttribute(name) 操作元素setAttribute()1elementNode.setAttribute(name,value) 1.name: 要设置的属性名。 2.value: 要设置的属性值 注意： 1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 innerHTML1object.innerHTML object是获取的元素 12345&lt;p id=&quot;1&quot;&gt;text&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var str = document.getElementById(&quot;1&quot;); documen.write(str.innerHTML);&lt;/script&gt; 这样就对了 改变HTML样式1object.style.property=new style; object是获取的元素 property 123456&lt;p id=&quot;1&quot;&gt;text&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var str = document.getElementById(&quot;1&quot;); document.write(str.innerHTML); str.style.color=&quot;pink&quot;;//变粉&lt;/script&gt; 显示和隐藏1object.style.display = &quot;value&quot;; value的值 1234567&lt;p id=&quot;1&quot;&gt;text&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var str = document.getElementById(&quot;1&quot;); document.write(str.innerHTML); str.style.color=&quot;pink&quot;;//变粉 str.style.display=&quot;none&quot;;//隐藏&lt;/script&gt; 控制类名1object.className = &quot;classname&quot;; 获取元素class属性 为元素指定一个css样式 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; var str = document.getElementById(&quot;1&quot;); document.write(str.innerHTML); str.style.color=&quot;pink&quot;;//变粉 str.style.display=&quot;none&quot;;//隐藏 str.classNme = &quot;hahaha&quot;//改变元素类名&lt;/script&gt;&lt;style type=&quot;text/css&quot;&gt; .ha{color:pink;} .hahaha{color:blue;}&lt;/style&gt;&lt;p id=&quot;1&quot; class=&quot;ha&quot;&gt;text&lt;/p&gt; 结点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 二、nodeValue 属性：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问结点访问子节点childNodes1elementNode.childNodes 返回值是所有子节点的列表，可以看作数组，没有子节点则返回一个不包含结点的列表 访问子节点的第一项和最后一项一、**firstChild **属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： 1node.firstChild 说明：与elementNode.childNodes[0]是同样的效果。 二、** lastChild** 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 语法： 1node.lastChild 说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 访问父节点parentNode1elementNode.parentNode 一个结点只能有一个父结点 访问兄弟结点 nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。 语法： 1nodeObject.nextSibling 说明：如果无此节点，则该属性返回 null。 previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。 语法： 1nodeObject.previousSibling 说明：如果无此节点，则该属性返回 null。 插入结点appendChild()1node.appendChild(newnode) 在指定节点的最后一个子节点列表之后添加一个新的子节点。 这里的newnode需要使用document.createElement(&quot;标签&quot;)来创建 insertBefore()方法在参考节点之前插入一个拥有指定父节点的子节点 1node.insertBefore(newnode,node); newnode: 要插入的新节点。 node: 指定此节点前插入节点。 而所谓的“拥有指定父节点”，就是指被参照的节点的父节点就是调用insertBefore方法的节点。 如果给定的子节点是对文档中现有节点的引用，insertBefore()会将其从当前位置移动到新位置。 如果给定的子节点是DocumentFragment，那么DocumentFragment的全部内容将被移动到指定父节点的子节点列表中。 删除节点removeChild()12345let oldChild = node.removeChild(child);//ORelement.removeChild(child); child 是要移除的那个子节点. node 是child的父节点. oldChild保存对删除的子节点的引用. oldChild === child. 被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如上例中的oldChild来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被内存管理回收. replaceChild()replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 语法： 1node.replaceChild (newnode,oldnew ) 参数： newnode : 必需，用于替换 oldnew 的对象。oldnew : 必需，被 newnode 替换的对象。","link":"/2020/03/30/JavaScript/"},{"title":"算法竞赛入门经典笔记","text":"[TOC] 数组程序3-1 逆序输出1234567891011121314#include&lt;stdio.h&gt;#define maxn 105 int a[maxn];int main(){ int x, n = 0; while(scanf(&quot;%d&quot;, &amp;x) == 1) a[n++] = x;//读取，先赋值a[n]＝x，然后执行n＝n＋1 for(int i = n-1; i &gt;= 1; i--) printf(&quot;%d &quot;, a[i]);//逆序输出 printf(&quot;%d\\n&quot;, a[0]);//最后一个输出后跟换行 return 0;} 数组声明在main函数外可以开的更大 数组不可以直接b=a，但可以使用memcpy(b,a,sizeof(int)*k),这个函数中的int需要根据数据类型不同，进行改变。这个函数包含在string.h中 程序3-2 开灯问题 开灯问题。有n盏灯，编号为1～n。第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉灯将被打开，开着的灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？输入n和k，输出开着的灯的编号。k≤n≤1000。 样例输入：7 3样例输出：1 5 6 7 模拟题 123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 1010int a[maxn];int main(){ int n, k, first = 1; memset(a, 0, sizeof(a));//初始化数组 scanf(&quot;%d%d&quot;, &amp;n, &amp;k);//n盏灯，k个人 for(int i = 1; i &lt;= k; i++) for(int j = 1; j &lt;= n; j++) if(j % i == 0) a[j] = !a[j];//j%i==0可以计算出i的倍数，符合条件就改变灯的状态 for(int i = 1; i &lt;= n; i++)//循环输出 if(a[i]) { //灯开着就输出 if(first) first = 0; //第一个进行特殊化处理，放在第一个的原因是，最后一个不好找 else printf(&quot; &quot;); printf(&quot;%d&quot;, i); } printf(&quot;\\n&quot;); return 0;} 蛇形填数。在n×n方阵里填入1，2，…，n×n，要求填成蛇形。例如，n＝4时方阵为：10 11 12 19 16 13 28 15 14 37 6 5 4 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 20int a[maxn][maxn];int main(){ int n, x, y, tot = 0; scanf(&quot;%d&quot;, &amp;n);//读方阵边长 memset(a, 0, sizeof(a)); tot = a[x=0][y=n-1] = 1; /* 上面这句其实就是 x = 0; y = n-1; a[x][y] = 1; tot = 1; */ while(tot &lt; n*n){ //向四个方向移动，先判断是否到达边界，是否已经来过，再移动，再赋值， while(x+1&lt;n &amp;&amp; !a[x+1][y]) a[++x][y] = ++tot; while(y-1&gt;=0 &amp;&amp; !a[x][y-1]) a[x][--y] = ++tot; while(x-1&gt;=0 &amp;&amp; !a[x-1][y]) a[--x][y] = ++tot; while(y+1&lt;n &amp;&amp; !a[x][y+1]) a[x][++y] = ++tot; } for(x = 0; x &lt; n; x++){ for(y = 0; y &lt; n; y++) printf(&quot;%3d&quot;, a[x][y]); printf(&quot;\\n&quot;); } return 0;} 在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔。因为“悔棋”往往比较麻烦。 细心的读者也许会发现这里的一个“潜在bug”：如果越界，x+1会等a[x+1][y]将访问非法内存！幸运的是，这样的担心是不必要的。“&amp;&amp;”是短路运算符（还记得我们在哪里提到过吗？）。如果x+1&lt;n为假，将不会计算“!a[x+1][y]”，也就不会越界了。 字符数组程序3-4 竖式问题 竖式问题。找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出(为了便于观察，竖式中的空格改用小数点显示，但所写程序中应该输出空格，而非小数点）。样例输入：2357样例输出：&lt;1&gt;..775 X..33 .2325 2325. 25575The number of solutions = 1 伪代码 12345678910111213char s[20];int count = 0;scanf(&quot;%s&quot;, s);for (int abc = 111; abc &lt;= 999; abc++) for (int de = 11; de &lt;= 99; de++) if (&quot;abc*de&quot;是个合法的竖式) { printf(&quot;&lt;%d&gt;\\n&quot;, count); 打印abc*de的竖式和其后的空行 count++; }printf(&quot;The number of solutions = %d\\n&quot;, count); 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ int count = 0; char s[20], buf[99]; scanf(&quot;%s&quot;, s); for (int abc = 111; abc &lt;= 999; abc++) for (int de = 11; de &lt;= 99; de++) { int x = abc * (de % 10), y = abc * (de / 10), z = abc * de;//模拟竖式计算过程 sprintf(buf, &quot;%d%d%d%d%d&quot;, abc, de, x, y, z);//把这个竖式 的所有字符放入buf中 int ok = 1; for (int i = 0; i &lt; strlen(buf); i++)//遍历buf的所有字符 if (strchr(s, buf[i]) == NULL) ok = 0;//如果buf里有一个字符在s中找不到，就不符合要求，ok=0不输出 if (ok) { printf(&quot;&lt;%d&gt;\\n&quot;, ++count); printf(&quot;%5d\\nX%4d\\n-----\\n%5d\\n%4d\\n-----\\n%5d\\n\\n&quot;, abc, de, x, y, z); } } printf(&quot;The number of solutions = %d\\n&quot;, count); return 0;} strchr():​ 原型： ​ char *strchr(const char *str, int c) ​ 参数： ​ str–要被检索的C字符串 ​ c–在str中要搜索的字符 ​ 返回值： ​ 该函数返回在字符串 str 中第一次出现字符 c 的位置，如果未找到该字符则返回 NULL。 sprintf()：​ 将格式化的数据写入字符串 ​ 原型： ​ int sprintf(char *str, char * format [, argument, …]); ​ 参数： ​ str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量 ​ 返回值： ​ 成功则返回参数str 字符串长度，失败则返回-1 strlen()：​ 返回字符串实际长度 scanf(“%s”, s)​ 使用该函数读取字符串，当遇到空格或TAB时，不会将他们读入 竞赛题目选讲例题3-2 WERTYU（WERTYU, UVa10082） 把手放在键盘上时，稍不注意就会往右错一位。这样，输入Q会变成输入W，输入J会变成输入K等。键盘如图3-2所示。输入一个错位后敲出的字符串（所有字母均大写），输出打字员本来想打出的句子。输入保证合法，即一定是错位之后的字符串。例如输入中不会出现大写字A。样例输入：O S, GOMR YPFSU/样例输出：I AM FINE TODAY. 123456789101112#include&lt;stdio.h&gt;char s[] = &quot;`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;'ZXCVBNM,./&quot;;//常量数组，真好！！！int main() { int i, c; while ((c = getchar()) != EOF) { for (i = 1; s[i] &amp;&amp; s[i] != c; i++); //找错位之后的字符在常量表中的位置 if (s[i]) putchar(s[i - 1]); //如果找到，则输出它的前一个字符 else putchar(c); } return 0;} 主要是常量数组的使用 输入一个字符串，判断它是否为回文串以及镜像串。输入字符串保证不含数字0。所谓回文串，就是反转以后和原串相同，如abba和madam。所有镜像串，就是左右镜像之后和原串相同，如2S和3AIAE。注意，并不是每个字符在镜像之后都能得到一个合法字符。在本题中，每个字符的镜像如图3-3所示（空白项表示该字符镜像后不能得到一个合法字符）。输入的每行包含一个字符串（保证只有上述字符。不含空白字符），判断它是否为回文串和镜像串（共4种组合）。每组数据之后输出一个空行。样例输入：NOTAPALINDROMEISAPALINILAPASI2A3MEASATOYOTA样例输出：NOTAPALINDROME – is not a palindrome.ISAPALINILAPASI – is a regular palindrome.2A3MEAS – is a mirrored string.ATOYOTA – is a mirrored palindrome. 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;ctype.h&gt;const char* rev = &quot;A 3 HIL JM O 2TUVWXY51SE Z 8 &quot;;const char* msg[] = {&quot;not a palindrome&quot;, &quot;a regular palindrome&quot;, &quot;a mirrored string&quot;,char r(char ch) { if (isalpha(ch)) return rev[ch - 'A'];//如果ch是个字母，就返回ch-'A'(这个的意思就是在rev中的序号) return rev[ch - '0' + 25];}int main() { char s[30]; while (scanf(&quot;%s&quot;, s) == 1) { int len = strlen(s);//读取字符串实际长度 int p = 1, m = 1; for (int i = 0; i &lt; (len + 1) / 2; i++) {//只要一半符合要求即可确定，因为回文串和镜像串从中间分开，两头都存在一定的关系，因此i &lt; (len + i) / 2 if (s[i] != s[len - 1 - i]) p = 0; //不是回文串,len-1-i实现倒序 if (r(s[i]) != s[len - 1 - i]) m = 0; //不是镜像串 } printf(&quot;%s -- is %s.\\n\\n&quot;, s, msg[m * 2 + p]); } return 0;} 头文件ctype.h中定义的isalpha，isdigit，isorint可以用来判断字符的属性，toupper，tolower可以用来转换大小写 例题3-4 猜数字游戏的提示（Master-Mind Hints, UVa 340） 实现一个经典”猜数字”游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确（A），有多少数字在两个序列都出现过但位置不对（B）。输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。 样例输入：41 3 5 51 1 2 34 3 3 56 5 5 16 1 3 51 3 5 50 0 0 0101 2 2 2 4 5 6 6 6 91 2 3 4 5 6 7 8 9 11 1 2 2 3 3 4 4 5 51 2 1 3 1 5 1 6 1 91 2 2 5 5 5 6 6 6 70 0 0 0 0 0 0 0 0 0 样例输出：Game 1:(1,1)(2,0)(1,2)(1,2)(4,0)Game 2:(2,4)(3,2)(5,0)(7,0) 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#define maxn 1010int main() { int n, a[maxn], b[maxn]; int kase = 0; while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) { //n=0时输入结束 printf(&quot;Game %d:\\n&quot;, ++kase); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);//读入答案 for (;;) { int A = 0, B = 0; for (int i = 0; i &lt; n; i++) { scanf(&quot;%d&quot;, &amp;b[i]);//读入用户猜的序列 if (a[i] == b[i]) A++; //相同位置，且相同的用A来记 } if (b[0] == 0) break; //正常的猜测序列不会有0，所以只判断第一个数是否为0即可 for (int d = 1; d &lt;= 9; d++) { int c1 = 0, c2 = 0; //统计数字d在答案序列和猜测序列中各出现多少次 for (int i = 0; i &lt; n; i++) { if (a[i] == d) c1++; if (b[i] == d) c2++; } if (c1 &lt; c2) B += c1; else B += c2; }//刘老师真是nb，这里把答案数组和用户数组的每一位拿出来和1-9分别比较，统计每一个数字出现的次数，然后输出两个计数器中值小的一个（一旦小的都大于等于1，就说明两个数列中都含有这个数） 1355 1123 printf(&quot; (%d,%d)\\n&quot;, A, B - A);//B-A总数-位置相同的，就是。。。 } } return 0;} 例题3-5 生成元（Digit Generator, ACM/ICPC Seoul 2005, UVa1583） 如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。 为了节省空间，提升效率，可以一次性把100000内所有数字的生成元计算出来，然后输出时直接调用 一个数的生成元可能有多个 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 100005int ans[maxn];int main() { int T, n; memset(ans, 0, sizeof(ans));//初始化 for (int m = 1; m &lt; maxn; m++) {// int x = m, y = m; while (x &gt; 0) { y += x % 10; x /= 10; }//把x拆分，各项相加 if (ans[y] == 0 || m &lt; ans[y]) ans[y] = m;//把这个数的生成元存到数组里，下标为数字，值为生成元 //有点难理解，可以让m=198自行尝试一下，就会发现其实这个程序是倒着来的，是已知某个数的生成元，然后再计算出这个数 //一个数的生成元是不唯一的，因此需要ans[y] == 0 || m &lt; ans[y]进行限制 } scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\\n&quot;, ans[n]); } return 0;} 例题3-6 环状序列（Circular Sequence, ACM/ICPC Seoul 2004, UVa1584） 长度为n的环状串有n种表示法，分别为从某个位置开始顺时针得到。例如，图3-4的环状串有10种表示： CGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称为”最小表示”。输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是CCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。 我理解能力不行，基本上每个题都要看原题才看得懂（可以上vj上看） 字典序（lexicographical order）：就是字符串在字典中的排序。abc比bcd小，hi比his小，1，2，4，7比1，2，5小 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define maxn 105//环状串s的表示法p是否比表示法q的字典序小int less(const char* s, int i, int ans) { int n = strlen(s); for (int j = 0; j &lt; n; i++) if (s[(i + j) % n] != s[(ans + j) % n]) 1 0/2 1/3 2 return s[(i + j) % n] &lt; s[(ans + j) % n]; return 0; //相等}int main() { int T; char s[maxn]; scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%s&quot;, s); int ans = 0; int n = strlen(s); for (int i = 1; i &lt; n; i++) if (less(s, i, ans)) ans = i; for (int i = 0; i &lt; n; i++) putchar(s[(i + ans) % n]); putchar('\\n'); } return 0;} 习题习题3-1 得分（Score, ACM/ICPC Seoul 2005, UVa1585）题目地址：https://vjudge.net/problem/UVA-1585 123456789101112131415161718192021#include&lt;stdio.h&gt;int main(int argc, char const *argv[]){ int T; char x; scanf(&quot;%d&quot;, &amp;T); while (T--) { int i = 0, res = 0, temp = 1; while ((x = getchar()) != '\\n') { if (x = 'O') { res += temp; temp++; } else { temp = 1; } } } printf(&quot;%d\\n&quot;, res); return 0;} 习题3-2 分子量（Molar Mass, ACM/ICPC Seoul 2007, UVa1586）又臭又长的烂代码，但是至少可以安慰自己这个代码好理解把，哈哈哈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;#include&lt;string.h&gt;const float ex[] = {67, 12.01, 72, 1.008, 79, 16.00, 78, 14.01} ;int main(int argc, char const *argv[]){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { char s[100]; scanf(&quot;%s&quot;, s); int len = strlen(s); double res = 0.0; for (int i = 0; i &lt; len; i++) { if (isalpha(s[i])) { if (!isalpha(s[i + 1]) &amp;&amp; i + 1 &lt; len) { int n = 1; while (!isalpha(s[i + n]) &amp;&amp; i + n &lt; len) { n++; } int temp1 = 1, temp2 = 0; for (int j = i + n - 1; j &gt; i; j--) { temp2 += (s[j] - 48) * temp1; temp1 *= 10; } for (int j = 0; j &lt; 8; j++) { if (s[i] == ex[j]) { res += ex[j + 1] * temp2; break; } } } else { for (int j = 0; j &lt; 8; j++) { if (s[i] == ex[j]) { res += ex[j + 1]; break; } } } } } printf(&quot;%.3lf\\n&quot;, res); } return 0;} 这题考察的应该是ctype.h里的函数的应用，isalpha，isdigit，当时没想到isdigit这个函数，所以写的比较复杂 在vj的评论区看到了29行的代码，牛皮 习题3-3 数数字（Digit Counting , ACM/ICPC Danang 2007, UVa1225）1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;char x[10010];int main(int argc, char const *argv[]){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { for (int i = 0; i &lt;= 10005; i++) { x[i] = i; } int d; scanf(&quot;%d&quot;, &amp;d); int q = 0, w = 0, e = 0, r = 0, t = 0, y = 0, u = 0, j = 0, o = 0, p = 0; for (int i = 1; i &lt;= d; i++) { int temp = i; while (temp) { switch (temp % 10) { case 0: q++; break; case 1: w++; break; case 2: e++; break; case 3: r++; break; case 4: t++; break; case 5: y++; break; case 6: u++; break; case 7: j++; break; case 8: o++; break; case 9: p++; break; } temp /= 10; } } printf(&quot;%d %d %d %d %d %d %d %d %d %d\\n&quot;, q, w, e, r, t, y, u, j, o, p); } return 0;} 习题3-4 周期串（Periodic Strings, UVa455）搞我心态。。 ..到网上随便找了个oj，贡献了一发WA，改了改代码，再到vj上就就提交上去了，哈哈哈vj这是为了我好！！！ 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[]){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { char s[100]; scanf(&quot;%s&quot;, s); int len = strlen(s), count = 1; while (count &lt;= len) { int ok = 1; for (int j = 0; j &lt; len ; j++) { if (s[j] != s[j % count] || len % count != 0) { ok = 0; break; } } if (ok) { printf(&quot;%d\\n&quot;, count); break; } count++; } } return 0;} 这个代码在vj上没过，在台湾那个oj上过了，不得不说vj真是严格 调整了一下格式总算AC了 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[]){ int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { char s[100]; scanf(&quot;%s&quot;, s); int len = strlen(s), count = 1; while (count &lt;= len) { int ok = 1; for (int j = 0; j &lt; len ; j++) { if (s[j] != s[j % count] || len % count != 0) { ok = 0; break; } } if (ok) { if (T) { printf(&quot;%d\\n\\n&quot;, count); } else printf(&quot;%d\\n&quot;, count); break; } count++; } } return 0;} 习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）这个代码没AC，格式有问题 写了一中午，在vj上获得两发persentation error之后脑子炸裂决定放弃 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc, char const *argv[]){ int count = 0; int tag = 1; while (1) { char f[5][5],temp; int x,y; count++; for (int i = 0; i &lt; 5; i++) { for (int j = 0; j &lt; 5; j++) { if((temp = getchar()) != '\\n'){ if (temp == 'Z') return 0; f[i][j] = temp; if (f[i][j] == ' ') { x = i; y = j; } } else j--; } } char op = '0'; int ok = 1; while ((op = getchar()) != '0') { switch (op) { case 'A': if (x-1 &gt;= 0 ) {f[x][y] = f[x-1][y]; f[x-1][y] = ' '; x = x - 1;} else ok = 0; break; case 'B': if (x+1 &lt; 5 ) {f[x][y] = f[x+1][y]; f[x+1][y] = ' '; x = x + 1;} else ok = 0; break; case 'L': if (y-1 &gt;= 0) {f[x][y] = f[x][y-1]; f[x][y-1] = ' '; y = y - 1;} else ok = 0; break; case 'R': if (y + 1 &lt; 5) {f[x][y] = f[x][y+1]; f[x][y+1] = ' '; y = y + 1;} else ok = 0; break; default: break; } } int isfil = 1, isfic = 1; if (ok) { if(tag){ printf(&quot;Puzzle #%d:\\n&quot;, count); tag = 0; } else printf(&quot;\\nPuzzle #%d:\\n&quot;, count); for (int i = 0; i &lt; 5; i++) { if(!isfil) isfic = 1; else isfil = 0; for (int j = 0; j &lt; 5; j++) { if (isfic) { printf(&quot;%c&quot;, f[i][j]); isfic = 0; } else printf(&quot; %c&quot;, f[i][j]); } printf(&quot;\\n&quot;); } } else{ if(tag){ printf(&quot;Puzzle #%d:\\n&quot;, count); printf(&quot;This puzzle has no final configuration.\\n\\n&quot;); tag = 0; } else { printf(&quot;\\nPuzzle #%d:\\n&quot;, count); printf(&quot;This puzzle has no final configuration.\\n\\n&quot;); } } } return 0;} 函数和递归例题4-3 救济金发放（The Dole Queue, UVa 133） n(n&lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3列。 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#define maxn 25int n, k, m, a[maxn];//逆时针走t步，步长是d（-1表示顺时针走），返回新位置int go(int p, int d, int t) { while(t--) {//走t布 do { p = (p+d+n-1) % n + 1; //循环数组 } while(a[p] == 0); //走到下一个非0数字，是零的说明那个人都已经走了 }return p;}int main() { while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m) == 3 &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) a[i] = i;//循环，初始化数组 int left = n; //还剩下的人数 int p1 = n, p2 = 1; while (left) { p1 = go(p1, 1, k);//从p1开始，逆时针遍历数组 p2 = go(p2, -1, m);//顺时针 printf(&quot;%3d&quot;, p1); //输出函数的返回值 left--;//剩余人数-1 if (p2 != p1) { //如果不是同一人 printf(&quot;%3d&quot;, p2); //再打印第二个人 left--; //人数-1 } a[p1] = a[p2] = 0;//赋为0，表示两人已离开，不参与下次循环，遇到就直接跳过 if (left) printf(&quot;,&quot;);//最后一个不打印， } printf(&quot;\\n&quot;); } return 0;} 例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）C++和STL引用(与指针类似比指针弱)直接再参数名之前加上一个&amp;，再函数内修改参数的值，也会修改函数的实参 123456789101112#include&lt;iostream&gt;using namespace std;void swap2(int&amp; a, int&amp; b) {//直接在参数名之前加一个&quot;&amp;&quot;，即可 int t = a; a = b; b = t;}int main() { int a = 3, b = 4; swap2(a, b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\\n&quot;; return 0;} 字符串C++中提供了一个string类型使处理字符数组更加简便，cin/cout可以直接读写string，还可以像整数一样相加 输入数据的每行包含若干个（至少一个）以空格隔开的整数，输出每行中所有整数之和。如果只能使用字符与字符数组，一般有两种方案：一是使用getchar( )边读边算，代码较短，但容易写错，并且相对较难理解(5)；二是每次读取一行，然后再扫描该行的字符，同时计算结果。如果使用C＋＋，代码可以很简单。 1234567891011121314#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int main() { string line; while (getline(cin, line)) { int sum = 0, x; stringstream ss(line); while (ss &gt;&gt; x) sum += x; cout &lt;&lt; sum &lt;&lt; &quot;\\n&quot;; } return 0;} string类在string头文件中，而stringstream在sstream头文件中 STL一个总结 对于需要输入多组数据的题目，当第一组数据处理完之后，一定要及时初始化各种变量，因此，定义变量时，尽量把变量定义在需要用的地方的附近。 对于一些需要特定格式的题目，例如需要使用空格隔开字母，但最后一个字母后不能有空格，如果直到一共可以输出多少个，既可以做一个判断，最后一个字母后不接空格，如果不知道要输出多少个，可以把空格放在每个字母之前，对第一个进行特殊化","link":"/2020/03/23/string/"},{"title":"数据结构-树（Tree）学习笔记","text":"[TOC] 树（Tree）n个节点构成的有限集合 n = 0时，称为空树 非空树有以下性质： 树中有一个称为”根（Root）”的节点，用r表示 其余节点互不相交且有限，其中每个集合本身又是一棵树，称为原树的子树(SubTree) 子树是不相交的 除根节点外，每个节点有且仅有一个父节点 这些都不是树 一棵N个节点的树有N-1条边 树的一些基本术语 节点的度(Degree)：节点的子树个数 树的度：树的所有节点中最大的度数（上面那个树的度为3） 叶结点（Leaf）：度为零的节点，即没有子树 父结点（Parent）：有子树的节点是其子树的根节点的父节点 子结点（Child） 兄弟结点（Sibling）：具有同一父节点的各节点彼此 路径和路径长度： 祖先节点（Ancestor）：沿树根到某一结点路径上的所有结点都是这个节点的祖先结点，比如从A到L，ABG都是L的祖先结点 子孙结点（Descendant） 结点的层次（Level）：规定根结点在1层，其他任一结点的层数是其父结点层数+1， 树的深度（Depth）：树中所有结点中的最大层次就是这棵树的深度 树的表示为了节省空间和方便这里使用兄弟-儿子表示法 兄弟-儿子表示法 Element FirstChild NextSibling 链表的每个结点如上图 链接起来后如下图 这样的树被称为二叉树 二叉树（Binary Tree）二叉树的定义二叉树是一个有穷的结点集合 这个集合可以为空 若不为空，则它是由根节点和称为其左子树和右子树的两个不相交的二叉树组成 二叉树的五种基本形态 空树 只有根 只有左子树 只有右子树 左右子树都有 二叉树和其他度为2的树的不同在于二叉树的子树有左右顺序之分 特殊的二叉树 斜二叉树（Skewed Binary Tree） 只有左子树或只有右子树 完美二叉树（Perfect Binary Tree）/满二叉树（Full Binary Tree） 完全二叉树（Complete Binary Tree） 有n个结点的二叉树，对树中的结点按上图所示方式编号，编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同 将完美二叉树的叶结点，从有往左依次删除任意个数，所形成的二叉树就是完全二叉树 下图就不是一个完全二叉树 二叉树的几个性质 一个二叉树第i层的最大结点数为：2^(i-1) , i &gt;= 1 深度为k的二叉树有最大结点总数为：2^k - 1 ,k &gt;= 1 完美二叉树可以达到2^k - 1个结点 对于任何非空二叉树T，若n0表示叶节点的个数、n2是度为2的非叶结点个数，那么n0 = n2 + 1 二叉树的抽象数据类型定义类型名称：二叉树数据对象集：​ 一个有穷结点集合。 ​ 若不为空，则有根节点和其左、右二叉树组成 操作集： Boolean IsEmpty(BinTree BT):判断二叉树是否为空 void Traversal(BinTree BT):遍历，按某种顺序访问每个结点 void PreOrderTraversal(BinTree BT):先序-根、左子树、右子树 void InOrderTraversal(BinTree BT):中序—左子树、根、右子树 void PostOrderTraversal(BinTree BT):后序—左子树、右子树、根 void LevelOrderTraversal(BinTree BT):层次遍历，从上到下、从左到右 BinTree CreatBinTree():创建二叉树 二叉树的存储结构1. 顺序存储结构完全二叉树可以方便的使用数组实现 共n个结点 结点 A B C D E 序号 1 2 3 4 5 非根结点（i &gt; 1）的父结点的序号是i/2 结点（i）的左孩子结点序号是2i（2i &lt;= n，否则没有左孩子） 结点（i）的右孩子结点的序号是2i+1（2i+1 &lt;= n,否则没有右孩子） 一般二叉树也可以使用数组实现，但是会造成空间浪费 2. 链表存储结点的结构：|Left|Data|Right| 1234567typedef struct TreeNode *BinTree;typedef BinTree Position;struct TreeNode{ ElementType Data; BinTree Left; BinTree Right;}; 二叉树的遍历 遍历（递归） 简单但是浪费空间 先序遍历 遍历过程 访问根节点 先序遍历其左子树 先序遍历其右子树 看了这个图可能能更好地理解递归的过程 这个图更好，注意看箭头 1234567void PreOrderTraversal(BinTree BT){ if(BT){ printf(&quot;%d&quot;,BT-&gt;Data);//打印这个结点的数据 PerOrderTraversal(BT-&gt;Left);//递归地遍历左子树 PerOrderTraversal(BT-&gt;Right); }} 中序遍历 中序遍历其左子树 访问其根节点 中序遍历其右节点 12345678void InOrderTraversal(BinTree BT){ if(BT){ InOrderTraversal(BT-&gt;Left);//递归地遍历左子树 printf(&quot;%d&quot;,BT-&gt;Data);//打印这个结点的数据 InOrderTraversal(BT-&gt;Right); }} 后序遍历 后序遍历其左节点 后序遍历其右节点 访问根节点 12345678void PostOrderTraversal(BinTree BT){ if(BT){ PostOrderTraversal(BT-&gt;Left);//递归地遍历左子树 PostOrderTraversal(BT-&gt;Right); printf(&quot;%d&quot;,BT-&gt;Data);//打印这个结点的数据 }} 以上三种遍历过程，经过结点的路线一样，只是访问各结点的时机不同 遍历（非递归） 中序遍历（第二次碰到结点就printf） 遇到一个结点，就把它压栈，并去遍历它的左子树 当左子树遍历结束后，就从栈顶弹出这个结点并访问它 然后按其右指针再去中序遍历该节点的右子树 12345678910111213141516void InOrderTraversal(BinTree BT){ BinTree T = BT; Stack S = CreatStack(MaxSize); //创建并初始化堆栈 while(T || !IsEmpty(S)){//循环结束只要满足结点为空且堆栈为空 while(T){ //一直循环直至结点为空 Push(S,T);//把结点压入堆栈 T = T-&gt;Left; //指针转到下一个左边的结点 } if(!IsEmpty(S)){ //如果堆栈不空的话就开始Pop T = Pop(S); //把栈顶元素给T，并Pop printf(&quot;%5d&quot;,T-&gt;Data); //打印结点数据 T = T-&gt;Right; //准到根节点的右子树 } } } 先序遍历（第一次碰到结点就printf） 由于走过的路径相同，只需要改变访问结点的时机就可以在中序遍历的基础上实现先序遍历 123456789101112131415void InOrderTraversal(BinTree BT){ BinTree T = BT; Stack S = CreatStack(MAxSize); while(T || !Empty(S)){ while(T){ Push(S,T); printf(&quot;%5d&quot;,T-&gt;Data);//与中序遍历的区别就在printf的位置 T = T-&gt;Left; } if(!IsEmpty(S)){ T = Pop(S); T = T-&gt;Right; } }} 后序遍历（第三次碰到结点再printf） 层序遍历 二叉树遍历的核心问题：二维结构的线性化 问题在于当你访问完一个结点的左儿子或右儿子之后，剩下的一个儿子怎么办？如果没有存储右儿子或者自己，那么这些结点就丢失了，所以需要一种方法保存该节点或保存他的父结点 **总的来说就是我们需要一个存储结构保存暂时不访问的结点** 这里使用队列解决问题 - 先把根入队 - 根出队，并且让它的两个儿子入队，左儿子现右儿子后 - 依次让队列里的结点出队，并且让他的儿子入队 - 重复，直至队列空 123456789101112void LevelOrderTraversal(BinTree BT){ Queue Q; BinTree T; Q = CreatQueue(MaxSize); //创建并初始化队列 Add(Q,BT); //让根入队 while(!IsEmpty(Q)){ //队列不空就一直循环 T = Delete(Q); //队首的出队，并记录队首的地址 printf(&quot;%d\\n&quot;,T-&gt;Data); if(T-&gt;Left) Add(Q,T-&gt;Left); //左儿子入队 if(T-&gt;Right) Add(Q,T-&gt;Right); //右儿子入队 }} 二叉树遍历的应用二叉树的同构一个二叉树可以通过n次左右树交换就能变得和另一个一样，就称俩数同构 二叉搜索树（Binary Search Tree）满足： 非空左子树的所有键值小于其根节点的键值 右子树大于根节点 左右子树都是搜索二叉树 操作集Position Find(ElementType X,BinTree BST):查找X，返回结点的地址 Position FindMin(BinTree BST)：返回最小元素结点并返回 Position FindMax(BinTree BST)：最大 BinTree Insert(ElementType X,BinTree BST)：插入X BinTree Delete(ElementType X,BinTree BST)：删除X Find()思路： 从根节点开始，如果树为空返回NULL 非空就和X进行比较 若小于根就在左子树继续查找 大于则就在右子树里查找 相等就返回指针 递归实现 123456789Position Find (ElementType X,BinTree BST){ if(!BST) return NULL;//若数为空就返回NULL if(x &gt; BST-&gt;Data) return Find(X,BST-&gt;Right); //递归地调用Find，进入右子树继续查找 else if(X &lt; BST-&gt;Data) return Find(X,BST-&gt;Left); else return BST;//相等时返回该节点的指针} 循环实现 1234567891011Position IterFind(ElementType X,BinTree BST){ while(BST){ if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else return BST; } return NULL;} FindMin()&amp;FindMax() 递归实现 1234567Position FindMin(BinTree BST){ if(!BST) return NULL;//空就返回NULL else if(!BST-&gt;Left)//如果左子树为空，说明到最小回 return BST; else return FindMin(BST-&gt;Left);//不为空，就进入左子树} 循环实现 12345Position FindMax(BinTree BST){ if(BST)//找到空为止 while(BST-&gt;Right) BST = BST-&gt;Right; return BST;} Insert() 关键是找到插入的位置 123456789101112131415BinTree Insert(ElementType X,BinTree BST){ if(!BST){//若原树为空，则生成并返回一个结点 BST = malloc(sizeof(struct TreeNode)); BST-&gt;Data = x; BST-&gt;Left = BST-&gt;Right = NULL; } else{ if(x &lt; BST-&gt;Data) BST-&gt;Left = Insert(X,BST-&gt;Left);//递归，找出正确位置，赋值 else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(X,BST-&gt;Right); //else 若X已经存在，那什么都不用做 return BST; }} Delete() 有三种情况 叶结点，直接让他的父结点指向NULL 只有一个孩子，直接用它的儿子替代它‘ 有两个孩子， 1234567891011121314151617181920212223BinTree Delete(ElementType X,BinTree BST){ Position Tmp; if(!BST) printf(&quot;要删除的元素未找到&quot;); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(X,BST-&gt;Left);//递归 else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(X,BST-&gt;Right);//这两个else if都是查找的过程 else//找到后 if(BST-&gt;Left &amp;&amp; BST-&gt;Right){//判断结点的类型 Tmp = FindMin(BST-&gt;Right);//找到右子树中最小的结点 BST-&gt;Data = Tmp-&gt;Data;//用找到的那个结点替换要删除的结点 BST-&gt;Right=Delete(BST-&gt;Data,BST-&gt;Right);//删除那个用于替换原结点的结点,不理解为什么，有赋值这个操作 } else{ Tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else if(!BST-&gt;Right) BST = BST-&gt;Left; free(Tmp); } return BST;} 平衡二叉树查找效率高 平衡因子（Blance Factor，BF）：BF(T) = hL-hR hL,hR分别为T的左右子树的高度 平衡二叉树(Blance Binary Tree)(AVL树) 空树 任意结点左右子树高度差的绝对值不超过1 平衡二叉树的调整给树插入结点时，有可能会破坏树的平衡，因此需要调整 平衡二叉树还是一个搜索二叉树，因此在调整过程中，依然要保持搜索二叉树的特性 堆优先队列(Priority Queue):特殊的队列，取出元素的顺序按照元素的优先权（关键字）大小 两个特性： 结构性：用数组表示的完全二叉树 有序性：任意结点的关键字是其子树所有结点的最大值或最小值 最大堆（MaxHeap）也称大顶堆 最小堆（MinHeap）也称小顶堆 操作集MaxHeap Create(int MaxSize) Boolean IsFull(MaxHeap H) Inser(MaxHeap H,ElementType item) Boolean IsEmpty(MaxHeap H) ElementType DeleteMax(MaxHeap H) 123456typedef struct HeapStruct *MaxHeap;struct HeapStruct{ ElementType *ElementType;//储存堆元素的数组 int Size;//堆当前元素的个数 int Capacity;//堆的最大容量} 12345678MaxHeap Create(int MaxSize){ MaxHeap H = malloc(sizeof(struct HeapStruct));//申请一块空间给H H-&gt;Elements = malloc((MaxSize+1)*sizeof(ElementType));//申请一块数组空间 H-&gt;Size = 0;//初始为零，当前元素个数 H-&gt;Capacity = MaxSize;//初始为MaxSize，堆的最大容量 H-&gt;Element[0] = MaxDate;//哨兵，方便以后访问 return H; } 123456789101112void Insert(MaxHeap H,ElementType item){ int i; if(IsFull(H)){ printf(&quot;满&quot;); return; } i = ++H-&gt;Size;//i指向插入后堆中的最后一个元素,插入后Size++ for(;H&gt;Elements[i/2] &lt; item;i/=2)//插入时结点放在最后，然后依次与他的父结点进行比较，直到父结点大于他为止 H-&gt;Elements[i] = H-&gt;Elements[i/2];//大于就和父结点互换位置 H-&gt;Elements[i] = item; //完全二叉树中，一个结点的序号/2就是它父结点的序号} 哨兵的一个作用就是，哨兵的值是堆中最大的，无论多大的结点来比较，到哨兵这里就会停止，可以减少一个判断条件i&gt;1，提高效率 基本思路：删除根之后，把树的最后一个节点（保证完全二叉树的特性）挪到根的位置，然后进行调整排序 12345678910111213141516171819ElementType DeleteMax(MaxHeap H){ int Parent,Child; ElementType MaxItem,temp; if(IsEmpty(H)){ printf(&quot;满&quot;); return; } MaxItem = H-&gt;Elements[1];//把要删除的结点存起来，一会儿返回出去 temp = H-&gt;Element[H-&gt;Size--];//把最后一个结点存起来，然后Size-- for(Parent = 1;Parent*2&lt;=H-&gt;Size;Parent=Child){//从根节点开始循环，每次循环完后进入下一层的左节点，如果Parent*2&lt;=H-&gt;Size说明，下一层没有节点了 Child = Parent*2;//进入下一层的左节点 if((Child!=H-&gt;Size)&amp;&amp;(H-&gt;Element[Child]&lt;H-&gt;Elements[Chile+1]))//Child!=H-&gt;Size保证进入这个判断的结点都有两个儿子，(H-&gt;Element[Child]&lt;H-&gt;Elements[Chile+1])默认左节点大于右节点，如果小于就Child++ Child++; if(temp &gt;= H-&gt;Element[Child]) break;//如果temp大于这个节点的最大子节点那么说明位置正确 else H-&gt;ElementS[Parent] = H-&gt;Elements[Child];//交换两节点位置 } H-&gt;Element[Parent] = temp; return MaxItem;} 建立最大堆 方法： 通过Insert操作，将元素一个一个插进去（O(NlogN)） 在线性时间复杂度下建立最大堆 将N个元素按顺序存入，先满足完全二叉树的特性 调整各节点位置，以满足有序特性 如何调整 哈夫曼树（最优二叉树）（Huffman Tree）带权路径长度（WPL）：设二叉树有n个叶结点，每个叶结点带有权值Wk，从根节点到每个叶结点的长度为Lk，WPL=每条路径长度乘权值的和 哈夫曼树：WPL最小 哈夫曼树的构造思路:把所有元素按权值排列，然后拿出两个权值最小的合并成一个二叉树，然后再找两个最小的合并，直到合并完 12345678910111213141516171819typedef struct TreeNode *HuffmanTree;struct TreeNode{ int Weight; HuffmanTree Left,Right;}HuffmanTree Huffman(MinHeap H){//假设H-&gt;Size的权值已经存在H-&gt;Element[]-&gt;Weight里 int i; HuffmanTree T; BulidMinHeap(H); //将H-》ElementS[]按权值调整为最小堆 for(i = 1;i&lt;H-&gt;Size;i++){ T = malloc(sizeof(struct TreeNode));//建一个新结点，存放新组成的树 T-&gt;Left = DeleteMin(H); T-&gt;Right = DeleteMin(H);//从堆里拿出俩元素，进行组合 T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; Insert(H,T);//把组合后的树插入最小堆 } T = DeleteMin(H); return T;} 特点： 没有度为1的结点 n个叶结点的哈夫曼树共有2n-1个结点 任意非叶结点的左右子树交换后仍是哈夫曼树 同一组权值存在不同构的两颗哈夫曼树 哈夫曼编码为了将字符的存储空间降到最小还要避免二义性，就可以使用哈夫曼编码（编码不等长） 方法： 将每个字符出现的次数作为权值 创建一个哈夫曼树，保证每个字符都在叶结点上就不会出现二义性 集合并查集：集合并，查某元素属于那个集合 存储实现：用树结构（并非二叉树），树的每个结点代表一个元素 用是链表实现 数组： 数组的每个分量都是一共结构，包含结点的值和父结点的下标，没有父结点则记为-1 1234typedef struct{ ElementType Data; int Parent;}SetType; 查 12345678int Find(SetType s[],ElementType X){ int i; for(i = 0;i &lt; MaxSize &amp;&amp; S[i].Data != X;i++);//循环查找X，找到后退出时i的值就是该节点的下标或没找到 if(i &gt;= MaxSize) return -1;//判断属于以上那种情况 for(;s[i].Parent &gt;= 0;i = s[i].Parent);//查找这个结点的根结点，退出时就是i是根节点的下标 return i ;} 并 分别找到两个集合的根节点 若不同根就设置一个集合的根节点的父结点为另一个集合的根节点 123456void Union(SetType s[],ElementType X1,ElementType X2){ int Root1,Root2; Root1 = Find(S,X1); Root2 = FInd(S,X2); if(Root1 != Root2) s[Root2].Parent = Root1;} ​ 如果总是这样插的话可能会导致树越来越高，所以考虑将结点少的插到结点多的树底下 这使就需要考虑如何存储一个树的结点个数，如果在结构中再创建一个变量的话，由于只有根节点需要存储数据，会造成空间浪费，所以考虑继续使用本来的数组存储，可以使用原来标记结点为根节点的空间来存储，有x个结点就在数组中存为-x，到时候只需要判断正负就可以。","link":"/2020/03/09/tree/"},{"title":"我是如何实现易班自动打卡的？","text":"需要用到的工具 HttpCanary 抓包 先进入易班，然后退出登录，方便我们一会记录整个登录和打卡的过程 打开HttpCanary将易班添加为目标程 开始抓包 完成从登录易班到打卡完成的整个过程的抓包 分析我们倒着来分析 抓到了很多数据包，但是音频和图片js…文件是我们不需要的，因此进行过滤保留这三种数据包即可 开始一个一个分析，发现一个数据包很可疑，打开一看这不就是我们提交的表单吗 验证猜想，重发这个请求，返回消息如下，可以确定这就是我们要找的数据包 猜想是否可以依靠每天自动重发这个请求实现签到，答案是否定的，是什么原因呢 分析该请求的请求头，发现这里有一个Cookie，有两个字段 12client=androidPHPSESSID=96098a2d53fdfef072b13f7113da5e17 第一个不用说，第二个就是罪魁祸首，一看这名字就知道肯定和SESSION有关，百度一下 好了这下目标明确，寻找是谁第一次Set了这个Cookie，筛选，好了就是他，理论上我们只要，发送一下这个请求就可以拿到Cookie 问题又来了，这些又是啥？？？继续往下看 首先猜测一下这个act=iappxxxxx应该是易班小程序的ID，那么OK，他是不会变的，记住就行了，那么这个v是什么？看了看他的前一个请求发现就是access_token 好了继续寻找access_token 拉到最下面，第一个请求应该就是登录的请求，查看他的响应信息果然access_token就在里面 至此，抓包数据分析完成 总结： 登录拿到access_token 拿着access_token去获得Cookie 拿着Cookie提交表单 完成 代码以下使用java，使用Hutool进行Http请求、json解析等等等 获取Access_token 1234567891011121314151617181920212223242526272829public static CommonResult getAccess_token(String username, String password){ //设置请求参数 HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;account&quot;,username); map.put(&quot;passwd&quot;,password); map.put(&quot;ct&quot;,1); map.put(&quot;identify&quot;,0); map.put(&quot;v&quot;,&quot;4.7.4&quot;); //获取返回的字符串 String jsonStr = HttpUtil.get(&quot;https://mobile.yiban.cn/api/v2/passport/login&quot;,map); //把获取到的字符串转换为JSONObject对象 JSONObject jsonObject = JSONUtil.parseObj(jsonStr); //try catch一下，以防获取到一些奇奇怪怪的东西 try { //比较状态码，是否登陆成功 if (jsonObject.get(&quot;response&quot;).equals(&quot;100&quot;)){ String res = ((JSONObject) jsonObject.get(&quot;data&quot;)).getStr(&quot;access_token&quot;); return CommonResult.success(res,&quot;拿到数据了&quot;); } else { return CommonResult.failed(&quot;登录失败&quot;); } } catch (Exception e){ e.printStackTrace(); return CommonResult.failed(&quot;易班返回的Json数据可能有变化&quot;); } } 获取Cookie 1234567891011121314151617181920public static CommonResult getPHPSESSID(String access_token){ //请求数据 HashMap&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;act&quot;,&quot;iapp610661&quot;); map.put(&quot;access_token&quot;,access_token); //发送请求，从cookie中获取PHPSESSIONID HttpResponse response = HttpRequest .get(&quot;http://f.yiban.cn/iapp/index&quot;) .form(map) .setFollowRedirects(true) .execute(); try { String res = response.header(&quot;Set-Cookie&quot;); return CommonResult.success(res,&quot;成功获取SESSID&quot;); } catch (NullPointerException e) { System.out.println(response.toString()); return CommonResult.failed(&quot;没获取到SESSID&quot;); } } 提交表单 1234567891011121314151617public static CommonResult submit(String cookie, String content){ HttpResponse response = HttpRequest.post(&quot;http://yiban.sust.edu.cn/v4/public/index.php/Index/form/add.html?id=9&quot;) .contentType(&quot;application/x-www-form-urlencoded&quot;) .body(content) .cookie(cookie) .execute(); JSONObject jsonObject = JSONUtil.parseObj(response.body()); try { if (jsonObject.get(&quot;code&quot;).equals(&quot;1&quot;)){ return CommonResult.success(jsonObject.getStr(&quot;msg&quot;)); } else { return CommonResult.failed(jsonObject.getStr(&quot;msg&quot;)); } } catch (NullPointerException e){ return CommonResult.failed(e.getMessage()+ &quot;没找到返回的code，奇了怪了&quot;); } } 发送邮件(不得不说Hutool就是好用) 1MailUtil.send(&quot;你的邮箱&quot;,标题,内容,是否为html(boolean));","link":"/2020/07/28/yiban-auto-checkin/"}],"tags":[{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"cors","slug":"cors","link":"/tags/cors/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"学习笔记","slug":"学习笔记","link":"/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"spring cloud","slug":"spring-cloud","link":"/tags/spring-cloud/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"mybatis","slug":"mybatis","link":"/tags/mybatis/"}],"categories":[{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C","slug":"C","link":"/categories/C/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"}]}