<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="alternate" type="application/rss+xml" title="Verge's Blog" href="https://jysperm.me/atom.xml"><link rel="stylesheet" href="/styles.css"><title>Verge's Blog</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container"><div class="columns page-header"><h1>Verge's Blog</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="Verge's Blog" src="/favicon.png"></a><a href="/">Home</a></nav><nav class="right menus-right"><a href="/atom.xml">RSS</a><a target="_blank" href="hexo-theme-simpleblock">fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">与精子同款的博客主题 simpleblock 现已发布！</a></div><article><header><h2><a href="/2020/03/09/queue/">队列</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-09</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 队列

只能在一段插入另一端删除

数据对象集：一个有0个或者多个元素的有穷线性表

操作集：

Queue Create(int MaxSize)

int IsFull(Queue Q,int Maxsize)

void Add(Queue Q,ElementType item)

int IsEmpty(Queue Q)

ElementType Delete(Queue Q)

#### 队列的顺序存储实现

为了使空间得到充分的使用**循环队列（当数组满了之后，又从头开始）**

- 如何实现？

由一个一维数组和一个记录队列头元素位置的变量**front**和一个记录队列尾元素位置的变量**rear**

插入元素时rear前移一位，删除元素时front前移一位

- 如何判断队列是空还是满？

用front和rear之间的距离来判断，当front和rear相差1时，队列满

为什么不是front和rear相等时未满？

相等时由两种状态，有可能为空也有可能满。

当然这个问题可以引入一个标记来解决：

1. 引入Size

每次Add时+1，Delete时-1，当Size为0是队列为空

2. 引入Tag

Add时Tag = 1，Delete时Tag = 0，当front和rear相等时判断Tag的值即可

<br>

**这里当rear与front相差1时就判断队列满**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 元素最大数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data[NaxSize];</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure>

1.Add

**难点在于如何当rear到MaxSize时再+1就又返回起点**

**这里使用取余，当rear到达最大值时取MaxSize的余，就得到0**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(Queue Q,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(Q))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列满"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>) % MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;rear] = item; <span class="comment">//把item放到数组里</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. Delete

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>)；</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">        <span class="keyword">return</span> Q-&gt;Data[Q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 队列的链式存储实现

使用一个**单链表**实现，插入和删除分别在两头进行，**问题在于front和rear应该分别指向链表的哪一头 **

rear需要插入数据需要放在链表的尾部，插入时只需要前一个节点的地址，front要在链表的头部的的下一个节点，方法与堆栈类似

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line">Queue PtrQ;</span><br></pre></td></tr></table></figure>

1. Delete

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">(Queue PtrQ)</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span></span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front == <span class="literal">NULL</span>)&#123;<span class="comment">//若头节点之后没有节点则队列时空的</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列空"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FrontCell = PtrQ-&gt;front;<span class="comment">//储存第二个节点</span></span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front == PtrQ-&gt;rear) <span class="comment">//若队列只有一个元素</span></span><br><span class="line">        PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>; <span class="comment">//则删除完后队列置空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        PrtQ-&gt;front = ptrQ-&gt;rear-&gt;Next;<span class="comment">//</span></span><br><span class="line">    FrontElem = Front-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>(FrontCell);</span><br><span class="line">    <span class="keyword">return</span> FrontElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. Add

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(Queue PtrQ,ElementType item)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">TempCell</span>;</span><span class="comment">//创建新节点</span></span><br><span class="line">    TempCell = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));<span class="comment">//申请空间</span></span><br><span class="line">    TempCell-&gt;Data = item;</span><br><span class="line">    PtrQ-&gt;rear-&gt;Next = TempCell;<span class="comment">//将链表与新节点链接起来</span></span><br><span class="line">	PtrQ-&gt;rear = TempCell;<span class="comment">//移动rear </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></article><article><header><h2><a href="/2020/03/06/stack/">堆栈</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-06</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 堆栈

数据对象集：一个有0个或多个元素的有穷线性表

操作集：

1. Stack CreateStack(int MaxSize)
2. bool IsFull(Stacak S,int MaxSize)
3. void Push(Stack S,ElementType item)
4. bool IsEmpty(Stack S)
5. ElementType Pop(Stack S)

<br>

#### 堆栈的顺序存储实现

通常由一个**一维数组**和一个**记录栈顶元素位置的变量**组组成

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 元素最大个数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

1. 创建

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">	Stack S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));<span class="comment">//申请一块空间，存放Stack这个结构</span></span><br><span class="line">    S-&gt;Data = (ElementType *)<span class="built_in">malloc</span>(MaxSize * <span class="keyword">sizeof</span>(ElementType))<span class="comment">//申请一块空间存放MaxSize个ElementType</span></span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;<span class="comment">//初始状态栈顶为-1</span></span><br><span class="line">    S-&gt;MaxSize = MaxSize;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 栈是否满了

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">(Stack S,<span class="keyword">int</span> MaxSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;Top == S-&gt;MaxSize - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

3.栈是否为空

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;Top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

4. Push

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Stack S,ElemenType item)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(S) == <span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈满"</span>)；</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top)] = item; <span class="comment">//Top先加一，在进行运算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**++a是先自加再进行运算，a++是先运算再自加**

5. Pop

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( IsEmpty(S) )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[(S-&gt;Top)--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

#### 用一个数组实现两个堆栈

思路：两个堆栈分别从数组头和尾开始，向中间，当两个顶指针相遇时，表示两个堆栈都满了

​			----->    <-------

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 元素最大个数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DStack</span> *<span class="title">PtrS</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DStack</span>&#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    <span class="keyword">int</span> Top1;</span><br><span class="line">    <span class="keyword">int</span> Top2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

​    S.Top1 = -1    说明栈1空

​    S.Top2 = MaxSize    说明栈2空

1. Push

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(PtrS S,ElementType item,<span class="keyword">int</span> Tag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;Top2 - S-&gt;Top1 == <span class="number">1</span>)&#123;<span class="comment">//两栈相遇时Top相差1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Tag == <span class="number">1</span>)</span><br><span class="line">        S-&gt;Data[++(S-&gt;Top1)] = item;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        S-&gt;Data[--(S-&gt;Top2)] = item;<span class="comment">//注意因为堆栈2是倒着来的，所以是--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. Pop

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(PtrS S,<span class="keyword">int</span> Tag)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Tag == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;Top1 == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈1空"</span>)；</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> S-&gt;Data[(S-&gt;Top1)--];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;Top2 == MaxSize)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"堆栈1空"</span>)；</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> S-&gt;Data[(S-&gt;Top2)++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 堆栈的链式存储实现

实际上是单向链表，叫链栈。插入和删除操作只能再链栈的栈顶进行，**栈顶指针应该在链表的表头后其他节点之前**，否则无法进行删除操作，因为前一个节点无法保存上一个节点的指针

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span> <span class="comment">//记录下一个节点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

1. Create

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>&#123;<span class="comment">//构建指针头节点</span></span><br><span class="line">    Stack S;</span><br><span class="line">    S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2.IsEmpty

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Next == <span class="literal">NULL</span>); <span class="comment">//若头节点的Next为NULL则堆栈为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

3. Push

   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType item,Stack S)</span></span>&#123;</span><br><span class="line">    Stack TempCell;</span><br><span class="line">    TempCell = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Struct SNode));</span><br><span class="line">    TempCell-&gt;Data = item;</span><br><span class="line">    TempCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TempCell; <span class="comment">//插到头节点之后其他节点之前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


4. Pop 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆栈空"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Stack TopCell;<span class="comment">//为了找到第三个节点和释放空间而声明的</span></span><br><span class="line">        ElemtType TopElem;</span><br><span class="line">    	TopCell = S-&gt;Next;<span class="comment">//把第二个节点的地址给TopCell</span></span><br><span class="line">    	S-&gt;Next = TopCell-&gt;Next;<span class="comment">//把第三个节点给S的Next，就跳过了第二个节点即删除了第二个节点</span></span><br><span class="line">		TopElem = TopCell-&gt;Element;        </span><br><span class="line">        <span class="built_in">free</span>(TopCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 堆栈的应用

- 中缀表达式转后缀表达式
- 函数调用及递归实现
- 深度优先搜索
- 回溯算法
- .......

</div></article><article><header><h2><a href="/2020/03/03/linerlist/">线性表</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-03</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 什么是线性表

线性表（Linear List）由**同类型**数据元素构成**有序序列**的线性结构

- 表中元素个数称为线性表的**长度**
- 线性表没有元素时，称为**空表**
- 表起始位置称为**表头**，结束位置称为**表尾**

数据对象集：n个元素构成的有序序列  

### 操作集

**L表示一个线性表，整数i表示位置，元素X属于ElementType**

**ElementType表示一种数据类型，可以是整形也可以是实型，也可以是结构**

<br>

List MakeEmpty():初始化一个空线性表

ElementType Findkth(int k,LIst L):返回位序K的元素

int Find(ElementType X,List L):查找X在L内第一次出现的位置

void insert(ElementType X,int i,List L):给L在位序i前插入一个元素X

void Delete(int i,List L):删除L内位序为i的元素

int Lenth(List L):返回L的长度

#### 线性表的顺序存储实现

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>//<span class="title">List</span>存放该结构的地址</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">LNode</span>&#123;</span><span class="comment">//定义一个名为LNode的结构</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> Last;<span class="comment">//线性表最后一位的位序</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span> <span class="comment">//声明一个结构体</span></span><br><span class="line">List PtrL; <span class="comment">//声明该结构体的指针</span></span><br></pre></td></tr></table></figure>

访问下标为i的元素：L.Data[i]或PtrL->Data[i]

线性表的长度：L.Last+1或PtrL->Last+1    因为Last从0开始，所以长度为Last+1

**"->"表示取出PtrL指向的结构体中的某个数据，与"."类似，当声明一个指针变量时想要取出该结构体中的数据就需要"->",而声明一个普通的变量是使用"."即可**

#### 主要操作实现

1. 初始化（建立空顺序表）

   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List Ptrl; <span class="comment">//声明该结构体的指针</span></span><br><span class="line">    PtrL = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (struct LNode));</span><br><span class="line">    Ptrl-&gt;Last = <span class="number">-1</span>;<span class="comment">//当表内没有数据时Last为-1</span></span><br><span class="line">    <span class="keyword">return</span> Ptrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


2. 查找  O(n)

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= PtrL-&gt;Last &amp;&amp; PtrL-&gt;Data[i]!= x)&#123;<span class="comment">//循环结束有两个原因一个是i&gt;last说明，找完了还没有，另一个是Data[i] = X说明找到了</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; PtrL-&gt;Last)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

3. 插入（第i（1<=i<=n+1）个位置上插入一个值位X的新元素）

在第i个位置插入实际上就是插在下标位i-1的位置，首先把原来的数据从i-1开始依次向后移（从后往前），然后把数据插到i-1，

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(PtrL-&gt;Last == MAXSIZE<span class="number">-1</span>)&#123; <span class="comment">//判断表的最后一位是否已经到达MAXSIZE，-1是因为表的下标从0开始</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"表满"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; PtrL-&gt;Last+<span class="number">2</span>)&#123; <span class="comment">//或者可以写成（i-1 &lt; 0 || i-1 &gt; PtrL-&gt;Last+1）+1确保还有剩余位置</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置不合法"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = PtrL-&gt;Last;j &gt;= i<span class="number">-1</span>;j++)&#123; <span class="comment">//从最后一位开始，循环到i-1这个位置（O(n)）</span></span><br><span class="line">        Ptrl-&gt;Data[j+<span class="number">1</span>] = Ptrl-&gt;Data[j];<span class="comment">//每个数据往后移动一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    PtrL-&gt;Data[i<span class="number">-1</span>] = X;<span class="comment">//令原本下标为i-1的位置为X</span></span><br><span class="line">    PtrL-&gt;Last++;<span class="comment">//表长+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

4. 删除（第i个位置）

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || PtrL-&gt;Last+<span class="number">1</span>)&#123; <span class="comment">//此处为删除因此不需要保存余量，只需小于Last+1即可</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不存在"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = i;j &lt;= PtrL-&gt;Last;j++)&#123;<span class="comment">//从i+1开始到结束的值都向前移动一位</span></span><br><span class="line">        PtrL-&gt;Data[j<span class="number">-1</span>] = PtrL-&gt;Data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    PtrL-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 线性表链式存储实现

在链表内插入只需要修改链，但是查找第i个元素和查看链表长度就比较复杂

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data;<span class="comment">//存储数据</span></span><br><span class="line">    List Next;<span class="comment">//下一个链表的头。</span></span><br><span class="line">&#125;;</span><br><span class="line">Struct LNode L;</span><br><span class="line">List PrtL;</span><br></pre></td></tr></table></figure>

1. 求表长

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List PtrL)</span></span>&#123;</span><br><span class="line">    List p = PtrL; <span class="comment">//p指向表的第一个节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;<span class="comment">//若返回NULL即到最后一位，则循停止</span></span><br><span class="line">        p = p-&gt;Next; <span class="comment">//指向下一个节点</span></span><br><span class="line">        j++;<span class="comment">//计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 查找

   1. 按序号查找

      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List PtrL)</span></span>&#123;</span><br><span class="line">    List p = PtrL;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//表头为一</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; i &lt; K)&#123;<span class="comment">//第一个条件是表不能到结尾，第二个是刚好遍历到K就停止</span></span><br><span class="line">        p = p-&gt;Next;<span class="comment">//转到下一节点</span></span><br><span class="line">        i++;<span class="comment">//计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == K) <span class="comment">//等于说明找到了</span></span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">//返回该节点的指针</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   2. 按值查找

      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List PtrL)</span></span>&#123;</span><br><span class="line">    List p = Prtl;</span><br><span class="line">    <span class="keyword">while</span>(X != P-&gt;Data &amp;&amp; p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;Data == X)</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
   
3. 插入（在i-1（1<=i<=n+1）个节点后插入一个值为X的新节点）**之所以插入到i-1之后是因为，想给链表插入节点，需要知道前面一个节点的信息**

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List PtrL)</span></span>&#123;<span class="comment">//List PtrL 传入的是表头的指针</span></span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;<span class="comment">//1在表头位置需要特殊处理</span></span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));<span class="comment">//申请一块空间</span></span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = PtrL;<span class="comment">//将这下个节点的Next赋给此节点的Next</span></span><br><span class="line">        <span class="keyword">return</span> s;<span class="comment">//返回表头</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,PtrL);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;<span class="comment">//把i-1的链接给要插入的节点</span></span><br><span class="line">        p-&gt;Next = s;<span class="comment">//把要插入的节点的链接给i-1</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

4. 删除

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List PtrL)</span></span>&#123;</span><br><span class="line">	List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;<span class="comment">//1特殊化</span></span><br><span class="line">        s = PtrL;</span><br><span class="line">        <span class="keyword">if</span>(PtrL!=<span class="literal">NULL</span>) <span class="comment">//查看这个表是否无节点</span></span><br><span class="line">            PtrL = PtrL-&gt;Next; <span class="comment">//是表头变为下一个节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">//释放被删除的节点</span></span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,List PtrL); <span class="comment">//查找第i-1个节点</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)&#123; <span class="comment">//判断输入的i是否在范围内</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d个节点不存在"</span>，i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Next == <span class="literal">NULL</span>)&#123;  <span class="comment">//判断输入的节点是否是表的结尾</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"第%d个节点不存在"</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> PtrL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</div></article><article><header><h2><a href="/2020/03/03/malloc/">malloc()函数的用法/动态内存分配</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-03</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 计算机内存

计算机的内存从高位到低位分别是**系统内核-栈-可自由分配的空间-堆-数据段-代码段**

源代码编译后的二进制文件会加载到内存中的**代码段**

数据段包含了在程序中明确被**初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）**。

> - 栈存储区：
>
> **通常存放程序临时创建的局部变量（但不包括static声明的变量，static意味着在数据段中存放变量）**，即函数括大括号 “{ }” 中定义的变量，其中还包括函数调用时其形参，调用后的返回值等。
>
> 最后栈还具有“小内存、自动化、可能会溢出”的特点。栈顶的地址和栈的最大容量一般是系统预先规定好的，通常不会太大。由于栈中主要存放的是局部变量，而局部变量的占用的内存空间是其所在的代码段或函数段结束时由系统回收重新利用，所以栈的空间是循环利用自动管理的，一般不需要人为操作。如果某次局部变量申请的空间超过栈的剩余空间时就有可能出现 “栈的溢出”，进而导致意想不到的后果。**所以一般不宜在栈中申请过大的空间，比如长度很大的数组、递归调用重复次数很多的函数等等**。
>
> - 堆存储区：
>
> **通常存放程序运行中动态分配的存储空间。**它的大小，并不固定，可动态扩张或缩放。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）/释放的内存从堆中被提出（堆被缩减）。
>
> (堆是低地址向高地址扩展的数据结构，是一块不连续的内存区域。**在标准C语言上，使用malloc等内存分配函数是从堆中分配内存的**
>
> 堆具有“大内存、手工分配管理、申请大小随意、可能会泄露”的特点，堆内存是操作系统划分给堆管理器来管理的，管理器向使用者（用户进程）提供API（malloc和free等）来使用堆内存。需要程序员手动分配释放，如果程序员在使用完申请后的堆内存却没有及时把它释放掉，那么这块内存就丢失了（进程自身认为该内存没被使用，但是在堆内存记录中该内存仍然属于这个进程，所以当需要分配空间时又会重新去申请新的内存而不是重复利用这块内存），就是我们常说的内存泄漏，所以内存泄漏指的是堆内存被泄露了。

<br>

### malloc()用法

#### malloc()函数的原型

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

#### 功能

size应该为整型

分配一个size这么大的内存，返回一个指向这片内存空间的起始位置的一个指针，类型为void*、

若空间不足则或者其他原因没有成功申请到内存则返回NULL

#### 如何使用

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

它的意思是：请求系统分配 **4 字节**的内存空间，并**返回第一字节的地址**，然后赋给指针变量 p。

> 位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。
> 字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示,1B（byte,字节）= 8bit（位）

C 语言中，void* 型可以不经转换（系统自动转换）地直接赋给任何类型的指针变量（函数指针变量除外）。或者自己进行强制类型转换也可以

void\*与void不同，void\* 是定义一个无类型的指针变量，它可以指向任何类型的数据。任何类型的指针变量都可以直接赋给 void* 型的指针变量，无需进行强制类型转换。

**注意，不能对 void* 型的指针变量进行运算操作，如指针的运算、指针的移动等。原因很简单，前面讲int*型的指针变量加 1 就是移动 4 个单元，因为 int\* 型的指针变量指向的是 int 型数据；但是 void\* 型可以指向任何类型的数据，所以无法知道“1”所表示的是几个内存单元。**

### free()

用于释放使用malloc动态分配的内存

#### 原型

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>





**参考**：http://c.biancheng.net/view/223.html

​		    https://blog.csdn.net/weixin_39371711/article/details/81783780</div></article><article><header><h2><a href="/2020/03/02/and-in-C/">C语言中的*和&amp;</a></h2></header><div class="article-meta clearfix"><time class="left">2020-03-02</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *b = &amp;a；</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“%d\n”, a);</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”, b);</span><br><span class="line"><span class="built_in">printf</span>(“%d\n”, *b);</span><br></pre></td></tr></table></figure>

结果：
10
6487620
6487620
10

**为什么&a和*b的值不是一样？**



变量a 本质上代表一个存储单元。CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。于是就有了二异性。

**为了消除这种二义性，C语言规定a表示存储单元中的数据，&a表示存储单元的地址。**
a存储单元中的数据可以是一个普通数值，也可以是另一个存储单元的地址，比如：a = &b; 语句就是将b的存储单元的地址存入a存储单元中。C语言规定 \*a 代表a中存储的地址对应的存储单元中的数据，也就是访问\*a就等于访问b，于是*a提供了通过a访问b中的数据的手段。

a表示a对应的存储单元中的数据。
&a表示a对应的存储单元的地址。

\*a表示：首先，要求a对应的存储单元中的数据一定是另一个存储单元的地址。
于是，\*a表示另一个存储单元中的数据。
当a声明的类型是int时，a中存储的是一个整数数值，通过a可以访问（读取或修改）这个数值。
**当a声明的类型是int\*时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是一个整数数值；通过\*a可以访问（读取或修改）这个数值。a == &\*a 都是该存储单元的地址。**
当a声明的类型是int\*\*时，a中存储的是一个存储单元的地址，而该存储单元中存储的数据是另外一个存储单元的地址，另外这个存储单元中存储的是一个整数数值；通过\*\*a可以访问（读取或修改）这个数值。
最后，在C语言里地址叫指针。还有，在C语言中的数组本质上其实也是指针，即：*a 等同于 a[]。
————————————————
版权声明：本文为CSDN博主「kiraliam」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_27445903/article/details/82563059</div></article><article><header><h2><a href="/2020/02/13/struct/">结构</a></h2></header><div class="article-meta clearfix"><time class="left">2020-02-13</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
## 结构

### 声明结构类型

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">&#125;;<span class="comment">//声明一种结构，结构内包含year，month，day三个成员</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">//定义一个变量today，这个变量的类型是date</span></span><br></pre></td></tr></table></figure>

**在函数内声明的结构只可以在函数内使用**

### 声明结构的三种形式

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p1</span>,<span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;<span class="comment">//只定义了两个变量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br></pre></td></tr></table></figure>



### 结构的初始化

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span> = &#123;</span><span class="number">2020</span>,<span class="number">02</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">yesterday</span> = &#123;</span>.month = <span class="number">2</span>, .year = <span class="number">2020</span>&#125;;</span><br></pre></td></tr></table></figure>



### 结构成员

结构使用"."来访问成员

today.year = xxxx;

### 结构运算

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = (struct <span class="built_in">point</span>)&#123;<span class="number">5</span>,<span class="number">10</span>&#125;;<span class="comment">//相当于怕p1.x = 5;p2.y = 10; </span></span><br><span class="line">p1 = p2; <span class="comment">//相当于p1.x = p2.x;p1.y = p2.y;</span></span><br></pre></td></tr></table></figure>

### 结构指针

- 与数组不同，结构的变量名并不是结构变量的地址，必须使用&
- struct date *pDate = &today;

## 结构与函数

### 结构作为函数参数

- 整个结构可以作为参数的值传入函数
- 实际上进行的操作是在函数内新疆一个结构变量，并复制调用者的结构的值
- 也可返回一个结构

## typedef

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;<span class="built_in">point</span>;</span><br></pre></td></tr></table></figure>

h表示声明一个结构，结构名为point</div></article><article><header><h2><a href="/2020/02/05/Answer-and-analysis-of-winter-vacation-C/">寒假C语言作业参考答案</a></h2></header><div class="article-meta clearfix"><time class="left">2020-02-05</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
**按作业发布时间排序（顺序）**

**0218**

>1 阅读程序，写出程序所完成的功能。
>
><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, s=<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++) <span class="comment">//1到7循环7次  </span></span><br><span class="line">  		s=s*i; <span class="comment">//i从1开始变化直到7 </span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">" %d "</span>, s);  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

计算1x1x2x3x4x5x6x7

即计算7！

>2 阅读程序，写出程序所完成的功能。
>
><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span>&#123;   </span><br><span class="line">   <span class="keyword">int</span> digit, i, letter, other; </span><br><span class="line">	<span class="keyword">char</span> ch; </span><br><span class="line">   digit = letter = other = <span class="number">0</span>; </span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">"Enter 20 characters: "</span>);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) <span class="comment">//循环20次&#123;   </span></span><br><span class="line">       ch = getchar(); <span class="comment">//依次读取每个字符</span></span><br><span class="line">   	<span class="keyword">if</span> ((ch&gt;= <span class="string">'a'</span>&amp;&amp;ch&lt;= <span class="string">'z'</span>)||(ch&gt;= <span class="string">'A'</span>&amp;&amp;ch&lt;= <span class="string">'Z'</span>)) <span class="comment">//判断是否属于大写或小写字母</span></span><br><span class="line">       	letter ++; </span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) <span class="comment">//是否为数字</span></span><br><span class="line">       	digit ++;</span><br><span class="line">   	<span class="keyword">else</span>  </span><br><span class="line">           other ++; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"%d, %d, %d\n"</span>, letter, digit, other);   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

统计20个字符中字母和数字以及其他的个数

>3 阅读程序，写出程序所完成的功能。
>
><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> count, num;	  </span><br><span class="line"><span class="keyword">double</span> grade, total;   </span><br><span class="line">num = <span class="number">0</span>;  total = <span class="number">0</span>;  count = <span class="number">0</span>;  			<span class="built_in">printf</span>(<span class="string">"Enter grades: "</span>);	   </span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%lf"</span>, &amp;grade);   </span><br><span class="line">	<span class="keyword">while</span>(grade &gt;= <span class="number">0</span>)&#123; <span class="comment">//输入一个负数就停止输入 </span></span><br><span class="line">	total = total + grade;	<span class="comment">//计算总成绩	</span></span><br><span class="line">    	num++;	<span class="comment">//计算人数	  </span></span><br><span class="line">   	<span class="keyword">if</span> (grade &lt; <span class="number">60</span>)</span><br><span class="line">           count++;   <span class="comment">//计算小于60分的人数 </span></span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%lf"</span>, &amp;grade);	   </span><br><span class="line">   &#125;  </span><br><span class="line">	<span class="keyword">if</span>(num != <span class="number">0</span>)&#123;  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" %.2f\n"</span>, total / num);   </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" %d\n"</span>, count);  </span><br><span class="line">   &#125;   </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

计算平均成绩和低于60分的人数

>4 阅读程序，写出程序所完成的功能。
>
><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt; </span></span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, n;  </span><br><span class="line"><span class="keyword">double</span> power;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">15</span> ; i++)&#123; <span class="comment">//从0到15</span></span><br><span class="line">       power = <span class="built_in">pow</span>(<span class="number">2</span>,i); <span class="comment">//计算2的i次方    </span></span><br><span class="line">  		<span class="built_in">printf</span> (<span class="string">"pow(2,%d)= %.0f\n"</span>, i,power);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
>
>

计算2的0到15次方并打印

##### 作业20200212

> 1.从键盘输入一个正整数，判断是几位数？并输出其最高位的数字。
>
>  例如输入： 362 输出 3位数，最高位是3

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,c = <span class="number">0</span>,high;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;<span class="comment">//对0进行特殊化</span></span><br><span class="line">    	c = <span class="number">1</span>;</span><br><span class="line">    	high = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(x)&#123;<span class="comment">//循环直至x为0时停止</span></span><br><span class="line">			<span class="keyword">if</span>(x &lt; <span class="number">10</span> )&#123;<span class="comment">//当x只剩下一位时，这一位即为最高位</span></span><br><span class="line">	            high = x;</span><br><span class="line">        	&#125;</span><br><span class="line">	        x /= <span class="number">10</span>; <span class="comment">//去掉数字的末尾位</span></span><br><span class="line">	        c++; <span class="comment">//数字位数+1</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d位数，最高位是%d"</span>,c,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

>2.猜棋子游戏。桌子上有25颗棋子。游戏双方分别是计算机和参与人。
>
> 轮流取子，每方每次最少取走一颗棋子，最多可取走3颗棋子。
>
> 双方一直轮流直到棋子取完。最终哪方所取得棋子数是偶数则胜出。
>
> 计算机取子数量由程序控制随机选取，参与人取子则键盘输入。
>
> 若由参与人先取，请编写程序完成游戏过程，显示计算机每次的取值。
>
> 计算机是否可以是“常胜将军”？
>
>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p,r;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">25</span>,pt = <span class="number">0</span>,rt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请输入1-3中的一个数\n"</span>);</span><br><span class="line">		start:</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p);</span><br><span class="line">		<span class="keyword">if</span>(p &gt;= <span class="number">1</span> &amp;&amp; p &lt;= <span class="number">3</span> &amp;&amp; p &lt;= x)&#123; <span class="comment">//确保p在1-3之间且避免出现有两个棋子拿3个的情况</span></span><br><span class="line">			x -= p; <span class="comment">//棋子数-p</span></span><br><span class="line">			pt += p; <span class="comment">//你拥有的棋子火速+p</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"现在还剩%d个棋子,你共有%d个棋子\n"</span>,x,pt);</span><br><span class="line">			 </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"数据超出范围,请重新输入\n"</span>);</span><br><span class="line">			<span class="keyword">goto</span> start; <span class="comment">//我觉得用goto不太好，但是没想到更好的办法</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">0</span>) <span class="comment">//防止出现棋子都取完了，计算机还再取一次的情况</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			srand(time(<span class="literal">NULL</span>));<span class="comment">// 播种</span></span><br><span class="line">			r = rand() % <span class="number">3</span> + <span class="number">1</span>; <span class="comment">//取一个1-3之间的随机数</span></span><br><span class="line">		&#125;<span class="keyword">while</span>(r &gt; x); <span class="comment">//若这个数大于总数则重新取</span></span><br><span class="line">		rt += r;	</span><br><span class="line">		x -= r;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"计算机取走%d个棋子,现在还剩%d个棋子,计算机共有%d个棋子\n"</span>,r,x,rt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n你共取走%d个棋子，计算机共取走%d个棋子\n"</span>,pt,rt);</span><br><span class="line">	<span class="keyword">if</span>(pt % <span class="number">2</span> == <span class="number">0</span>)&#123;<span class="comment">//判断你手上的棋子是否位偶数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n你获胜了"</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n计算机获胜"</span>); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**计算机是否为常胜将军涉及到了博弈论，不会**

<hr>


##### 作业20200201

题目

> 1.编写程序，对于给定的一个百分制整数成绩，输出相应的五等级成绩。
>
> 设：90--100为‘A’；80--89分为 ‘B’；70--79分为‘C’；60--69分为‘D’;60分以下为 ‘E’。
>
> 例如：输入 75 则输出 C

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一题可以使用if判断成绩的范围输出相应结果，也可使用switch，这里使用swiitch</span></span><br><span class="line"><span class="comment">//原谅我乱七八糟的变量名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,temp;</span><br><span class="line">	<span class="keyword">char</span> g; <span class="comment">//定义变量g，用于储存成绩的等级</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x); <span class="comment">//输入成绩</span></span><br><span class="line">	temp = x / <span class="number">10</span>; <span class="comment">//取成绩的十位数字</span></span><br><span class="line">	<span class="keyword">if</span>(x &gt; <span class="number">100</span> || x &lt;<span class="number">0</span>)&#123; <span class="comment">//判断输入成绩是否越界</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            g = <span class="string">'A'</span>;  <span class="comment">//判断成绩，并将等级赋给g</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        	g = <span class="string">'B'</span>;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        	g = <span class="string">'C'</span>;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        	g = <span class="string">'D'</span>;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        	g = <span class="string">'E'</span>;</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,g); <span class="comment">//输出等级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

> 2.编写程序，用户输入星期的数字1—7，输出相应的英文表示.
>
> 例如：输入 1 则输出 Monday

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与第一题思路相同，可以使用switch也可以使用if</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Monday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">2</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Tusday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Wednesday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">4</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Thursday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">5</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Friday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">6</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Saturday"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">7</span>)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"Sunday"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

> 3.编写程序，输入x op y，x和y是运算数据，op是运算符，然后输出该运算的结果。设定只能识别 + - * /四种运算。
>
>  例如：输入3+5 则输出 8

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路大概就是将输入拆分，分别对应x，op，y，xy储存两个数字，op储存运算符号，用if进行判断做出相应运算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">char</span> op,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//此函数用于判断和计算</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">'+'</span>)</span><br><span class="line">    	res = x + y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'-'</span>)</span><br><span class="line">    	res = x - y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'*'</span>)</span><br><span class="line">    	res = x * y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">'/'</span>)</span><br><span class="line">    	res = x / y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,op;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%c%d"</span>,&amp;x,&amp;op,&amp;y);<span class="comment">//读取数字和运算符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum(x,op,y)); <span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这题还有跟简单的做法，只不过我不会</span></span><br></pre></td></tr></table></figure>

> 4.编写程序，输出分数序列：2/1，3/2，5/3，8/5，...... 的前20项.

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出这是一道找规律的题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,x = <span class="number">2</span>,y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)&#123; <span class="comment">//for循环输出前20项</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d/%d "</span>,x,y);</span><br><span class="line">        x += y; <span class="comment">//这两句就是规律</span></span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

> 5.如果密码组成只能用a,b,c,d,e,f,g,h共8个字符，可以组成哪些4位的密码，共有多少个？编写程序进行解答。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用四重for循环，应该是对的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">9</span>] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>&#125;; <span class="comment">//用一个数组把这几个数存起来</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(a = <span class="number">0</span>;a &lt; <span class="number">8</span>;a++)&#123; <span class="comment">//遍历数组下标</span></span><br><span class="line">    	<span class="keyword">for</span>(b = <span class="number">0</span>;b &lt; <span class="number">8</span>;b++)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(c = <span class="number">0</span>;c &lt; <span class="number">8</span>;c++)&#123;</span><br><span class="line">    			<span class="keyword">for</span>(d = <span class="number">0</span>;d &lt; <span class="number">8</span>;d++)&#123;</span><br><span class="line">    				<span class="built_in">printf</span>(<span class="string">"%c%c%c%c "</span>,x[a],x[b],x[c],x[d]);</span><br><span class="line">    				num++; <span class="comment">//计数</span></span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n共计%d种组合"</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应该也有更简单的方法</span></span><br></pre></td></tr></table></figure>

</div></article><article><header><h2><a href="/2020/02/05/markdown-Grammatical-summary/">markdown基础语法</a></h2></header><div class="article-meta clearfix"><time class="left">2020-02-05</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
### 基础语法

#### 强调

斜体可用两个*表示，将内容放入星号间即可

效果：*123*

加粗使用两个**

效果：**123**

#### 标题

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 2</span><br><span class="line">## 2</span><br><span class="line">### 2</span><br><span class="line">#### 2</span><br><span class="line">##### 2 </span><br><span class="line">###### 2</span><br></pre></td></tr></table></figure>

效果：

# 2
## 2
### 2
#### 2
##### 2 
###### 2

**注意最后一个#与文字之间需要一个空格**

#### 引用

引用使用 >

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; 123</span><br><span class="line">&gt; 456</span><br><span class="line">&gt;&gt; 789</span><br><span class="line">&gt;  &#x2F;&#x2F;表示嵌套结束</span><br><span class="line">&gt; 0</span><br></pre></td></tr></table></figure>

效果：

> 123
> 456
> > 789
>
> 0

#### 列表

##### 有序列表

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 1</span><br><span class="line">2. 1</span><br><span class="line">4. 1 &#x2F;&#x2F;实际显示与编号不一致</span><br></pre></td></tr></table></figure>

效果：

1. 1
2. 1
4. 1

##### 无序列表

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line"></span><br><span class="line">+ 1</span><br><span class="line">+ 2</span><br><span class="line"></span><br><span class="line">* 1</span><br><span class="line">* 2</span><br></pre></td></tr></table></figure>

效果：

- 1
- 2

+ 1
+ 2

* 1
* 2

**注意+-*不可混用**



##### 嵌套列表

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 1</span><br><span class="line">- 1</span><br><span class="line">	- 2</span><br><span class="line">	- 2</span><br><span class="line">		- 3</span><br><span class="line">- 1 &#x2F;&#x2F;使用一个制表符表示提高一级</span><br></pre></td></tr></table></figure>

- 1
- 1
	- 2
	- 2
		- 3
- 1

#### 分割线

三个或更多-_*

效果：

1

***

2

</div></article><div class="archive-pagination"><div class="paginator"><a class="extend prev" rel="prev" href="/page/2/">&amp;laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span></div></div></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>Simple Block 是一个基于线框设计的简单的 Hexo 主题，拆分自 <a href="https://jysperm.me" target="_blank" rel="noopener">精子的博客</a>。
支持使用 Jade 或 Markdown 来向边栏添加小部件，或向正文前添加横幅。</p>
<p>技术栈：</p>
<ul>
<li>Jade - 页面模板</li>
<li>Less/Sass - 页面样式</li>
<li>Bower - 前端包管理器</li>
<li>CoffeeScript - Hexo 拓展脚本</li>
<li>Gulp - 编译工具</li>
</ul>
</div><div class="widget tags"></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a>&nbsp; 授权发布。最后生成于 2020-08-05.</p></div></div></div></div></body></html>