<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="alternate" type="application/rss+xml" title="Verge's Blog" href="https://jysperm.me/atom.xml"><link rel="stylesheet" href="/styles.css"><title>图（Graph） | Verge's Blog</title><meta name="generator" content="Hexo 4.2.1"></head><body><div class="container"><div class="columns page-header"><h1>Verge's Blog</h1></div><div class="columns"><div class="navigation"><nav class="menus-main"><a href="/" class="favicon"><img alt="Verge's Blog" src="/favicon.png"></a><a href="/">Home</a></nav><nav class="right menus-right"><a href="/atom.xml">RSS</a><a target="_blank" href="hexo-theme-simpleblock">fork on Github</a></nav></div></div><div class="columns"><div class="block-body column three-fourths"><div class="article-widget"><a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">与精子同款的博客主题 simpleblock 现已发布！</a></div><article><header><small class="right"><a target="_blank" href="null_posts%2Fgraph.md">查看源代码</a></small><h1>图（Graph）</h1></header><div class="article-meta clearfix"><time class="left">2020-04-26</time><ul class="tags left"></ul><ul class="tags right"></ul></div><div class="markdown-body">
[TOC]

### 图（Graph）

- 表示多对多的关系
- 包含
  - 一组顶点:通常用V（Vertex）表示顶点集合
  - 一组边：通常用E（Edge）表示边的集合
    - 边是顶点对：（v,w）属于E，v,w属于V
    - 有向边<v,w>表示从v指向w的边（单行线）
    - 不考虑重边和自回路

#### 抽象数据类型定义

- 类型名称：图（Graph）
- 操作对象集：G（V，E）由一个非空的有限顶点集合V和一个有限边集合E组成
- 操作集
  - Graph Create()
  - Graph InsertVertex(Graph G,Vertex V)
  - Graph InsertEdge(Graph G,Edge e)
  - void DFS(Graph G,Vertex v)
  - void BFS(Graph G,Vertex v)
  - void ShortestPath(Graph G,Vertex v,int Dist[])
  - void MST(Graph G)最小生成树

#### 如何表示一个图

- 邻接矩阵
  - 有边记为1
  - 优缺点
    - 直观简单，方便查找任意一对顶点之间是否有边，方便查找任一顶点的所有邻接点（有边直接相连的顶点）
    - 方便计算任意顶点的度
      - 无向图：对应行或列非零元素个数
      - 有向图：非零行是出度，非零列的入度
    - 若是稀疏矩阵的话会造成空间浪费以及时间浪费

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;<span class="comment">//定点数</span></span><br><span class="line">    <span class="keyword">int</span> Ne;<span class="comment">//边数</span></span><br><span class="line">    WeightType G[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    DataType Data[MaxVertexNum]; <span class="comment">//顶点包含的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode MGraph;</span><br></pre></td></tr></table></figure>

MGraph创建并初始化

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Vertex;</span><br><span class="line"><span class="function">MGraph <span class="title">CreateGraph</span><span class="params">(<span class="keyword">int</span> VertexNum)</span></span>&#123;</span><br><span class="line">    Vertex V,W;</span><br><span class="line">    MGraph Graph;</span><br><span class="line">    Graph = (MGraph)mallcon(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    Graph-&gt;Nv = VertexNum;</span><br><span class="line">    Graph-&gt;Ne = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把Graph全部置为0</span></span><br><span class="line">    <span class="keyword">for</span>(V = <span class="number">0</span>;V &lt; Graph-&gt;Nv;V++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(W = <span class="number">0</span>;W &lt; Graph-&gt;Nv;W++)&#123;</span><br><span class="line">            Graph-&gt;G[V][W] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

向MGraph插入边

 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">PtrToENode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>&#123;</span></span><br><span class="line">	Vertex V1,V2;</span><br><span class="line">    WeightType Weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToENode Edge;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(MGraph Graph,Edge E)</span></span>&#123;</span><br><span class="line">	Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;</span><br><span class="line">    <span class="comment">//若为无向图，则还要插入边（V2，V1）</span></span><br><span class="line">    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

建立完整的MGraph

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MGraph <span class="title">BuildGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MGraph Grpah;</span><br><span class="line">    Edge E;</span><br><span class="line">    Vertex V;</span><br><span class="line">    <span class="keyword">int</span> Nv,i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph = CreateGraph(Nv);</span><br><span class="line">    scnaf(<span class="string">"%d"</span>,&amp;(Graph-&gt;Ne));</span><br><span class="line">    <span class="keyword">if</span>(Graph-&gt;Ne != <span class="number">0</span>)&#123;</span><br><span class="line">		E = (Edge)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; Graph-&gt;Ne;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);</span><br><span class="line">            InsertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//读入数据</span></span><br><span class="line">        <span class="keyword">for</span>(V = <span class="number">0</span>;V &lt; Graph-&gt;Nv;V++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;Data[V]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**这个矩阵存的是顶点与顶点间的关系**

- 邻接表
  - 用一个指针数组，对应矩阵每行一个元素，只存非零元素
    - 优缺点
      - 对于稀疏矩阵在时间和空间上的表现都比较好
      - 方便找任意顶点的邻接点
      - 方便计算任一顶点的度
        - 无向图：是
        - 有向图：否，只能计算出度，需要构造逆邻接表
      - 难以检查任意一对顶点间是否存在边
- 用一个长为N(N+1)/2的一维数组表示
  - Gij在这个数组中对应的下标为(i*(i+1)/2+j) 

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">Vnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	PtrToAdjVNode FirstEdge;</span><br><span class="line">    DataType Data;</span><br><span class="line">&#125;AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> Nv;</span><br><span class="line">    <span class="keyword">int</span> Ne;</span><br><span class="line">    AdjList G;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToGNode LGraph;</span><br></pre></td></tr></table></figure>



#### 图的遍历

##### 深度优先搜索(Depth First Search,DFS)

思路:从起点出发，挑视线内一盏灯点亮，然后走到刚刚点亮的等上，继续重复，如果视线内所有灯都被点亮，就原路返回，退后一格，然后继续看，直到退到起点

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">	visited[V] = ture;</span><br><span class="line">    <span class="keyword">for</span>(V的每个邻接点W)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[W]) DFS(W);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

##### 广度优先搜素(Breath First Search,BFS)

与树的层序遍历类似

思路：从起点开始，把所有邻接点压入队列，然后弹出一个，再把这的结点的所有邻接点压入队列，重复直至队列空

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Vertex V)</span></span>&#123;</span><br><span class="line">    visited[V] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(V,Q);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        V = Dequeue(Q);</span><br><span class="line">        <span class="keyword">for</span>(V的每个邻接点W)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visited[W])&#123;</span><br><span class="line">				visited[W] = <span class="literal">true</span>;</span><br><span class="line">                Enqueue(W,Q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 最短路问题

分类：

- 单源最短路径问题：从某固定点出发，求其到所有其他顶点的最短路径
  - 有向无权图
  - 有向有权图
- 多源最短路问题：求任意两顶点间的最短路径

##### 单源有向无权图的最短路

**无权图的最短路可以认为是，从起点到终点经过的顶点数最少的路**

与BFS有点类似

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Unweighted</span><span class="params">(Vertex S)</span></span>&#123;</span><br><span class="line">	Enqueue(S,Q);<span class="comment">//先把这个结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">		 V = Dequeue(Q);<span class="comment">//弹出一个元素</span></span><br><span class="line">    	<span class="keyword">for</span>(V 的每个邻接点 W)<span class="comment">//遍历V的每个邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(dist[W] == <span class="number">-1</span>)&#123;<span class="comment">//如果W没有被访问过就执行以下操作</span></span><br><span class="line">			dist[W] = dist[V]+<span class="number">1</span>;<span class="comment">//S到W的距离变成，S到他前一个结点V的距离+1</span></span><br><span class="line">            path[W] = V;<span class="comment">//要到达W就要经过V，把v存起来</span></span><br><span class="line">            Enqueue(W,Q);<span class="comment">//把这个结点入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

因为每次找的都是这个结点的邻接点，因此最后出来的结果是最短的

path存储来这个结点的结点，只要一直网下推，就能推出整条最短路

##### 单源有向有权图

**权重和最小 **

**Dijkatra算法**

- 令s = {源点s + 已经确定了从s到的最短路径的顶点v}
- 对于任何一个没有收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径**仅经过s中的顶点**，即{s -> (v属于s) -> v}的最小长度(这个最小长度不是最终的最小长度)
  - 前提条件：路径是按照递增的顺序生成的
  - 真正的最短路必须只经过s中的顶点，因为，假设一个顶点不在s中，但从源点到v经过他，这时就产生了矛盾，因为路径书按照递增顺序生成的
  - 每次从未收录的顶点中选一个dist最小的收录
  - 增加一个v进入s，可能会影响另外一个w的dist值 
    - 要产生这样的结果要满足
    - v在s到w的路径上
    - v到w一定有一条直接的边，因为路径按照递增顺序生成

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Vertex s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        V = 为收录顶点中dist最小者;</span><br><span class="line">        <span class="keyword">if</span>(这样的V不存在) <span class="keyword">break</span>;</span><br><span class="line">        collected[V] = <span class="literal">true</span>;<span class="comment">//用来标记结点是否被收录</span></span><br><span class="line">        <span class="keyword">for</span>(V 的每个邻接点 W)</span><br><span class="line">            <span class="keyword">if</span>(collected[W] == <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span>(dist[V] + E(v到w的距离) &lt; dist[W])&#123;<span class="comment">//如果原来s到w的距离大于，s到v加上v到w的距离那么就改变s到w的最短路径</span></span><br><span class="line">                    dist[W] = dist[V]+E(V到W的距离);</span><br><span class="line">                    path[W] = V;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="block-sidebar column one-fourth"><div class="widget text-content"><p>Simple Block 是一个基于线框设计的简单的 Hexo 主题，拆分自 <a href="https://jysperm.me" target="_blank" rel="noopener">精子的博客</a>。
支持使用 Jade 或 Markdown 来向边栏添加小部件，或向正文前添加横幅。</p>
<p>技术栈：</p>
<ul>
<li>Jade - 页面模板</li>
<li>Less/Sass - 页面样式</li>
<li>Bower - 前端包管理器</li>
<li>CoffeeScript - Hexo 拓展脚本</li>
<li>Gulp - 编译工具</li>
</ul>
</div><div class="widget tags"></div><div class="widget archives"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">3</span></li></ul></div><div class="widget text-content"><p>该博客使用基于 &nbsp;<a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a>&nbsp; 的 &nbsp;<a href="https://github.com/jysperm/hexo-theme-simpleblock" target="_blank" rel="noopener">simpleblock</a>&nbsp; 主题。博客内容使用 &nbsp;<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn" target="_blank" rel="noopener">CC BY-NC-SA 3.0</a>&nbsp; 授权发布。最后生成于 2020-08-05.</p></div></div></div></div></body></html>